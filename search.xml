<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>libuv源码分析（5）uv_fs_*</title>
      <link href="/2019/11/26/libuv5/"/>
      <url>/2019/11/26/libuv5/</url>
      
        <content type="html"><![CDATA[<h4 id="uv-fs"><a href="#uv-fs" class="headerlink" title="uv_fs_*"></a>uv_fs_*</h4><p>&emsp;&emsp;uv_fs_*这一系列的函数基本是一致的，它们的逻辑大概是如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x代表一种操作open、write等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_x</span><span class="params">(...<span class="keyword">uv_fs_t</span>* req...)</span> </span>&#123;</span><br><span class="line">  INIT(x); <span class="comment">//uv_fs_t和其基类uv_req_t的基本初始化</span></span><br><span class="line">  ... <span class="comment">//这里是每个操作各自不同对于req的初始化</span></span><br><span class="line">  POST; <span class="comment">//提交这个任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h4><p>&emsp;&emsp;INIT这个宏定义函数没有特别的地方，就是把req初始化，该置0的置0。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>&emsp;&emsp;其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST                          </span></span><br><span class="line">  <span class="keyword">do</span> &#123;   <span class="comment">//dowhile包裹作用域          </span></span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>) &#123;                 </span><br><span class="line">      uv__req_register(loop, req);    </span><br><span class="line">      uv__work_submit(loop,           </span><br><span class="line">      &amp;req-&gt;work_req,                 </span><br><span class="line">      UV__WORK_FAST_IO,               </span><br><span class="line">      uv__fs_work,                    </span><br><span class="line">      uv__fs_done);                   </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                       </span><br><span class="line">    &#125;                                 </span><br><span class="line">    <span class="keyword">else</span> &#123;                            </span><br><span class="line">      uv__fs_work(&amp;req-&gt;work_req);    </span><br><span class="line">      <span class="keyword">return</span> req-&gt;result;             </span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;                                   </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里通过有无回调函数来决定调用同步版本还是异步版本。</p><blockquote><p><a href="http://docs.libuv.org/en/v1.x/fs.html" target="_blank" rel="noopener">http://docs.libuv.org/en/v1.x/fs.html</a><br>libuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously.</p></blockquote><p>&emsp;&emsp;uv__fs_work这个函数就是<strong>文件操作的封装</strong>，所有的文件操作都通过这个函数来完成，即使是异步，最终也要在别的线程中同步执行这个函数。 <br><br>&emsp;&emsp;uv__fs_done这个函数会调用用户给的回调函数，这个函数会在uv_run中的is_poll函数中得到执行。</p><p>&emsp;&emsp;uv__work_submit函数的实现是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,struct uv__work* w,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">enum</span> uv__work_kind kind, <span class="keyword">void</span> (*work)(struct uv__work* w),</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> (*done)(struct uv__work* w, <span class="keyword">int</span> status))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq, kind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv_once(&amp;once, init_once);是初始化多个线程，我在<a href="https://lurenaa.github.io/2019/11/18/libuv3/" target="_blank" rel="noopener">我的第三篇文章</a>中有介绍。不过当时对于子线程运行的worker函数没有提及，work函数大概是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)...) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);  </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, struct uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  </span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我去掉了对于slow_io的处理，大致是这样一个过程。</p><p>&emsp;&emsp;一开始线程会卡在uv_cond_wait这里，直到被uv_cond_signal唤醒，如果唤醒时wq队列中有任务，它就会执行任务，w-&gt;work(w)也就是调用uv__fs_work。然后把w放入loop-&gt;wq（为了uv__fs_done的执行）。</p><p>&emsp;&emsp;uv_async_send调用让loop-&gt;wq_async可读，主线程就从uv_run中的uv__io_poll的epoll_pwait中醒来，wq_async的回调函数会遍历loop-&gt;wq执行w-&gt;done。（<a href="https://lurenaa.github.io/2019/11/25/libuv4/" target="_blank" rel="noopener">我的第四篇文章</a>有讲这一部分的详细内容）</p><h4 id="谁来触发uv-cond-signal唤醒子线程呢？"><a href="#谁来触发uv-cond-signal唤醒子线程呢？" class="headerlink" title="谁来触发uv_cond_signal唤醒子线程呢？"></a>谁来触发uv_cond_signal唤醒子线程呢？</h4><p>🥣uv__work_submit中的post函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uv_mutex_lock(&amp;mutex);</span><br><span class="line">...</span><br><span class="line">QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line"><span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">  uv_cond_signal(&amp;cond);</span><br><span class="line">uv_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我再次省略了slow_io的部分，因为它们只是特殊处理。</p><p>&emsp;&emsp;该函数有空闲的线程就唤醒，不然就阻塞该线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（4）async</title>
      <link href="/2019/11/25/libuv4/"/>
      <url>/2019/11/25/libuv4/</url>
      
        <content type="html"><![CDATA[<h4 id="uv-async-init"><a href="#uv-async-init" class="headerlink" title="uv_async_init"></a>uv_async_init</h4><p>&emsp;&emsp;libuv中async的开端在uv_loop_init函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面省略</span></span><br><span class="line">err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;</span><br><span class="line"><span class="comment">//后面省略</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;wq_async是个uv_async_t类型，它用于线程work函数调用最后处理loop-&gt;wq中的回调，暂时不用管,我在<a href="https://lurenaa.github.io/2019/11/26/libuv5/" target="_blank" rel="noopener">我的第五篇文章</a>会讲到它的用途。<br/><br>&emsp;&emsp;我们来看uv_async_init内部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">err = uv__async_start(loop);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_ASYNC);</span><br><span class="line">handle-&gt;async_cb = async_cb;</span><br><span class="line">handle-&gt;pending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;<span class="built_in">queue</span>);</span><br><span class="line">uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第五行以后的操作就是初始化基类uv_handle_t以及子类uv_async_t，然后将这个handle放入loop-&gt;queue(放uv_handle_t的队列)以及放入loop-&gt;async_handles（放uv_async_t的队列）中，然后uv__handle_start中将loop-&gt;active_handles加一。<br/><br>&emsp;&emsp;总而言之，第五行以后的内容就是初始化uv_async_t，可以理解成<strong>uv_async_t的构造函数</strong>。<br/><br>&emsp;&emsp;uv__async_start则不一样，它是初始化函数，它<strong>只会调用一次</strong>（一般情况是在uv_loop_init中调用），我们先看下它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__async_start</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;async_io_watcher.fd != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err = uv__async_eventfd();</span><br><span class="line">  <span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    pipefd[<span class="number">0</span>] = err;</span><br><span class="line">    pipefd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中间省略</span></span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[<span class="number">0</span>]);</span><br><span class="line">  uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN);</span><br><span class="line">  loop-&gt;async_wfd = pipefd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看第三行loop-&gt;async_io_watcher.fd，当你调用过一次这个函数后，loop-&gt;async_io_watcher.fd不会等于-1，以后你初始化uv_async_t类型变量，调用uv_async_init函数时，uv__async_start都是直接返回的。<br><br>&emsp;&emsp;我省略掉了中间如果eventfd没有在当前系统下实现时的兼容性处理。总的来说，就是<strong>初始化loop-&gt;async_io_watcher</strong>。uv__io_t是为epoll设计的结构体。<del>这里你肯定感觉很懵逼，请坚持一下，最后我会梳理一下总体的整个过程。</del><br><br>&emsp;&emsp;uv__io_t的实现是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv__io_t</span>&#123;</span><br><span class="line">  uv__io_cb cb;  <span class="comment">//回调函数 </span></span><br><span class="line">  <span class="keyword">void</span>* watcher_queue[<span class="number">2</span>]; <span class="comment">//放入loop-&gt;watcher_queue</span></span><br><span class="line">  <span class="keyword">void</span>* pending_queue[<span class="number">2</span>]; <span class="comment">//同理</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pevents; <span class="comment">/* Pending event mask i.e. mask at next tick. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> events;  <span class="comment">/* Current event mask. */</span></span><br><span class="line">  <span class="keyword">int</span> fd;  <span class="comment">//文件描述符，用于epoll注册</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里uv__io_init函数是初始化loop-&gt;async_io_watcher这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QUEUE_INIT(&amp;w-&gt;pending_queue);</span><br><span class="line">QUEUE_INIT(&amp;w-&gt;watcher_queue);</span><br><span class="line">w-&gt;cb = cb;</span><br><span class="line">w-&gt;fd = fd; <span class="comment">//前面我们的eventfd</span></span><br><span class="line">w-&gt;events = <span class="number">0</span>;</span><br><span class="line">w-&gt;pevents = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__io_start将loop-&gt;async_io_watcher放入loop-&gt;watcher_queue。还有对于loop-&gt;nfds大小的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (QUEUE_EMPTY(&amp;w-&gt;watcher_queue))</span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loop-&gt;watchers[w-&gt;fd] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  loop-&gt;watchers[w-&gt;fd] = w;</span><br><span class="line">  loop-&gt;nfds++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第四行以后的操作是为了在epoll后，我们得到struct event结构体，我们从event-&gt;data.fd可以得到fd，那<strong>我们如何获取到对应的uv__io_t呢？</strong> 就是通过loop-&gt;watchers这个数组。</p><h4 id="uv-async-send"><a href="#uv-async-send" class="headerlink" title="uv_async_send"></a>uv_async_send</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_send</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Do a cheap read first. */</span></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="keyword">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the other thread we're busy with the handle. */</span></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wake up the other thread's event loop. */</span></span><br><span class="line">  uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the other thread we're done. */</span></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">1</span>, <span class="number">2</span>) != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ACCESS_ONCE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(type, var)  \</span></span><br><span class="line">  (*(<span class="keyword">volatile</span> type*) &amp;(var))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里调用一次ACCESS_ONCE，是为了告诉编译器，handle-&gt;pending可能被其他线程修改，所以别给我乱优化。<br><br>&emsp;&emsp;cmpxchgi是原子操作compare_and_change。pending的有三个取值0，1，2。0代表闲置、1代表忙（比如uv_async_send调用途中）、2代表完成。loop-&gt;async_io_watcher调用uv__async_io时，会遍历loop-&gt;async_handles，通过pending来判断哪些回调该被执行。<br><br>&emsp;&emsp;uv__async_send就是向loop-&gt;async_io_watcher.fd（eventfd）写（这里关系到eventfd的机制，不懂可以man eventfd）。</p><h4 id="整体调用过程"><a href="#整体调用过程" class="headerlink" title="整体调用过程"></a>整体调用过程</h4><p>&emsp;&emsp;这里总体归纳一下async的过程。<br><br>&emsp;&emsp;1.在loop_uv_init中初始化async_io_watcher，它的fd为eventfd，值为0，不可读。<br><br>&emsp;&emsp;2.用户uv_async_init注册uv_async_t变量，被添加到loop-&gt;async_handles，设置回调函数。<br><br>&emsp;&emsp;3.如果对uv_async_t变量调用uv_async_send，那么uv_async_t变量的pending变为2（done），并且向eventfd写，loop-&gt;async_io_watcher可读了。<br><br>&emsp;&emsp;4.在uv_run的uv__io_poll中，每次都会把loop-&gt;watchers注册到epoll中，<strong>第四步这个过程在每次事件循环中都在执行</strong>。如果async_io_watcher的fd不可读，就没它事儿。如果可读，async_io_watcher的回调函数uv__async_io执行，它遍历loop-&gt;async_handles，将其中pending为2的uv_async_t变量移除队列，并执行其回调函数。</p><h4 id="看源码后写的小DEMO：-https-github-com-LurenAA-simple-imitation-of-libuv"><a href="#看源码后写的小DEMO：-https-github-com-LurenAA-simple-imitation-of-libuv" class="headerlink" title="看源码后写的小DEMO： https://github.com/LurenAA/simple_imitation_of_libuv"></a>看源码后写的小DEMO： <a href="https://github.com/LurenAA/simple_imitation_of_libuv" target="_blank" rel="noopener">https://github.com/LurenAA/simple_imitation_of_libuv</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh: connect to host github.com port 22: Connection refused</title>
      <link href="/2019/11/24/problems1/"/>
      <url>/2019/11/24/problems1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> </span><br><span class="line">vim .ssh/config</span><br></pre></td></tr></table></figure><p>你会发现这是一个新文件，在其中添加以下文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 你的用户名（例如97860xx@qq.com）</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>然后保存退出（代码如下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接下来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现下面的画面：<br><img src="../assets/ssh-connect.PNG" alt=""><br>在图片倒数第五行的地方会询问是否建立连接，输入yes即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（3）init_threads</title>
      <link href="/2019/11/18/libuv3/"/>
      <url>/2019/11/18/libuv3/</url>
      
        <content type="html"><![CDATA[<h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>&emsp;&emsp;在我们第一次提交io操作时，会有uv_once被调用，来检测是否初始化过线程池，如果没有则立刻<strong>初始化线程池</strong>。所以说线程池并非一开始在uv_run的时候或者在loop中初始化的，而是在io操作开始前。<br><strong>我以uv_open为例子画一下UML图如下：</strong><br><img src="https://img-blog.csdnimg.cn/20191118023241696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在uv_open中先初始化req，然后准备提交work，提交前会调用uv_once检测是否初始化线程池，没有则初始化。</p><h4 id="init-once"><a href="#init-once" class="headerlink" title="init_once"></a>init_once</h4><p>uv_once实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_ONCE_INIT PTHREAD_ONCE_INIT</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uv_once_t</span> once = UV_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="comment">/* Re-initialize the threadpool after fork.</span></span><br><span class="line"><span class="comment">   * Note that this discards the global mutex and condition as well</span></span><br><span class="line"><span class="comment">   * as the work queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_atfork(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;reset_once))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  init_threads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在uv__work_submit中uv_once是这样被调用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分可以参看TLPI 31.2部分，libuv多做了pthread_atfork的处理。<br>&emsp;&emsp;pthread_atfork注册reset_once函数，在fork之后重置once，保证在libuv循环中如果你fork了一个进程，如果在那个新的进程中你也启动一个libuv，init_threads()能被调用。</p><h4 id="init-threads"><a href="#init-threads" class="headerlink" title="init_threads"></a>init_threads</h4><h6 id="🐤条件变量"><a href="#🐤条件变量" class="headerlink" title="🐤条件变量"></a>🐤条件变量</h6><p>&emsp;&emsp;libuv初始化<strong>条件变量</strong>时，调用自己的uv_cond_init，这个函数只做了一件事情，就是将<strong>条件变量</strong>的时钟设置为相对时间，这一点是值得我们自己写代码时参考的，相对时间不受系统时间的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_cond_init</span><span class="params">(<span class="keyword">uv_cond_t</span>* cond)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="🥛互斥锁"><a href="#🥛互斥锁" class="headerlink" title="🥛互斥锁"></a>🥛互斥锁</h6><p>&emsp;&emsp;初始化<strong>互斥锁</strong>时，调用uv_mutex_init，在DEBUG时，libuv会将<strong>互斥锁</strong>设置为PTHREAD_MUTEX_ERRORCHECK，这样能自我检测是否为死锁，不过这会消耗性能，所以在运行时设置为默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_mutex_init</span><span class="params">(<span class="keyword">uv_mutex_t</span>* mutex)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK)</span></span><br><span class="line">  <span class="keyword">return</span> UV__ERR(pthread_mutex_init(mutex, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PTHREAD_MUTEX_ERRORCHECK<br>This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error.</p></blockquote><h6 id="🥡信号量"><a href="#🥡信号量" class="headerlink" title="🥡信号量"></a>🥡信号量</h6><p>&emsp;&emsp;初始化每个线程时，libuv用<strong>信号量</strong>来保证init_threads函数在初始化完所有线程后退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br></pre></td></tr></table></figure><p>在linux下并且glibc版本大于2.21时，uv_sem_init(&amp;sem, 0)和sem_init(&amp;sem, 0)是一样的，没有额外的处理。<br>线程创建好后，在worker函数中会调用uv_sem_post释放<strong>信号量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="🥚uv-thread-create"><a href="#🥚uv-thread-create" class="headerlink" title="🥚uv_thread_create"></a>🥚uv_thread_create</h6><p>&emsp;&emsp;uv_thread_create做的事情就是<strong>设置线程的stack大小</strong>，然后创建它。<br><img src="https://img-blog.csdnimg.cn/20191118025701932.png" alt="在这里插入图片描述"><br>thread_stack_size函数获取栈大小，有一些是跨平台兼容性的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize(); 和</span><br><span class="line"><span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br></pre></td></tr></table></figure><p>上面两行的限制是来源于pthread_attr_setstacksize函数，一下是pthread_attr_setstacksize函数man手册的一部分。</p><blockquote><p>ERRORS<br>       pthread_attr_setstacksize() can fail with the following error:<br>EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.<br> On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of<br>       the system page size.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">thread_stack_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_STACK, &amp;lim))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lim.rlim_cur != RLIM_INFINITY) &#123;</span><br><span class="line">    <span class="comment">/* pthread_attr_setstacksize() expects page-aligned values. */</span></span><br><span class="line">    lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is</span></span><br><span class="line"><span class="comment">     * too small to safely receive signals on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has</span></span><br><span class="line"><span class="comment">     * the largest MINSIGSTKSZ of the architectures that musl supports) so</span></span><br><span class="line"><span class="comment">     * let's use that as a lower bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ</span></span><br><span class="line"><span class="comment">     * is between 28 and 133 KB when compiling against glibc, depending</span></span><br><span class="line"><span class="comment">     * on the architecture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (lim.rlim_cur &gt;= <span class="number">8192</span>)</span><br><span class="line">      <span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; <span class="number">20</span>;  <span class="comment">/* glibc default. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>😂无趣的是在linux Ubuntus我的环境下测试时，attr的默认stacksize和thread_stack_size函数设置到的是一样的值。下面是我的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_page() &#123;</span><br><span class="line">  rlimit x;</span><br><span class="line">  assert(getrlimit(RLIMIT_STACK, &amp;x) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size = x.rlim_cur - x.rlim_cur % getpagesize();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(stack_size &gt; PTHREAD_STACK_MIN) </span><br><span class="line">    <span class="keyword">return</span> stack_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  assert(pthread_attr_init(&amp;attr) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size;</span><br><span class="line">  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  stack_size = stack_page();</span><br><span class="line">  pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  <span class="keyword">pthread_t</span> p1;</span><br><span class="line">  pthread_create(&amp;p1, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))a, <span class="literal">nullptr</span>);</span><br><span class="line">  pthread_attr_destroy(&amp;attr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（2）uv__loop_alive</title>
      <link href="/2019/11/16/libuv2/"/>
      <url>/2019/11/16/libuv2/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>&emsp;&emsp;上一篇说了一下整体的事件循环，对于UV_RUN_DEFAULT模式来调用uv_run来说，uv__loop_alive就决定了是否退出，这一篇看一下uv__loop_alive的源码。</p><h5 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见loop的状态取决于三个方面：handles、reqs、closing_handles </p><h5 id="handles"><a href="#handles" class="headerlink" title="handles"></a>handles</h5><p>&emsp;&emsp;uv__has_active_handles就是检查loop-&gt;active_handles值是否大于0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_handles(loop)                                          \</span></span><br><span class="line">  ((loop)-&gt;active_handles &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_loop_s</span> <span class="title">uv_loop_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_handle_s</span> <span class="title">uv_handle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_dir_s</span> <span class="title">uv_dir_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> <span class="title">uv_async_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_process_s</span> <span class="title">uv_process_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_event_s</span> <span class="title">uv_fs_event_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_poll_s</span> <span class="title">uv_fs_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_signal_s</span> <span class="title">uv_signal_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;handles列表如上。handle在调用时，会包含一个函数的调用，就是<br>uv__handle_start。下图所示，是哪些函数调用了uv__handle_start。<del>有一些handle不在其中，可能与其调用方式有关，我暂时无法解释</del><br><img src="https://img-blog.csdnimg.cn/20191116181231294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != <span class="number">0</span>) <span class="keyword">break</span>;                          \</span><br><span class="line">    (h)-&gt;flags |= UV_HANDLE_ACTIVE;                                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_REF) != <span class="number">0</span>) uv__active_handle_add(h);          \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__handle_start函数在调用时，会调用uv__active_handle_add，uv__active_handle_add就是将loop-&gt;active_handles++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_add(h)                                              \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相应的在handle结束时有uv__active_handle_rm的调用，(h)-&gt;loop-&gt;active_handles减一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_rm(h)                                               \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="req"><a href="#req" class="headerlink" title="req"></a>req</h5><p>&emsp;&emsp;uv__has_active_reqs和handle的道理一样，是检测(loop)-&gt;active_reqs.count &gt; 0。active_reqs是个共用体，它的另一个用途暂时我还不知道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_reqs(loop)                                             \</span></span><br><span class="line">  ((loop)-&gt;active_reqs.count &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_req_s</span> <span class="title">uv_req_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getaddrinfo_s</span> <span class="title">uv_getaddrinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getnameinfo_s</span> <span class="title">uv_getnameinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_shutdown_s</span> <span class="title">uv_shutdown_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_write_s</span> <span class="title">uv_write_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_connect_s</span> <span class="title">uv_connect_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_send_s</span> <span class="title">uv_udp_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_s</span> <span class="title">uv_fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_work_s</span> <span class="title">uv_work_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__req_register(loop, req)等同于handle的uv__active_handle_add。uv__req_register在uv__req_init中调用，几乎（<del>漏网的暂时没法解释</del> ）每个req在初始化时都调用了uv__req_init。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_init(loop, req, typ)                                          \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    UV_REQ_INIT(req, typ);                                                    \</span><br><span class="line">    uv__req_register(loop, req);                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_register(loop, req)                                           \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图所示是那些函数调用了uv__req_init，由名称我们可以看出来它们是属于哪些req的。<br><img src="https://img-blog.csdnimg.cn/20191116181900253.png" alt="在这里插入图片描述"><br>&emsp;&emsp;同理，还有uv__req_unregister。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_unregister(loop, req)                                         \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(uv__has_active_reqs(loop));                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="closing-handles"><a href="#closing-handles" class="headerlink" title="closing_handles"></a>closing_handles</h5><p>&emsp;&emsp;要关闭的handle会以链表的形式挂在loop-&gt;closing_handles上。这个操作通过调用uv__make_close_pending来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__make_close_pending</span><span class="params">(<span class="keyword">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class="line">  assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class="line">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class="line">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果closing_handles不为空，那么还需要进入事件循环，去调用关闭的handle的回调函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（1）事件循环分析</title>
      <link href="/2019/11/16/libuv1/"/>
      <url>/2019/11/16/libuv1/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>&emsp;&emsp;libuv总是报出一些让人难以理解的错误😂，作为一个C的项目，不具有Java、JavaScript、php那样的人气，很难百度到一些问题的答案，甚至google也不行。为了用好libuv，也为了学习吧。我开始看libuv的源码，不知道自己能走多远。。。</p></blockquote><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><img src="https://img-blog.csdnimg.cn/20191116165040610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" width="400" height="500" alt="Event Loop" align=center><p>这是官方事件循环的示意图。<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">链接-&gt;官方图片位置</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;整个事件循环就是在主线程的uv_run（）调用中执行的。我就跟着官方的介绍一步一步来看（<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方介绍</a>）。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><blockquote><p>The loop concept of ‘now’ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls.</p></blockquote><p>&emsp;&emsp;第一步是更新时间。对应代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__update_time(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结来说就是调用这个函数，更新时间。<del>uv__update_time实现我下一篇来介绍</del> </p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><blockquote><p>If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and ref’d handles, active requests or closing handles it’s considered to be alive.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用uv__loop_alive函数获取loop状态。<br>&emsp;&emsp;如果uv__loop_alive返回零或者loop-&gt;stop_flag == 1说明loop终止，直接跳过循环，到代码最下面（<del>这里有一些性能的处理暂时不管</del> ），退出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;stop_flag == 0的一个来源是调用了uv_stop，这个函数在手册中看见。它的源代码也很清晰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv_stop</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  loop-&gt;stop_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果loop状态OK，那么就进入循环中。</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><blockquote><p>Due timers are run. All active timers scheduled for a time before the loop’s concept of now get their callbacks called.</p></blockquote><p>&emsp;&emsp;对应代码这一部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uv__run_timers(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min(timer_heap(loop));</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将堆里面已经超时的拿出来运行。</p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><blockquote><p>Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point.</p></blockquote><p>对应：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ran_pending = uv__run_pending(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将loop-&gt;pending_queue中的任务拿出来运行。</p><h5 id="第五、六、九步"><a href="#第五、六、九步" class="headerlink" title="第五、六、九步"></a>第五、六、九步</h5><blockquote><p>5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active</p></blockquote><blockquote><p> 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O.</p></blockquote><blockquote><p>9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv__run_idle(loop);</span><br><span class="line">uv__run_prepare(loop);</span><br><span class="line">uv__run_check(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三部为什么要一起说呢？因为它们的实质是一样的。在每次循环固定的位置调用。<br>&emsp;&emsp;这三个函数定义在loop-watcher.c这个文件里面，它们是用宏定义定义的。只改了idle、prepare、check这三个名字的部分，其余部分函数都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the "Software"), to</span></span><br><span class="line"><span class="comment"> * deal in the Software without restriction, including without limitation the</span></span><br><span class="line"><span class="comment"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></span><br><span class="line"><span class="comment"> * sell copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"> * all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></span><br><span class="line"><span class="comment"> * IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"internal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \</span></span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123;              \</span></span><br><span class="line">    uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_##type);                   \</span><br><span class="line">    handle-&gt;name##_cb = <span class="literal">NULL</span>;                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line">    <span class="keyword">if</span> (uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                      \</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) <span class="keyword">return</span> UV_EINVAL;                                         \</span><br><span class="line">    QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;<span class="built_in">queue</span>);         \</span><br><span class="line">    handle-&gt;name##_cb = cb;                                                   \</span><br><span class="line">    uv__handle_start(handle);                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line">    <span class="keyword">if</span> (!uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                     \</span><br><span class="line">    QUEUE_REMOVE(&amp;handle-&gt;<span class="built_in">queue</span>);                                             \</span><br><span class="line">    uv__handle_stop(handle);                                                  \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__run_#<span class="meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">    uv_#<span class="meta">#name##_t* h;                                                         \</span></span><br><span class="line">    QUEUE <span class="built_in">queue</span>;                                                              \</span><br><span class="line">    QUEUE* q;                                                                 \</span><br><span class="line">    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="built_in">queue</span>);                                \</span><br><span class="line">    <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;                                            \</span><br><span class="line">      q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);                                                 \</span><br><span class="line">      h = QUEUE_DATA(q, uv_##name##<span class="keyword">_t</span>, <span class="built_in">queue</span>);                                \</span><br><span class="line">      QUEUE_REMOVE(q);                                                        \</span><br><span class="line">      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">      h-&gt;name##_cb(h);                                                        \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__#<span class="meta">#name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line">    uv_#<span class="meta">#name##_stop(handle);                                                 \</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(check, CHECK)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(idle, IDLE)</span><br></pre></td></tr></table></figure><h5 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h5><blockquote><p>Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:<br>If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.<br>If the loop is going to be stopped (uv_stop() was called), the timeout is 0.<br>If there are no active handles or requests, the timeout is 0.<br>If there are any idle handles active, the timeout is 0.<br>If there are any handles pending to be closed, the timeout is 0.<br>If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这部分是取决于uv_run的模式的特殊处理，暂时不细看。</p><h5 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h5><blockquote><p>The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__io_poll(loop, timeout);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分对于不同操作系统有所不同，linux是poll，mac是kqueue。</p><h5 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h5><blockquote><p>Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__run_closing_handles(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用各类的close回调函数。</p><h5 id="第十一、十二步"><a href="#第十一、十二步" class="headerlink" title="第十一、十二步"></a>第十一、十二步</h5><blockquote><p>11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.<br>12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if it’s still alive, otherwise it will also end.</p></blockquote><p>&emsp;&emsp;对于uv_run不同模式的一点特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;宏观上梳理一下整个事件循环的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(2.5)</title>
      <link href="/2019/08/14/rax3/"/>
      <url>/2019/08/14/rax3/</url>
      
        <content type="html"><![CDATA[<h5 id="点点废话"><a href="#点点废话" class="headerlink" title="点点废话"></a>点点废话</h5><p>&emsp;&emsp;最近没有再将rax的源码往下看，rax对于一个新手来说还是体量过大，在尝试自己写写，在写的时候遇到了一些坑，也体会到了rax的一些写法的精妙之处，记录一下。</p><hr><h5 id="宏定义函数的注意点："><a href="#宏定义函数的注意点：" class="headerlink" title="宏定义函数的注意点："></a>宏定义函数的注意点：</h5><p>&emsp;&emsp;我定义了这样一个宏定义函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define radixNthChild(h, n) \</span><br><span class="line">  (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*))</span><br></pre></td></tr></table></figure><p>我这样调用这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radixNthChild(new_cur, new_cur-&gt;size - 1)</span><br></pre></td></tr></table></figure><p>这样一个调用大家觉得有问题吗？嗯，肯定是有问题的，不然我说啥?。</p><p>这里，按照我们一般的调用函数的思路，这样一个调用的运行过程是这样的：</p><ol><li>计算出new_cur-&gt;size - 1</li><li>带入radixNthChild函数</li></ol><p>实际上恰恰相反，<strong>宏定义的处理在预编译时（g++ -E）</strong>，宏定义是将对于的定义替换掉，所以在<br>预编译后的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 363 &quot;radix_tree.c&quot;</span><br><span class="line">    memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*));</span><br></pre></td></tr></table></figure><p>可以看到是 ： + new_cur-&gt;size - 1 * sizeof(void<em>)<br>而不是我所想的： + （new_cur-&gt;size - 1） * sizeof(void</em>)</p><p><strong>可以得出其过程其实是：</strong></p><ol><li>函数宏定义替换</li><li>运行时计算</li></ol><p> <strong>结论： 在宏定义函数调用时注意括号的问题</strong>，不加括号可能会<del>由于运算符优先级而</del> 导致表达式意义与我们想的有出入?</p><hr><h5 id="地址运算注意点"><a href="#地址运算注意点" class="headerlink" title="地址运算注意点"></a>地址运算注意点</h5><p>先给出这样一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct test &#123;</span><br><span class="line">void* a, *b, *c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>int main(void) {cout &lt;&lt; sizeof(test) &lt;&lt; endl;test* p = new test;fprintf(stdout, &quot;%p:%p:%p:%p\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1);return 0;}</code></pre><p>&emsp;&emsp;在这样一个测试代码中，大家觉得p + 1, (char<em>)p + 1, (int</em>)p+1这三个结果，相对于p的数值相差多少呢？<br><img src="https://img-blog.csdnimg.cn/20190814211800282.png" alt="在这里插入图片描述"><br>&emsp;&emsp;运行结果是这样的。类型与地址的运算是有着密切关系的。</p><ul><li>p + 1是一个默认情况， 这时1的意义是一个p的地址宽度</li><li>(char*)p + 1，p被解释为char类型指针，指向的地址被解释为char，于是1就是一个char的地址宽度。</li></ul><p><strong>总结：</strong> 在计算地址时，要注意运算符左边值的类型。你加上的1可能并不是一个字节的大小。</p><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(2)</title>
      <link href="/2019/08/12/rax2/"/>
      <url>/2019/08/12/rax2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天我想要说的是rax中的padding这个函数，我查了很多的资料，大家的博客都告诉我们内存对齐提高性能，却没有去分析为什么，是有根据让作者选择这样做？如果只是这样简单的放过，总感觉让人有一丝的遗憾。</p></blockquote><hr><p>&emsp;&emsp;<br><strong>先把主角拉出来：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define raxPadding(nodesize) </span><br><span class="line">((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先要说的是raxPadding的作用是：让raxNewNode申请的内存nodesize是8的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">raxNode *raxNewNode(size_t children, int datafield) &#123;</span><br><span class="line">    size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+</span><br><span class="line">                      sizeof(raxNode*)*children;</span><br><span class="line">    if (datafield) nodesize += sizeof(void*);</span><br><span class="line">    raxNode *node = rax_malloc(nodesize);</span><br><span class="line">    if (node == NULL) return NULL;</span><br><span class="line">    node-&gt;iskey = 0;</span><br><span class="line">    node-&gt;isnull = 0;</span><br><span class="line">    node-&gt;iscompr = 0;</span><br><span class="line">    node-&gt;size = children;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第一个问题：对齐的优势"><a href="#第一个问题：对齐的优势" class="headerlink" title="第一个问题：对齐的优势"></a>第一个问题：对齐的优势</h6><p>&emsp;&emsp;这个并不是我想说的重点，这里是大家都谈到的，也就是<strong>经过内存对齐之后，CPU的内存访问速度大大提升</strong>。对于我来说，这个结论感觉还是太模糊，这是一个定性的结论，具体的底层细节对于我们初学者来说倒是没必要去深究。</p><h6 id="第二个问题：为什么要这么去做？"><a href="#第二个问题：为什么要这么去做？" class="headerlink" title="第二个问题：为什么要这么去做？"></a>第二个问题：为什么要这么去做？</h6><p>&emsp;&emsp;rax的作者这样的做法其实是<strong>参考结构体的做法</strong>。<br><strong>举个例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct X</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int c;</span><br><span class="line">    double b;</span><br><span class="line">&#125;S2;</span><br></pre></td></tr></table></figure><p>这样一个结构体，它的大小是多少？答案是16。<br>在c语言的内部，做了这样的内存对齐处理：<br><img src="https://img-blog.csdnimg.cn/20190812190523897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>这里转载了<a href="https://www.cnblogs.com/zhoujiayi/p/7872262.html" target="_blank" rel="noopener">这篇文章</a>中的很多资源，大家也可以去看看这篇文章，写的很不错。也有更多例子。</p></blockquote><h5 id="回到rax上来"><a href="#回到rax上来" class="headerlink" title="回到rax上来"></a>回到rax上来</h5><p>&emsp;&emsp; 在rax的raxNode这个结构体中，<del>因为使用了<strong>柔性数组</strong>，所以在c语言本身是无法帮助我们实现像上面一样的内存对齐的（sizeof(raxNode) == 4,我们申请的内存大小决定了柔性数组的长度，详情请百度柔性数组）</del> ，c语言对于结构体的优化没有包含柔性数组这个部分，所以<strong>我们必须自己来接管这一部分的内存对齐，保证程序的运行效率。</strong></p><pre><code>typedef struct raxNode {uint32_t iskey:1;     /* Does this node contain a key? */uint32_t isnull:1;    /* Associated value is NULL (don&apos;t store it). */uint32_t iscompr:1;   /* Node is compressed. */uint32_t size:29;     /* Number of children, or compressed string len. */unsigned char data[];} raxNode;</code></pre><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(1)</title>
      <link href="/2019/08/12/rax1/"/>
      <url>/2019/08/12/rax1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;最近想用libuv写个http服务器，看到了这个开源项目<a href="https://github.com/haywire/haywire" target="_blank" rel="noopener">haywire</a>，在看到第39次提交的时候，作者用基数树来存储不同路由的controller，不过在后续版本中改为了使用hash，不过想来不如正好学学基数树，作者使用的基数树是这个版本<a href="https://github.com/j0sh/radixtree" target="_blank" rel="noopener">radix_tree</a>，这个版本缺少注释，且和一般思路不一样的使用的是二叉树而非N叉树，为了理解方便，我选择了注释较多的<a href="https://github.com/antirez/rax" target="_blank" rel="noopener">rax</a></p></blockquote><hr><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>&emsp;&emsp;首先要提到的是rax的数据结构设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct raxNode &#123;</span><br><span class="line">    uint32_t iskey:1;     /* Does this node contain a key? */</span><br><span class="line">    uint32_t isnull:1;    /* Associated value is NULL (don&apos;t store it). */</span><br><span class="line">    uint32_t iscompr:1;   /* Node is compressed. */</span><br><span class="line">    uint32_t size:29;     /</span><br><span class="line">    unsigned char data[];</span><br><span class="line">&#125; raxNode;</span><br></pre></td></tr></table></figure><p>这里第一个要说到的点是：你觉得这样一个数据结构的大小是多少？24？ 16？ 还是8？<br><img src="https://img-blog.csdnimg.cn/20190811233343948.png" alt="在这里插入图片描述"><br>&emsp;&emsp;<strong>第一个原因</strong>是位域，也就是结构体中的<strong>冒号：</strong>  ，冒号在这里声明实际需要使用的位数，iskey，isnull，iscompr，size四个一共加起来32位，占4个字节。<br>&emsp;&emsp;<strong>第二个原因</strong>是data[]占0个字节。unsigned char data[];这样一个结构在这里并不是理解成一个指针8个字节。而是一个<strong>柔性数组</strong>的概念，实现一个可变长度。data[1]占结构体1个字节，data[2]占结构体2个字节…….data[13]占13个字节。数组类型的内存是结构体中直接分配的，而不是像指针一样需要我们后来分配。如下图可见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct raxNode &#123;</span><br><span class="line">    unsigned char data[13];</span><br><span class="line">&#125; raxNode;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, sizeof(raxNode));</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812000143659.png" alt="在这里插入图片描述"></p><hr><h5 id="data"><a href="#data" class="headerlink" title="data[]"></a>data[]</h5><p>&emsp;&emsp;接下来我们还是要谈data，在这里data的意义并不是一个简单的unsigned char数组，它存储的是键值key和radixNode指针两种变量。<br><img src="https://img-blog.csdnimg.cn/20190812001425256.png" alt="在这里插入图片描述"><br>图来自：<a href="https://my.oschina.net/yunqi/blog/3039132" target="_blank" rel="noopener">https://my.oschina.net/yunqi/blog/3039132</a><br>data的实际使用方式在大多数时候是以<strong>内存地址</strong>的方式进行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define raxNodeLastChildPtr(n) ((raxNode**) ( \</span><br><span class="line">    ((char*)(n)) + \</span><br><span class="line">    raxNodeCurrentLength(n) - \</span><br><span class="line">    sizeof(raxNode*) - \</span><br><span class="line">    (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是访问最后一个节点的函数（也就是访问图中的A-ptr）。n是一个raxNode*指针，对这个指针指向的地址进行＋操作来得到最后一个节点的地址。</p><hr><h5 id="节点的表示"><a href="#节点的表示" class="headerlink" title="节点的表示"></a>节点的表示<img src="https://img-blog.csdnimg.cn/20190812001723801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h5><p>图来自：<a href="https://my.oschina.net/yunqi/blog/3039132" target="_blank" rel="noopener">https://my.oschina.net/yunqi/blog/3039132</a><br>&emsp;&emsp;假设基数树中有“abcd”这个键值的节点。那么它的表示形式是像上图这样的。“abcd”这个节点的value-data存储在图片下半部分的节点处，并且下面一个节点iskey设为1.<br>&emsp;&emsp;<strong>为什么不是直接只有图片的上半部分，由图片上半部分那个节点将iskey设置为1并且将值存储在其value·data中呢？</strong><br>像这样： <strong>[iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr]</strong></p><h4 id="先给出结论：-在rax中一个节点的存在（iskey-1）是由data中对应的子节点来表示的。"><a href="#先给出结论：-在rax中一个节点的存在（iskey-1）是由data中对应的子节点来表示的。" class="headerlink" title="先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。"></a>先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。</h4><p><strong>原因很简单：</strong><br><img src="https://img-blog.csdnimg.cn/20190812002913974.png" alt="在这里插入图片描述"><br>在这个例子里面，这是一个没有压缩的节点，这一层由a和A两个子节点，如果在当前层次表示，如何分辨你指定的是a还是A？所以用引出子节点来表示。</p><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
