<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ssh: connect to host github.com port 22: Connection refused</title>
      <link href="/2019/11/24/ssh-connect-to-host-github-com-port-22-Connection-refused/"/>
      <url>/2019/11/24/ssh-connect-to-host-github-com-port-22-Connection-refused/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> </span><br><span class="line">vim .ssh/config</span><br></pre></td></tr></table></figure><p>ä½ ä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ–‡å­—ï¼š</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User ä½ çš„ç”¨æˆ·åï¼ˆä¾‹å¦‚97860xx@qq.comï¼‰</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>ç„¶åä¿å­˜é€€å‡ºï¼ˆä»£ç å¦‚ä¸‹ï¼‰ã€‚</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>æ¥ä¸‹æ¥æµ‹è¯•ä¸€ä¸‹ï¼š</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>å‡ºç°ä¸‹é¢çš„ç”»é¢ï¼š<br><img src="../assets/ssh-connect.PNG" alt=""><br>åœ¨å›¾ç‰‡å€’æ•°ç¬¬äº”è¡Œçš„åœ°æ–¹ä¼šè¯¢é—®æ˜¯å¦å»ºç«‹è¿æ¥ï¼Œè¾“å…¥yeså³å¯ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> é‡è§çš„é—®é¢˜ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuvæºç åˆ†æï¼ˆ3ï¼‰init_threads</title>
      <link href="/2019/11/18/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89init_threads/"/>
      <url>/2019/11/18/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89init_threads/</url>
      
        <content type="html"><![CDATA[<h4 id="ç”±æ¥"><a href="#ç”±æ¥" class="headerlink" title="ç”±æ¥"></a>ç”±æ¥</h4><p>&emsp;&emsp;åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡æäº¤ioæ“ä½œæ—¶ï¼Œä¼šæœ‰uv_onceè¢«è°ƒç”¨ï¼Œæ¥æ£€æµ‹æ˜¯å¦åˆå§‹åŒ–è¿‡çº¿ç¨‹æ± ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç«‹åˆ»<strong>åˆå§‹åŒ–çº¿ç¨‹æ± </strong>ã€‚æ‰€ä»¥è¯´çº¿ç¨‹æ± å¹¶éä¸€å¼€å§‹åœ¨uv_runçš„æ—¶å€™æˆ–è€…åœ¨loopä¸­åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯åœ¨ioæ“ä½œå¼€å§‹å‰ã€‚<br><strong>æˆ‘ä»¥uv_openä¸ºä¾‹å­ç”»ä¸€ä¸‹UMLå›¾å¦‚ä¸‹ï¼š</strong><br><img src="https://img-blog.csdnimg.cn/20191118023241696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br>åœ¨uv_openä¸­å…ˆåˆå§‹åŒ–reqï¼Œç„¶åå‡†å¤‡æäº¤workï¼Œæäº¤å‰ä¼šè°ƒç”¨uv_onceæ£€æµ‹æ˜¯å¦åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæ²¡æœ‰åˆ™åˆå§‹åŒ–ã€‚</p><h4 id="init-once"><a href="#init-once" class="headerlink" title="init_once"></a>init_once</h4><p>uv_onceå®ç°å¦‚ä¸‹ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_ONCE_INIT PTHREAD_ONCE_INIT</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uv_once_t</span> once = UV_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="comment">/* Re-initialize the threadpool after fork.</span></span><br><span class="line"><span class="comment">   * Note that this discards the global mutex and condition as well</span></span><br><span class="line"><span class="comment">   * as the work queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_atfork(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;reset_once))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  init_threads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>åœ¨uv__work_submitä¸­uv_onceæ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚çœ‹TLPI 31.2éƒ¨åˆ†ï¼Œlibuvå¤šåšäº†pthread_atforkçš„å¤„ç†ã€‚<br>&emsp;&emsp;pthread_atforkæ³¨å†Œreset_onceå‡½æ•°ï¼Œåœ¨forkä¹‹åé‡ç½®onceï¼Œä¿è¯åœ¨libuvå¾ªç¯ä¸­å¦‚æœä½ forkäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œå¦‚æœåœ¨é‚£ä¸ªæ–°çš„è¿›ç¨‹ä¸­ä½ ä¹Ÿå¯åŠ¨ä¸€ä¸ªlibuvï¼Œinit_threads()èƒ½è¢«è°ƒç”¨ã€‚</p><h4 id="init-threads"><a href="#init-threads" class="headerlink" title="init_threads"></a>init_threads</h4><h6 id="ğŸ¤æ¡ä»¶å˜é‡"><a href="#ğŸ¤æ¡ä»¶å˜é‡" class="headerlink" title="ğŸ¤æ¡ä»¶å˜é‡"></a>ğŸ¤æ¡ä»¶å˜é‡</h6><p>&emsp;&emsp;libuvåˆå§‹åŒ–<strong>æ¡ä»¶å˜é‡</strong>æ—¶ï¼Œè°ƒç”¨è‡ªå·±çš„uv_cond_initï¼Œè¿™ä¸ªå‡½æ•°åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å°†<strong>æ¡ä»¶å˜é‡</strong>çš„æ—¶é’Ÿè®¾ç½®ä¸ºç›¸å¯¹æ—¶é—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å€¼å¾—æˆ‘ä»¬è‡ªå·±å†™ä»£ç æ—¶å‚è€ƒçš„ï¼Œç›¸å¯¹æ—¶é—´ä¸å—ç³»ç»Ÿæ—¶é—´çš„å½±å“ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_cond_init</span><span class="params">(<span class="keyword">uv_cond_t</span>* cond)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ğŸ¥›äº’æ–¥é”"><a href="#ğŸ¥›äº’æ–¥é”" class="headerlink" title="ğŸ¥›äº’æ–¥é”"></a>ğŸ¥›äº’æ–¥é”</h6><p>&emsp;&emsp;åˆå§‹åŒ–<strong>äº’æ–¥é”</strong>æ—¶ï¼Œè°ƒç”¨uv_mutex_initï¼Œåœ¨DEBUGæ—¶ï¼Œlibuvä¼šå°†<strong>äº’æ–¥é”</strong>è®¾ç½®ä¸ºPTHREAD_MUTEX_ERRORCHECKï¼Œè¿™æ ·èƒ½è‡ªæˆ‘æ£€æµ‹æ˜¯å¦ä¸ºæ­»é”ï¼Œä¸è¿‡è¿™ä¼šæ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_mutex_init</span><span class="params">(<span class="keyword">uv_mutex_t</span>* mutex)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK)</span></span><br><span class="line">  <span class="keyword">return</span> UV__ERR(pthread_mutex_init(mutex, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PTHREAD_MUTEX_ERRORCHECK<br>This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error.</p></blockquote><h6 id="ğŸ¥¡ä¿¡å·é‡"><a href="#ğŸ¥¡ä¿¡å·é‡" class="headerlink" title="ğŸ¥¡ä¿¡å·é‡"></a>ğŸ¥¡ä¿¡å·é‡</h6><p>&emsp;&emsp;åˆå§‹åŒ–æ¯ä¸ªçº¿ç¨‹æ—¶ï¼Œlibuvç”¨<strong>ä¿¡å·é‡</strong>æ¥ä¿è¯init_threadså‡½æ•°åœ¨åˆå§‹åŒ–å®Œæ‰€æœ‰çº¿ç¨‹åé€€å‡ºã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br></pre></td></tr></table></figure><p>åœ¨linuxä¸‹å¹¶ä¸”glibcç‰ˆæœ¬å¤§äº2.21æ—¶ï¼Œuv_sem_init(&amp;sem, 0)å’Œsem_init(&amp;sem, 0)æ˜¯ä¸€æ ·çš„ï¼Œæ²¡æœ‰é¢å¤–çš„å¤„ç†ã€‚<br>çº¿ç¨‹åˆ›å»ºå¥½åï¼Œåœ¨workerå‡½æ•°ä¸­ä¼šè°ƒç”¨uv_sem_posté‡Šæ”¾<strong>ä¿¡å·é‡</strong>ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="ğŸ¥šuv-thread-create"><a href="#ğŸ¥šuv-thread-create" class="headerlink" title="ğŸ¥šuv_thread_create"></a>ğŸ¥šuv_thread_create</h6><p>&emsp;&emsp;uv_thread_createåšçš„äº‹æƒ…å°±æ˜¯<strong>è®¾ç½®çº¿ç¨‹çš„stackå¤§å°</strong>ï¼Œç„¶ååˆ›å»ºå®ƒã€‚<br><img src="https://img-blog.csdnimg.cn/20191118025701932.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br>thread_stack_sizeå‡½æ•°è·å–æ ˆå¤§å°ï¼Œæœ‰ä¸€äº›æ˜¯è·¨å¹³å°å…¼å®¹æ€§çš„å¤„ç†ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize(); å’Œ</span><br><span class="line"><span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br></pre></td></tr></table></figure><p>ä¸Šé¢ä¸¤è¡Œçš„é™åˆ¶æ˜¯æ¥æºäºpthread_attr_setstacksizeå‡½æ•°ï¼Œä¸€ä¸‹æ˜¯pthread_attr_setstacksizeå‡½æ•°manæ‰‹å†Œçš„ä¸€éƒ¨åˆ†ã€‚</p><blockquote><p>ERRORS<br>       pthread_attr_setstacksize() can fail with the following error:<br>EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.<br> On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of<br>       the system page size.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">thread_stack_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_STACK, &amp;lim))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lim.rlim_cur != RLIM_INFINITY) &#123;</span><br><span class="line">    <span class="comment">/* pthread_attr_setstacksize() expects page-aligned values. */</span></span><br><span class="line">    lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is</span></span><br><span class="line"><span class="comment">     * too small to safely receive signals on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has</span></span><br><span class="line"><span class="comment">     * the largest MINSIGSTKSZ of the architectures that musl supports) so</span></span><br><span class="line"><span class="comment">     * let's use that as a lower bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ</span></span><br><span class="line"><span class="comment">     * is between 28 and 133 KB when compiling against glibc, depending</span></span><br><span class="line"><span class="comment">     * on the architecture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (lim.rlim_cur &gt;= <span class="number">8192</span>)</span><br><span class="line">      <span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; <span class="number">20</span>;  <span class="comment">/* glibc default. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>ğŸ˜‚æ— è¶£çš„æ˜¯åœ¨linux Ubuntusæˆ‘çš„ç¯å¢ƒä¸‹æµ‹è¯•æ—¶ï¼Œattrçš„é»˜è®¤stacksizeå’Œthread_stack_sizeå‡½æ•°è®¾ç½®åˆ°çš„æ˜¯ä¸€æ ·çš„å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘çš„æµ‹è¯•ä»£ç ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_page() &#123;</span><br><span class="line">  rlimit x;</span><br><span class="line">  assert(getrlimit(RLIMIT_STACK, &amp;x) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size = x.rlim_cur - x.rlim_cur % getpagesize();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(stack_size &gt; PTHREAD_STACK_MIN) </span><br><span class="line">    <span class="keyword">return</span> stack_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  assert(pthread_attr_init(&amp;attr) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size;</span><br><span class="line">  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  stack_size = stack_page();</span><br><span class="line">  pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  <span class="keyword">pthread_t</span> p1;</span><br><span class="line">  pthread_create(&amp;p1, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))a, <span class="literal">nullptr</span>);</span><br><span class="line">  pthread_attr_destroy(&amp;attr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuvæºç åˆ†æï¼ˆ2ï¼‰uv__loop_alive</title>
      <link href="/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89uv__loop_alive/"/>
      <url>/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89uv__loop_alive/</url>
      
        <content type="html"><![CDATA[<h5 id="å‰è¨€"><a href="#å‰è¨€" class="headerlink" title="å‰è¨€"></a>å‰è¨€</h5><p>&emsp;&emsp;ä¸Šä¸€ç¯‡è¯´äº†ä¸€ä¸‹æ•´ä½“çš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºUV_RUN_DEFAULTæ¨¡å¼æ¥è°ƒç”¨uv_runæ¥è¯´ï¼Œuv__loop_aliveå°±å†³å®šäº†æ˜¯å¦é€€å‡ºï¼Œè¿™ä¸€ç¯‡çœ‹ä¸€ä¸‹uv__loop_aliveçš„æºç ã€‚</p><h5 id="è¯¦æƒ…"><a href="#è¯¦æƒ…" class="headerlink" title="è¯¦æƒ…"></a>è¯¦æƒ…</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;å¯è§loopçš„çŠ¶æ€å–å†³äºä¸‰ä¸ªæ–¹é¢ï¼šhandlesã€reqsã€closing_handles </p><h5 id="handles"><a href="#handles" class="headerlink" title="handles"></a>handles</h5><p>&emsp;&emsp;uv__has_active_handleså°±æ˜¯æ£€æŸ¥loop-&gt;active_handleså€¼æ˜¯å¦å¤§äº0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_handles(loop)                                          \</span></span><br><span class="line">  ((loop)-&gt;active_handles &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_loop_s</span> <span class="title">uv_loop_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_handle_s</span> <span class="title">uv_handle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_dir_s</span> <span class="title">uv_dir_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> <span class="title">uv_async_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_process_s</span> <span class="title">uv_process_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_event_s</span> <span class="title">uv_fs_event_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_poll_s</span> <span class="title">uv_fs_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_signal_s</span> <span class="title">uv_signal_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;handlesåˆ—è¡¨å¦‚ä¸Šã€‚handleåœ¨è°ƒç”¨æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ï¼Œå°±æ˜¯<br>uv__handle_startã€‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å“ªäº›å‡½æ•°è°ƒç”¨äº†uv__handle_startã€‚<del>æœ‰ä¸€äº›handleä¸åœ¨å…¶ä¸­ï¼Œå¯èƒ½ä¸å…¶è°ƒç”¨æ–¹å¼æœ‰å…³ï¼Œæˆ‘æš‚æ—¶æ— æ³•è§£é‡Š</del><br><img src="https://img-blog.csdnimg.cn/20191116181231294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != <span class="number">0</span>) <span class="keyword">break</span>;                          \</span><br><span class="line">    (h)-&gt;flags |= UV_HANDLE_ACTIVE;                                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_REF) != <span class="number">0</span>) uv__active_handle_add(h);          \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__handle_startå‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨uv__active_handle_addï¼Œuv__active_handle_addå°±æ˜¯å°†loop-&gt;active_handles++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_add(h)                                              \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ç›¸åº”çš„åœ¨handleç»“æŸæ—¶æœ‰uv__active_handle_rmçš„è°ƒç”¨ï¼Œ(h)-&gt;loop-&gt;active_handleså‡ä¸€ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_rm(h)                                               \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="req"><a href="#req" class="headerlink" title="req"></a>req</h5><p>&emsp;&emsp;uv__has_active_reqså’Œhandleçš„é“ç†ä¸€æ ·ï¼Œæ˜¯æ£€æµ‹(loop)-&gt;active_reqs.count &gt; 0ã€‚active_reqsæ˜¯ä¸ªå…±ç”¨ä½“ï¼Œå®ƒçš„å¦ä¸€ä¸ªç”¨é€”æš‚æ—¶æˆ‘è¿˜ä¸çŸ¥é“ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_reqs(loop)                                             \</span></span><br><span class="line">  ((loop)-&gt;active_reqs.count &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_req_s</span> <span class="title">uv_req_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getaddrinfo_s</span> <span class="title">uv_getaddrinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getnameinfo_s</span> <span class="title">uv_getnameinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_shutdown_s</span> <span class="title">uv_shutdown_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_write_s</span> <span class="title">uv_write_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_connect_s</span> <span class="title">uv_connect_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_send_s</span> <span class="title">uv_udp_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_s</span> <span class="title">uv_fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_work_s</span> <span class="title">uv_work_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__req_register(loop, req)ç­‰åŒäºhandleçš„uv__active_handle_addã€‚uv__req_registeråœ¨uv__req_initä¸­è°ƒç”¨ï¼Œå‡ ä¹ï¼ˆ<del>æ¼ç½‘çš„æš‚æ—¶æ²¡æ³•è§£é‡Š</del> ï¼‰æ¯ä¸ªreqåœ¨åˆå§‹åŒ–æ—¶éƒ½è°ƒç”¨äº†uv__req_initã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_init(loop, req, typ)                                          \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    UV_REQ_INIT(req, typ);                                                    \</span><br><span class="line">    uv__req_register(loop, req);                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_register(loop, req)                                           \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ä¸‹å›¾æ‰€ç¤ºæ˜¯é‚£äº›å‡½æ•°è°ƒç”¨äº†uv__req_initï¼Œç”±åç§°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥å®ƒä»¬æ˜¯å±äºå“ªäº›reqçš„ã€‚<br><img src="https://img-blog.csdnimg.cn/20191116181900253.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°"><br>&emsp;&emsp;åŒç†ï¼Œè¿˜æœ‰uv__req_unregisterã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_unregister(loop, req)                                         \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(uv__has_active_reqs(loop));                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="closing-handles"><a href="#closing-handles" class="headerlink" title="closing_handles"></a>closing_handles</h5><p>&emsp;&emsp;è¦å…³é—­çš„handleä¼šä»¥é“¾è¡¨çš„å½¢å¼æŒ‚åœ¨loop-&gt;closing_handlesä¸Šã€‚è¿™ä¸ªæ“ä½œé€šè¿‡è°ƒç”¨uv__make_close_pendingæ¥å®ç°ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__make_close_pending</span><span class="params">(<span class="keyword">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class="line">  assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class="line">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class="line">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>å¦‚æœclosing_handlesä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿˜éœ€è¦è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œå»è°ƒç”¨å…³é—­çš„handleçš„å›è°ƒå‡½æ•°ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuvæºç åˆ†æï¼ˆ1ï¼‰äº‹ä»¶å¾ªç¯åˆ†æ</title>
      <link href="/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90/"/>
      <url>/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="å‰è¨€"><a href="#å‰è¨€" class="headerlink" title="å‰è¨€"></a>å‰è¨€</h4><blockquote><p>&emsp;&emsp;libuvæ€»æ˜¯æŠ¥å‡ºä¸€äº›è®©äººéš¾ä»¥ç†è§£çš„é”™è¯¯ğŸ˜‚ï¼Œä½œä¸ºä¸€ä¸ªCçš„é¡¹ç›®ï¼Œä¸å…·æœ‰Javaã€JavaScriptã€phpé‚£æ ·çš„äººæ°”ï¼Œå¾ˆéš¾ç™¾åº¦åˆ°ä¸€äº›é—®é¢˜çš„ç­”æ¡ˆï¼Œç”šè‡³googleä¹Ÿä¸è¡Œã€‚ä¸ºäº†ç”¨å¥½libuvï¼Œä¹Ÿä¸ºäº†å­¦ä¹ å§ã€‚æˆ‘å¼€å§‹çœ‹libuvçš„æºç ï¼Œä¸çŸ¥é“è‡ªå·±èƒ½èµ°å¤šè¿œã€‚ã€‚ã€‚</p></blockquote><h4 id="äº‹ä»¶å¾ªç¯"><a href="#äº‹ä»¶å¾ªç¯" class="headerlink" title="äº‹ä»¶å¾ªç¯"></a>äº‹ä»¶å¾ªç¯</h4><img src="https://img-blog.csdnimg.cn/20191116165040610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" width="400" height="500" alt="Event Loop" align=center><p>è¿™æ˜¯å®˜æ–¹äº‹ä»¶å¾ªç¯çš„ç¤ºæ„å›¾ã€‚<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">é“¾æ¥-&gt;å®˜æ–¹å›¾ç‰‡ä½ç½®</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;æ•´ä¸ªäº‹ä»¶å¾ªç¯å°±æ˜¯åœ¨ä¸»çº¿ç¨‹çš„uv_runï¼ˆï¼‰è°ƒç”¨ä¸­æ‰§è¡Œçš„ã€‚æˆ‘å°±è·Ÿç€å®˜æ–¹çš„ä»‹ç»ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼ˆ<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">å®˜æ–¹ä»‹ç»</a>ï¼‰ã€‚</p><h5 id="ç¬¬ä¸€æ­¥"><a href="#ç¬¬ä¸€æ­¥" class="headerlink" title="ç¬¬ä¸€æ­¥"></a>ç¬¬ä¸€æ­¥</h5><blockquote><p>The loop concept of â€˜nowâ€™ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls.</p></blockquote><p>&emsp;&emsp;ç¬¬ä¸€æ­¥æ˜¯æ›´æ–°æ—¶é—´ã€‚å¯¹åº”ä»£ç å¦‚ä¸‹ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__update_time(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;æ€»ç»“æ¥è¯´å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ›´æ–°æ—¶é—´ã€‚<del>uv__update_timeå®ç°æˆ‘ä¸‹ä¸€ç¯‡æ¥ä»‹ç»</del> </p><h5 id="ç¬¬äºŒæ­¥"><a href="#ç¬¬äºŒæ­¥" class="headerlink" title="ç¬¬äºŒæ­¥"></a>ç¬¬äºŒæ­¥</h5><blockquote><p>If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and refâ€™d handles, active requests or closing handles itâ€™s considered to be alive.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ç”¨uv__loop_aliveå‡½æ•°è·å–loopçŠ¶æ€ã€‚<br>&emsp;&emsp;å¦‚æœuv__loop_aliveè¿”å›é›¶æˆ–è€…loop-&gt;stop_flag == 1è¯´æ˜loopç»ˆæ­¢ï¼Œç›´æ¥è·³è¿‡å¾ªç¯ï¼Œåˆ°ä»£ç æœ€ä¸‹é¢ï¼ˆ<del>è¿™é‡Œæœ‰ä¸€äº›æ€§èƒ½çš„å¤„ç†æš‚æ—¶ä¸ç®¡</del> ï¼‰ï¼Œé€€å‡ºï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;stop_flag == 0çš„ä¸€ä¸ªæ¥æºæ˜¯è°ƒç”¨äº†uv_stopï¼Œè¿™ä¸ªå‡½æ•°åœ¨æ‰‹å†Œä¸­çœ‹è§ã€‚å®ƒçš„æºä»£ç ä¹Ÿå¾ˆæ¸…æ™°ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv_stop</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  loop-&gt;stop_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;å¦‚æœloopçŠ¶æ€OKï¼Œé‚£ä¹ˆå°±è¿›å…¥å¾ªç¯ä¸­ã€‚</p><h5 id="ç¬¬ä¸‰æ­¥"><a href="#ç¬¬ä¸‰æ­¥" class="headerlink" title="ç¬¬ä¸‰æ­¥"></a>ç¬¬ä¸‰æ­¥</h5><blockquote><p>Due timers are run. All active timers scheduled for a time before the loopâ€™s concept of now get their callbacks called.</p></blockquote><p>&emsp;&emsp;å¯¹åº”ä»£ç è¿™ä¸€éƒ¨åˆ†ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uv__run_timers(loop);</span><br><span class="line">å…¶å®ç°ï¼š</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min(timer_heap(loop));</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;å°†å †é‡Œé¢å·²ç»è¶…æ—¶çš„æ‹¿å‡ºæ¥è¿è¡Œã€‚</p><h5 id="ç¬¬å››æ­¥"><a href="#ç¬¬å››æ­¥" class="headerlink" title="ç¬¬å››æ­¥"></a>ç¬¬å››æ­¥</h5><blockquote><p>Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point.</p></blockquote><p>å¯¹åº”ï¼š</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ran_pending = uv__run_pending(loop);</span><br><span class="line">å…¶å®ç°ï¼š</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;å°†loop-&gt;pending_queueä¸­çš„ä»»åŠ¡æ‹¿å‡ºæ¥è¿è¡Œã€‚</p><h5 id="ç¬¬äº”ã€å…­ã€ä¹æ­¥"><a href="#ç¬¬äº”ã€å…­ã€ä¹æ­¥" class="headerlink" title="ç¬¬äº”ã€å…­ã€ä¹æ­¥"></a>ç¬¬äº”ã€å…­ã€ä¹æ­¥</h5><blockquote><p>5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active</p></blockquote><blockquote><p> 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O.</p></blockquote><blockquote><p>9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv__run_idle(loop);</span><br><span class="line">uv__run_prepare(loop);</span><br><span class="line">uv__run_check(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;è¿™ä¸‰éƒ¨ä¸ºä»€ä¹ˆè¦ä¸€èµ·è¯´å‘¢ï¼Ÿå› ä¸ºå®ƒä»¬çš„å®è´¨æ˜¯ä¸€æ ·çš„ã€‚åœ¨æ¯æ¬¡å¾ªç¯å›ºå®šçš„ä½ç½®è°ƒç”¨ã€‚<br>&emsp;&emsp;è¿™ä¸‰ä¸ªå‡½æ•°å®šä¹‰åœ¨loop-watcher.cè¿™ä¸ªæ–‡ä»¶é‡Œé¢ï¼Œå®ƒä»¬æ˜¯ç”¨å®å®šä¹‰å®šä¹‰çš„ã€‚åªæ”¹äº†idleã€prepareã€checkè¿™ä¸‰ä¸ªåå­—çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†å‡½æ•°éƒ½æ˜¯ä¸€æ ·çš„ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the "Software"), to</span></span><br><span class="line"><span class="comment"> * deal in the Software without restriction, including without limitation the</span></span><br><span class="line"><span class="comment"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></span><br><span class="line"><span class="comment"> * sell copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"> * all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></span><br><span class="line"><span class="comment"> * IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"internal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \</span></span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123;              \</span></span><br><span class="line">    uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_##type);                   \</span><br><span class="line">    handle-&gt;name##_cb = <span class="literal">NULL</span>;                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line">    <span class="keyword">if</span> (uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                      \</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) <span class="keyword">return</span> UV_EINVAL;                                         \</span><br><span class="line">    QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;<span class="built_in">queue</span>);         \</span><br><span class="line">    handle-&gt;name##_cb = cb;                                                   \</span><br><span class="line">    uv__handle_start(handle);                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line">    <span class="keyword">if</span> (!uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                     \</span><br><span class="line">    QUEUE_REMOVE(&amp;handle-&gt;<span class="built_in">queue</span>);                                             \</span><br><span class="line">    uv__handle_stop(handle);                                                  \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__run_#<span class="meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">    uv_#<span class="meta">#name##_t* h;                                                         \</span></span><br><span class="line">    QUEUE <span class="built_in">queue</span>;                                                              \</span><br><span class="line">    QUEUE* q;                                                                 \</span><br><span class="line">    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="built_in">queue</span>);                                \</span><br><span class="line">    <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;                                            \</span><br><span class="line">      q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);                                                 \</span><br><span class="line">      h = QUEUE_DATA(q, uv_##name##<span class="keyword">_t</span>, <span class="built_in">queue</span>);                                \</span><br><span class="line">      QUEUE_REMOVE(q);                                                        \</span><br><span class="line">      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">      h-&gt;name##_cb(h);                                                        \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__#<span class="meta">#name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line">    uv_#<span class="meta">#name##_stop(handle);                                                 \</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(check, CHECK)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(idle, IDLE)</span><br></pre></td></tr></table></figure><h5 id="ç¬¬ä¸ƒæ­¥"><a href="#ç¬¬ä¸ƒæ­¥" class="headerlink" title="ç¬¬ä¸ƒæ­¥"></a>ç¬¬ä¸ƒæ­¥</h5><blockquote><p>Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:<br>If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.<br>If the loop is going to be stopped (uv_stop() was called), the timeout is 0.<br>If there are no active handles or requests, the timeout is 0.<br>If there are any idle handles active, the timeout is 0.<br>If there are any handles pending to be closed, the timeout is 0.<br>If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;è¿™éƒ¨åˆ†æ˜¯å–å†³äºuv_runçš„æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼Œæš‚æ—¶ä¸ç»†çœ‹ã€‚</p><h5 id="ç¬¬å…«æ­¥"><a href="#ç¬¬å…«æ­¥" class="headerlink" title="ç¬¬å…«æ­¥"></a>ç¬¬å…«æ­¥</h5><blockquote><p>The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__io_poll(loop, timeout);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯¹äºä¸åŒæ“ä½œç³»ç»Ÿæœ‰æ‰€ä¸åŒï¼Œlinuxæ˜¯pollï¼Œmacæ˜¯kqueueã€‚</p><h5 id="ç¬¬åæ­¥"><a href="#ç¬¬åæ­¥" class="headerlink" title="ç¬¬åæ­¥"></a>ç¬¬åæ­¥</h5><blockquote><p>Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__run_closing_handles(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;è°ƒç”¨å„ç±»çš„closeå›è°ƒå‡½æ•°ã€‚</p><h5 id="ç¬¬åä¸€ã€åäºŒæ­¥"><a href="#ç¬¬åä¸€ã€åäºŒæ­¥" class="headerlink" title="ç¬¬åä¸€ã€åäºŒæ­¥"></a>ç¬¬åä¸€ã€åäºŒæ­¥</h5><blockquote><p>11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. Itâ€™s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.<br>12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if itâ€™s still alive, otherwise it will also end.</p></blockquote><p>&emsp;&emsp;å¯¹äºuv_runä¸åŒæ¨¡å¼çš„ä¸€ç‚¹ç‰¹æ®Šå¤„ç†ã€‚</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="å°ç»“"><a href="#å°ç»“" class="headerlink" title="å°ç»“"></a>å°ç»“</h4><p>&emsp;&emsp;å®è§‚ä¸Šæ¢³ç†ä¸€ä¸‹æ•´ä¸ªäº‹ä»¶å¾ªç¯çš„è¿‡ç¨‹ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
