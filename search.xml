<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3.无重复字符的最长子串</title>
      <link href="/2020/01/24/leetcode3/"/>
      <url>/2020/01/24/leetcode3/</url>
      
        <content type="html"><![CDATA[<h4 id="🥛set-emsp"><a href="#🥛set-emsp" class="headerlink" title="🥛set &emsp;"></a>🥛set &emsp;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        set&lt;char&gt; st;</span><br><span class="line">        int mx = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size();) &#123;</span><br><span class="line">            if(st.count(s[i]) &gt; 0) &#123;</span><br><span class="line">                if(st.size()) &#123;</span><br><span class="line">                    st.erase(s[i - st.size()]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st.insert(s[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            mx = max(mx, (int)st.size());</span><br><span class="line">        &#125;</span><br><span class="line">        return mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>987/987 cases passed (48 ms) <br><br>Your runtime beats 25.3 % of cpp submissions <br><br>Your memory usage beats 14.41 % of cpp submissions (16 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode771</title>
      <link href="/2020/01/24/leetcode771/"/>
      <url>/2020/01/24/leetcode771/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numJewelsInStones(string J, string S) &#123;</span><br><span class="line">        set&lt;char&gt; mp;</span><br><span class="line">        for(auto x : J) &#123;</span><br><span class="line">            mp.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        int tl = 0;</span><br><span class="line">        for(auto a: S) &#123;</span><br><span class="line">            if(mp.count(a) &gt; 0) &#123;</span><br><span class="line">                tl += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>254/254 cases passed (8 ms) <br><br>Your runtime beats 25.05 % of cpp submissions <br><br>Your memory usage beats 5.26 % of cpp submissions (8.8 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>652.寻找重复的子树</title>
      <link href="/2020/01/23/leetcode652/"/>
      <url>/2020/01/23/leetcode652/</url>
      
        <content type="html"><![CDATA[<h4 id="😔失败1"><a href="#😔失败1" class="headerlink" title="😔失败1"></a>😔失败1</h4><p>&emsp;&emsp;<strong>不可以重载map的比较函数</strong>，因为map的实现是红黑树，用于红黑树排序比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"> struct TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct Cmp &#123;</span><br><span class="line">        bool compr(const TreeNode* lhs, const TreeNode* rhs) const &#123;</span><br><span class="line">            if (!lhs &amp;&amp; !rhs)</span><br><span class="line">                return true;</span><br><span class="line">            if ((!lhs &amp;&amp; rhs) || (lhs &amp;&amp; !rhs))</span><br><span class="line">                return false;</span><br><span class="line">            bool v = lhs-&gt;val == rhs-&gt;val;</span><br><span class="line">            if (!v)</span><br><span class="line">                return false;</span><br><span class="line">            bool v1 = compr(lhs-&gt;left, rhs-&gt;left);</span><br><span class="line">            if (!v1)</span><br><span class="line">                return false;</span><br><span class="line">            bool v2 = compr(lhs-&gt;right, rhs-&gt;right);</span><br><span class="line">            if (!v2)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        bool operator()(const TreeNode* lhs, const TreeNode* rhs) const &#123;</span><br><span class="line">            return compr(lhs, rhs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">        map&lt;TreeNode*, int, Cmp&gt; st;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        dg(root, st, vec);</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">    void dg(TreeNode* h, map&lt;TreeNode*, int, Cmp&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!h)</span><br><span class="line">            return;</span><br><span class="line">        dg(h-&gt;left, st, vec);</span><br><span class="line">        dg(h-&gt;right, st, vec);</span><br><span class="line">        size_t ct = st.count(h);</span><br><span class="line">        if (ct &gt; 0) &#123;</span><br><span class="line">            if (st.at(h) == 1) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;i&quot; &lt;&lt; endl;</span><br><span class="line">                vec.push_back(h);</span><br><span class="line">            &#125;</span><br><span class="line">            st.at(h) += 1;</span><br><span class="line">            cout &lt;&lt; &quot;t&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            st.insert(&#123; h, 1 &#125;);</span><br><span class="line">            cout &lt;&lt; &quot;f&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* root = new TreeNode(1);</span><br><span class="line">    root-&gt;left = new TreeNode(2);</span><br><span class="line">    root-&gt;right = new TreeNode(3);</span><br><span class="line">    root-&gt;left-&gt;left = new TreeNode(4);</span><br><span class="line">    root-&gt;right-&gt;left = new TreeNode(2);</span><br><span class="line">    root-&gt;right-&gt;right = new TreeNode(4);</span><br><span class="line">    root-&gt;right-&gt;left-&gt;left = new TreeNode(4);</span><br><span class="line">    Solution().findDuplicateSubtrees(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="😍序列化"><a href="#😍序列化" class="headerlink" title="😍序列化"></a>😍序列化</h4><p>&emsp;&emsp;序列化成字符串之后再来比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123;</span><br><span class="line">        map&lt;string, int&gt; st;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        string s;</span><br><span class="line">        dg(root, st, vec, s);</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">    void dg(TreeNode* h, map&lt;string, int&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec, string&amp; s) </span><br><span class="line">    &#123;</span><br><span class="line">        if(!h)</span><br><span class="line">            return ;</span><br><span class="line">        dg(h-&gt;left, st, vec, s);</span><br><span class="line">        dg(h-&gt;right, st, vec, s);</span><br><span class="line">        s.clear();</span><br><span class="line">        seril(h, s);</span><br><span class="line">        if(st.count(s)) &#123;</span><br><span class="line">            if(st.at(s) == 1) &#123;</span><br><span class="line">                // cout &lt;&lt; &quot;i&quot; &lt;&lt; endl;</span><br><span class="line">                vec.push_back(h);</span><br><span class="line">            &#125;</span><br><span class="line">            st.at(s) += 1;</span><br><span class="line">            // cout &lt;&lt; &quot;t&quot; &lt;&lt; endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            st.insert(&#123;s, 1&#125;);</span><br><span class="line">            // cout &lt;&lt; &quot;f&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void seril(TreeNode* h,string&amp; s) </span><br><span class="line">    &#123;   </span><br><span class="line">        if(!h) &#123;</span><br><span class="line">            s += &quot;@#&quot;;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        s += to_string(h-&gt;val) + &apos;#&apos;;</span><br><span class="line">        seril(h-&gt;left, s);</span><br><span class="line">        seril(h-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>168/168 cases passed (684 ms) <br><br>Your runtime beats 5.25 % of cpp submissions <br><br>Your memory usage beats 15.17 % of cpp submissions (54.5 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36.有效的数独</title>
      <link href="/2020/01/23/leetcode36/"/>
      <url>/2020/01/23/leetcode36/</url>
      
        <content type="html"><![CDATA[<h4 id="🚌"><a href="#🚌" class="headerlink" title="🚌"></a>🚌</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int columns[9][9] = &#123;0&#125;, </span><br><span class="line">        rows[9][9] = &#123;0&#125;, </span><br><span class="line">        boxes[9][9] = &#123;0&#125;;</span><br><span class="line">        for(int r = 0; r &lt; 9; ++r)</span><br><span class="line">            for(int c = 0; c &lt; 9; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                if(board[r][c] == &apos;.&apos;)</span><br><span class="line">                    continue;</span><br><span class="line">                int val = board[r][c] - 48 - 1;</span><br><span class="line">                // cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">                int box_num = r / 3 * 3 + c / 3;</span><br><span class="line">                boxes[box_num][val] += 1;</span><br><span class="line">                columns[c][val] += 1;</span><br><span class="line">                rows[r][val] += 1;</span><br><span class="line">                if(boxes[box_num][val] &gt; 1 ||</span><br><span class="line">                columns[c][val] &gt; 1 || rows[r][val] &gt; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>504/504 cases passed (16 ms) <br><br>Your runtime beats 71.31 % of cpp submissions <br><br>Your memory usage beats 63.82 % of cpp submissions (9.4 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49.字母异位词分组</title>
      <link href="/2020/01/23/leetcode49/"/>
      <url>/2020/01/23/leetcode49/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) </span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        for(auto str: strs) &#123;</span><br><span class="line">            string s = respell(str);</span><br><span class="line">            mp[s].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; vs;</span><br><span class="line">        for(auto v : mp) </span><br><span class="line">            vs.push_back(v.second);</span><br><span class="line">        return vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string respell(string s) &#123;</span><br><span class="line">        vector&lt;char&gt; vec;</span><br><span class="line">        for(auto i : s) &#123;</span><br><span class="line">            vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        string ns = &quot;&quot;;</span><br><span class="line">        for(auto x : vec) &#123;</span><br><span class="line">            ns += x;</span><br><span class="line">        &#125;</span><br><span class="line">        return ns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>101/101 cases passed (64 ms) <br><br>Your runtime beats 47.5 % of cpp submissions <br><br>Your memory usage beats 11.54 % of cpp submissions (22.7 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>219.存在重复元素 II</title>
      <link href="/2020/01/23/leetcode219/"/>
      <url>/2020/01/23/leetcode219/</url>
      
        <content type="html"><![CDATA[<h4 id="😝实现"><a href="#😝实现" class="headerlink" title="😝实现"></a>😝实现</h4><p>set的大小用来记录距离值K。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        set&lt;int&gt; st;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            if(st.count(nums[i]) == 1) </span><br><span class="line">                return true;</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">            if(st.size() &gt; k) &#123;</span><br><span class="line">                st.erase(nums[i - k]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>23/23 cases passed (48 ms)<br><br>Your runtime beats 41.06 % of cpp submissions<br><br>Your memory usage beats 6.78 % of cpp submissions (15.6 MB)<br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350.两个数组的交集 II</title>
      <link href="/2020/01/23/leetcode350/"/>
      <url>/2020/01/23/leetcode350/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        if(!nums1.size() || !nums2.size()) </span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int lo, ho, mid;</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        for(auto x: nums1) &#123;</span><br><span class="line">            lo = 0;</span><br><span class="line">            ho = nums2.size() - 1;</span><br><span class="line">            while(lo &lt; ho) &#123;</span><br><span class="line">                mid = lo + (ho - lo) / 2;</span><br><span class="line">                if(nums2[mid] &lt; x) &#123;</span><br><span class="line">                    lo = mid + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ho = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums2[lo] == x) &#123;</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                nums2.erase(nums2.begin() + lo);</span><br><span class="line">                if(!nums2.size())</span><br><span class="line">                    return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>61/61 cases passed (12 ms) <br><br>Your runtime beats 55.05 % of cpp submissions <br><br>Your memory usage beats 52.41 % of cpp submissions (9.4 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387.字符串中的第一个唯一字符</title>
      <link href="/2020/01/23/leetcode387/"/>
      <url>/2020/01/23/leetcode387/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstUniqChar(string s) &#123;</span><br><span class="line">        if(!s.size())</span><br><span class="line">            return -1;</span><br><span class="line">        map&lt;char, int&gt; st;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            if(!st.count(s[i])) &#123;</span><br><span class="line">                st[s[i]] = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                st[s[i]] = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!st.size())</span><br><span class="line">            return -1;</span><br><span class="line">        auto x = min_element(st.begin(), st.end(), [](auto&amp; a, auto&amp; b)&#123;</span><br><span class="line">            if(a.second &lt; b.second) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;);</span><br><span class="line">        if(x-&gt;second == INT_MAX)</span><br><span class="line">            return -1;</span><br><span class="line">        return x-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>104/104 cases passed (92 ms) <br><br>Your runtime beats 20.33 % of cpp submissions <br><br>Your memory usage beats 5.07 % of cpp submissions (13.5 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>599.两个列表的最小索引总和</title>
      <link href="/2020/01/23/leetcode599/"/>
      <url>/2020/01/23/leetcode599/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        if(!list1.size())</span><br><span class="line">            return vec;</span><br><span class="line">        map&lt;string, int&gt; st1, st2;</span><br><span class="line">        for(int i = 0; i &lt; list1.size(); ++i) </span><br><span class="line">            st1.insert(&#123;list1[i], i&#125;);</span><br><span class="line">        for(int i = 0; i &lt; list2.size(); ++i) &#123;</span><br><span class="line">            if(st1.count(list2[i]) != 0) &#123;</span><br><span class="line">                auto x = st1.at(list2[i]);</span><br><span class="line">                st2.insert(&#123;list2[i], x + i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int mi = INT_MAX;</span><br><span class="line">        for(auto x :st2) &#123;</span><br><span class="line">            if(mi &gt; x.second) &#123;</span><br><span class="line">                mi = x.second;</span><br><span class="line">                // ms = x.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto x : st2) &#123;</span><br><span class="line">            if(mi == x.second) </span><br><span class="line">                vec.push_back(x.first);</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>133/133 cases passed (152 ms) <br><br>Your runtime beats 33.28 % of cpp submissions <br><br>Your memory usage beats 21.41 % of cpp submissions (31.6 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205.同构字符串</title>
      <link href="/2020/01/23/leetcode205/"/>
      <url>/2020/01/23/leetcode205/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; st, tt;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if(st.count(s[i]) == 1 || tt.count(t[i]) == 1) &#123;</span><br><span class="line">                if(tt.count(t[i]) != 1 || st.count(s[i]) != 1 || tt.at(t[i]) != st.at(s[i])) </span><br><span class="line">                    return false;</span><br><span class="line">            &#125; </span><br><span class="line">            st.insert(&#123;s[i], i&#125;);</span><br><span class="line">            tt.insert(&#123;t[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>30/30 cases passed (40 ms) <br><br>Your runtime beats 5.2 % of cpp submissions <br><br>Your memory usage beats 5.04 % of cpp submissions (15 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202.快乐数</title>
      <link href="/2020/01/23/leetcode202/"/>
      <url>/2020/01/23/leetcode202/</url>
      
        <content type="html"><![CDATA[<h4 id="🐤"><a href="#🐤" class="headerlink" title="🐤"></a>🐤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while(n != 1 &amp;&amp; count != 10) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            helper(n, res);</span><br><span class="line">            n = 0;</span><br><span class="line">            for(auto x: res) &#123;</span><br><span class="line">                n += pow(x, 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count == 10)</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void helper(int n, vector&lt;int&gt;&amp; res) &#123;</span><br><span class="line">        res.clear();</span><br><span class="line">        while(n) &#123;</span><br><span class="line">            res.push_back(n % 10);</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.两个数组的交集</title>
      <link href="/2020/01/23/leetcode349/"/>
      <url>/2020/01/23/leetcode349/</url>
      
        <content type="html"><![CDATA[<h4 id="🉐二分查找-and-哈希表"><a href="#🉐二分查找-and-哈希表" class="headerlink" title="🉐二分查找 and 哈希表"></a>🉐二分查找 and 哈希表</h4><p>&emsp;&emsp;一个哈希表的set来得到一个数组的唯一值，再通过二分查找来比较，得到一样的值，放入结果的vector中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        set&lt;int&gt; st;</span><br><span class="line">        if(!nums1.size() || !nums2.size()) </span><br><span class="line">            return vector&lt;int&gt;();</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int lo, ho, mid;</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        for(auto x: nums1) </span><br><span class="line">            st.insert(x);</span><br><span class="line">        for(auto x: st) &#123;</span><br><span class="line">            lo = 0;</span><br><span class="line">            ho = nums2.size() - 1;</span><br><span class="line">            while(lo &lt; ho) &#123;</span><br><span class="line">                mid = lo + (ho - lo) / 2;</span><br><span class="line">                if(nums2[mid] &lt; x) &#123;</span><br><span class="line">                    lo = mid + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ho = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums2[lo] == x) &#123;</span><br><span class="line">                res.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136.只出现一次的数字</title>
      <link href="/2020/01/23/leetcode136/"/>
      <url>/2020/01/23/leetcode136/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;int&gt; st;</span><br><span class="line">        for(auto x : nums) &#123;</span><br><span class="line">            if(st.count(x) == 0)</span><br><span class="line">                st.insert(x);</span><br><span class="line">            else </span><br><span class="line">                st.erase(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return *st.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>16/16 cases passed (36 ms) <br><br>Your runtime beats 8.92 % of cpp submissions <br><br>Your memory usage beats 5.02 % of cpp submissions (12.1 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>217.存在重复元素</title>
      <link href="/2020/01/23/leetcode217/"/>
      <url>/2020/01/23/leetcode217/</url>
      
        <content type="html"><![CDATA[<p>因为不需要有序，所以可以用unordered_set而不是set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; st;</span><br><span class="line">        for(auto x : nums) &#123;</span><br><span class="line">            if(st.count(x) &gt; 0)</span><br><span class="line">                return true;</span><br><span class="line">            st.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>706.设计哈希映射</title>
      <link href="/2020/01/23/leetcode706/"/>
      <url>/2020/01/23/leetcode706/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class MyHashMap &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyHashMap() : </span><br><span class="line">        N(0), M(10000)</span><br><span class="line">    &#123;</span><br><span class="line">        keys = new int [10000]();</span><br><span class="line">        vals = new int [10000]();</span><br><span class="line">        for(int i = 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">            keys[i] = -1;</span><br><span class="line">            vals[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** value will always be non-negative. */</span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key) &#123;</span><br><span class="line">                vals[i] = value;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vals[i] = value;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key)</span><br><span class="line">                return vals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br><span class="line">    void remove(int key) &#123;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(keys[i] == -1)</span><br><span class="line">            return ;</span><br><span class="line">        int k2, v2;</span><br><span class="line">        keys[i] = -1;</span><br><span class="line">        vals[i] = -1;</span><br><span class="line">        i = (i + 1) % M;</span><br><span class="line">        while(keys[i] != -1)&#123;</span><br><span class="line">            k2 = keys[i];</span><br><span class="line">            v2 = vals[i];</span><br><span class="line">            keys[i] = -1;</span><br><span class="line">            vals[i] = -1;</span><br><span class="line">            --N;</span><br><span class="line">            put(k2, v2);</span><br><span class="line">            i = (i + 1) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        --N;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int *keys;</span><br><span class="line">    int *vals;</span><br><span class="line">    int N;</span><br><span class="line">    int M;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>705.设计哈希集合</title>
      <link href="/2020/01/23/leetcode705/"/>
      <url>/2020/01/23/leetcode705/</url>
      
        <content type="html"><![CDATA[<h4 id="😂代码实现"><a href="#😂代码实现" class="headerlink" title="😂代码实现"></a>😂代码实现</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyHashSet &#123;</span><br><span class="line">public:</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyHashSet() : </span><br><span class="line">        N(0), M(10000)</span><br><span class="line">    &#123;</span><br><span class="line">        keys = new int [10000]();</span><br><span class="line">        for(int i = 0; i &lt; 10000; ++i)</span><br><span class="line">            keys[i] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void add(int key) &#123;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key)</span><br><span class="line">                return ;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void remove(int key) &#123;</span><br><span class="line">        if(!contains(key))</span><br><span class="line">            return ;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        int k2;</span><br><span class="line">        keys[i] = -1;</span><br><span class="line">        i = (i + 1) % M;</span><br><span class="line">        while(keys[i] != -1)&#123;</span><br><span class="line">            k2 = keys[i];</span><br><span class="line">            keys[i] = -1;</span><br><span class="line">            --N;</span><br><span class="line">            add(k2);</span><br><span class="line">            i = (i + 1) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        --N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns true if this set contains the specified element */</span><br><span class="line">    bool contains(int key) &#123;</span><br><span class="line">        int i = (key &amp; 0x7fffffff) % M;</span><br><span class="line">        for( ; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">            if(keys[i] == key)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int *keys;</span><br><span class="line">    int N;</span><br><span class="line">    int M;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 Internet协议</title>
      <link href="/2020/01/23/TIV5/"/>
      <url>/2020/01/23/TIV5/</url>
      
        <content type="html"><![CDATA[<p><strong>IPv4头部长度</strong>包含20个字节（没有选项），<strong>IPv6头部长度</strong>固定（40字节）。<br><br><strong>网络字节序</strong>：高位优先字节序。<br><br>Internet头部被限制为60个字节，因为<strong>IHL字段长度</strong>为4位，保存IPv4头部中32位字的数量。<br><br>主机不需要接收大于576字节的IPv4数据报。<br><br><strong>头部校验和</strong>字段仅计算IPv4头部。 <br></p>]]></content>
      
      
      
        <tags>
            
            <tag> 《TCP/IP详解》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 链路层</title>
      <link href="/2020/01/23/TIV3/"/>
      <url>/2020/01/23/TIV3/</url>
      
        <content type="html"><![CDATA[<h4 id="🐘关键词汇"><a href="#🐘关键词汇" class="headerlink" title="🐘关键词汇"></a>🐘关键词汇</h4><p><strong>最大传输单元</strong>： MTU<br><br><strong>以太网</strong>：通常指一套标准。10Mbit/s以太网，又称802.3标准。<br></p><h4 id="🐳关键概念"><a href="#🐳关键概念" class="headerlink" title="🐳关键概念"></a>🐳关键概念</h4><p>&emsp;交换机以双工方式运行，并且不需要使用CSMA/CD算法.<br><br>&emsp;传统以太网最小的帧是64字节，要求数据区长度最小为48字节，最大帧长度为1518字节，MTU大小限制为1500字节。<br></p>]]></content>
      
      
      
        <tags>
            
            <tag> 《TCP/IP详解》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 Internet地址结构</title>
      <link href="/2020/01/23/TIV2/"/>
      <url>/2020/01/23/TIV2/</url>
      
        <content type="html"><![CDATA[<h4 id="🐘关键词汇"><a href="#🐘关键词汇" class="headerlink" title="🐘关键词汇"></a>🐘关键词汇</h4><p><strong>子网寻址</strong>：一个站点被分配一个A类、B类和C类的网络号，保留一些剩余主机号进一步用站点分配。该站点可能将基础地址中的主机部分进一步划分为一个子网号和一个主机号。<br><br><strong>A类网络地址</strong>：网络号8位，0 + 7位自由;主机号24位 <br><br><strong>B类网络地址</strong>：网络号16位，10 + 14位自由；主机16位 <br><br><strong>C类网络地址</strong>：网络号24位，110 + 21位自由 ；主机8位<br><br><strong>D类网络地址</strong>：网络号32位，1110 + 28位自由 <br><br><strong>E类网络地址</strong>：网络号32位，1111 + 28位自由 <br><br><strong>子网掩码</strong>：由主机或路由器使用的分配位，以确定如何从一台主机对应IP地址中获得网络和子网信息。子网掩码纯粹是站点内部的局部问题。<br><br><strong>定向广播</strong>： 使用<strong>子网广播地址</strong>作为目的地的数据报。<br><br><strong>有限广播</strong>：255.255.255.255被保留为<strong>本地网络广播</strong>，它根本不会被路由器转发。<br><br><strong>任意源组播</strong>：ASM,任何发送方可以发送给任何组。<br><br><strong>特点组播</strong>：SSM，在每个组中只使用一个发送方。<br></p><h4 id="🐳关键概念"><a href="#🐳关键概念" class="headerlink" title="🐳关键概念"></a>🐳关键概念</h4><p>&emsp;IPv6地址长度128位（16* 8），IPv4地址长度32位（8* 4） <br><br>&emsp;IPv6块的前导的零不必书写。全零的块可以省略，并用符号::代替，为了避免歧义，一个IPv6地址中的符号::只能使用一次。在IPv6格式中嵌入IPv4地址可以使用混合符号形式，紧接着IPv4部分的地址块的值为ffff，地址的其他部分使用点分四组格式（::ffff:10.0.0.1） <br><br>&emsp;只有划分子网的网络中的主机和路由器知道子网结构，Internet其他部分仍然将它作为站点相关的地址来看待.<br><br>&emsp;128.32.1.255/24这个地址称为<strong>子网广播地址</strong>。<br><br>&emsp;CIDR缓解IPv4地址的压力，处理大于255小于65536的主机数。<br></p>]]></content>
      
      
      
        <tags>
            
            <tag> 《TCP/IP详解》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 概述</title>
      <link href="/2020/01/22/TIV1/"/>
      <url>/2020/01/22/TIV1/</url>
      
        <content type="html"><![CDATA[<h4 id="🐘关键词汇"><a href="#🐘关键词汇" class="headerlink" title="🐘关键词汇"></a>🐘关键词汇</h4><p><strong>协议族</strong>： 一系列相关协议的集合。 <br><br><strong>网关</strong>：又称路由器。 <br><br><strong>虚电路</strong>：表现出很多电路行为，但是不依赖于物理的交换机，而通过顶层的<strong>面向连接的分组</strong>来实现 <br><br><strong>数据报</strong>：一个特定类型的<strong>分组</strong>，包含所有来源地和目的地的所有识别信息。 <br><br><strong>消息边界</strong>：假设发送3个数据报，接收时必须是3个数据报，那么这就是有消息边界的；如果可以自己选择接收次数，一次接收3个数据报，或者2次，这就是没有消息边界。<br><br><strong>会话层</strong>：表示运行中的应用之间的交互，会话层协议可提供例如连接初始化和重新启动、增加检查点等功能。<br><br><strong>表示层</strong>：负责信息格式转换和标准化编码。<br><br><strong>PDU</strong>：协议数据单元 <br><br><strong>转发</strong>：每个数据报的目的地址用于决定将该数据报发送到哪里，而做出此决定和发送数据报到下一跳的过程。<br><br><strong>单播</strong>：目的地是一台主机。<br><br><strong>广播</strong>：目的地是一个指定网络中的所有主机。 <br><br><strong>组播</strong>：目的地是属于一个组播组的一组主机。 <br><br><strong>ICMP</strong>: Internet控制消息协议是<strong>IP的一个辅助协议</strong>。IP层使用它与其他主机或路由器的IP层之间交换差错消息和其他重要消息。 应用：ping、traceroute。<br><br><strong>IGMP</strong>：Internet组管理协议是<strong>IPv4的另一个辅助协议</strong>。它采用组播寻址和交付来管理作为组播成员的主机。<br><br><strong>SCTP</strong>: 流控制传输协议. <br><br><strong>端口号</strong>：16位非负整数（0~65535），熟知端口号（0 ~ 1023），注册端口号（1024 ~ 49151），动态/私有端口号（49152 ~ 65535）<br><br><strong>internet</strong>：常见协议族互联的多个网络。<br><br><strong>Internet</strong>: TCP/IP通信的世界范围的主机集合。<br></p><h4 id="🐳关键概念"><a href="#🐳关键概念" class="headerlink" title="🐳关键概念"></a>🐳关键概念</h4><p>&emsp;TCP/IP是一个实现Internet体系结构的<strong>协议族</strong>。 <br><br>&emsp;在<strong>尽力而为</strong>的交付中，网络不会花费很大努力来确保数据在没有差错或缺陷的情况下交付。<br><br>&emsp;在尽力而为的IP网络中，降低发送方的发送速度可通过<strong>流量控制</strong>机制实现。<br><br>&emsp;通常认为TCP/IP体系结构包含5层。<br><br>&emsp;端主机实现所有层，交换机实现到第二层，路由器实现到第三层。 <br><br>&emsp;<strong>通常不认为交换机或桥接是一个中间系统</strong>，这时由于它们没有使用互联网络协议的地址格式来编址，并在很大程度上以透明于网络层协议的方式运行。<br><br>&emsp;有多个接口的系统称为<strong>多宿主</strong>. <br><br>&emsp;IP发送给<strong>链路层协议</strong>的PDU称为<strong>IP数据报</strong>，它的大小是64KB（IPv6是4GB）,我们简化称为<strong>分组</strong><br><br>&emsp;大的分组放入链路层PDU（称为<strong>帧</strong>）时需要进行缩小处理，这个过程称为<strong>分片</strong>。 <br><br>&emsp;TCP发送到IP的PDU称为<strong>TCP段</strong>。 <br><br>&emsp;用户可以通过<strong>虚拟专用网VPN</strong>连接到内联网。<br><br>&emsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《TCP/IP详解》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表</title>
      <link href="/2020/01/22/alg6/"/>
      <url>/2020/01/22/alg6/</url>
      
        <content type="html"><![CDATA[<h4 id="🥣拉链法的散列表"><a href="#🥣拉链法的散列表" class="headerlink" title="🥣拉链法的散列表"></a>🥣拉链法的散列表</h4><p>&emsp;&emsp;基于<strong>链表实现的字典</strong>实现而来 <br><br>散列表的重点在于解决冲突，拉链法解决冲突的方法是通过数组＋链表的形式来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &quot;BinarySearchST.hpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 拉链法散列表</span><br><span class="line"> * 因为没有Java的hasCode方法，</span><br><span class="line"> * 所以这里的代码直接使用int类型</span><br><span class="line"> **/ </span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">class SeparateChainingHashST</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    SeparateChainingHashST(int M);</span><br><span class="line">    ~SeparateChainingHashST();</span><br><span class="line">    Value get(int key);</span><br><span class="line">    void put(int key, Value val);</span><br><span class="line">    int size() const &#123;return this-&gt;N;&#125;</span><br><span class="line">  private:</span><br><span class="line">    int N; //键值对总数</span><br><span class="line">    int M; //散列表的大小</span><br><span class="line">    BinarySearchST&lt;int, Value&gt; *st;</span><br><span class="line"></span><br><span class="line">    int hash(int key) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">SeparateChainingHashST&lt;Value&gt;::SeparateChainingHashST(int M)</span><br><span class="line">  : N(0), M(M)</span><br><span class="line">&#123;</span><br><span class="line">  st = new BinarySearchST&lt;int, Value&gt;[M]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">SeparateChainingHashST&lt;Value&gt;::~SeparateChainingHashST()</span><br><span class="line">&#123;</span><br><span class="line">  delete [] st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">int SeparateChainingHashST&lt;Value&gt;::hash(int key) const</span><br><span class="line">&#123;</span><br><span class="line">  return (key &amp; 0x7fffffff) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">Value SeparateChainingHashST&lt;Value&gt;::get(int key)</span><br><span class="line">&#123;</span><br><span class="line">  return st[hash(key)].get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">void SeparateChainingHashST&lt;Value&gt;::put(int key, Value val)</span><br><span class="line">&#123;</span><br><span class="line">  st[hash(key)].put(key, val);</span><br><span class="line">  N++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="😤线性探测法的散列表"><a href="#😤线性探测法的散列表" class="headerlink" title="😤线性探测法的散列表"></a>😤线性探测法的散列表</h4><p>&emsp;&emsp;线性探测法的重点在于hash值相同时，将键值往后移，这样就共用一个数组，对于拉链法的散列表，这种方法是<strong>用时间复杂度来换取空间复杂度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 线性探测法的散列表</span><br><span class="line"> **/ </span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">class LinearProbingHashST&#123;</span><br><span class="line">  public:</span><br><span class="line">    LinearProbingHashST(int M);</span><br><span class="line">    int size() const &#123;return N;&#125;</span><br><span class="line">    void put(int key, Value val);</span><br><span class="line">    Value get(int key);</span><br><span class="line">    void delet(int key);</span><br><span class="line">    bool contain(int key) const;</span><br><span class="line">  private:</span><br><span class="line">    int M; //长度</span><br><span class="line">    int N; //键值对数量</span><br><span class="line">    int* keys;</span><br><span class="line">    Value* vals;</span><br><span class="line"></span><br><span class="line">    void resize(int sz);</span><br><span class="line">    int hash(int key) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">int LinearProbingHashST&lt;Value&gt;::hash(int key) const</span><br><span class="line">&#123;</span><br><span class="line">  return (key &amp; 0x7fffffff) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">LinearProbingHashST&lt;Value&gt;::LinearProbingHashST(int M)</span><br><span class="line"> :M(M), N(0)</span><br><span class="line">&#123;</span><br><span class="line">  keys = new int [M]();</span><br><span class="line">  vals = new Value [M]();</span><br><span class="line">  for(int i  = 0; i &lt; M; ++i)</span><br><span class="line">    keys[i] = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">void </span><br><span class="line">LinearProbingHashST&lt;Value&gt;::put(int key, Value val)</span><br><span class="line">&#123;</span><br><span class="line">  if(N &gt; M / 2) &#123;</span><br><span class="line">    resize(2 * M);</span><br><span class="line">  &#125;</span><br><span class="line">  int i;</span><br><span class="line">  for(i = hash(key); keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">    if(keys[i] == key) </span><br><span class="line">    &#123;</span><br><span class="line">      vals[i] = val;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  keys[i] = key;</span><br><span class="line">  vals[i] = val;</span><br><span class="line">  N++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">void </span><br><span class="line">LinearProbingHashST&lt;Value&gt;::resize(int sz)</span><br><span class="line">&#123;</span><br><span class="line">  int * keys1 = keys;</span><br><span class="line">  Value* vals1 = vals;</span><br><span class="line">  int M1 = M;</span><br><span class="line">  keys = new int [sz]();</span><br><span class="line">  vals = new Value [sz] ();</span><br><span class="line">  for(int i = 0; i &lt; sz; ++i) &#123;</span><br><span class="line">    keys[i] = -1;</span><br><span class="line">  &#125;</span><br><span class="line">  N = 0;</span><br><span class="line">  M = sz;</span><br><span class="line">  for(int i = 0; i &lt; M1; ++i) &#123;</span><br><span class="line">    if(keys1[i] != -1) &#123;</span><br><span class="line">      put(keys1[i], vals1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  delete [] keys1;</span><br><span class="line">  delete [] vals1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">Value </span><br><span class="line">LinearProbingHashST&lt;Value&gt;::get(int key)</span><br><span class="line">&#123;</span><br><span class="line">  int i = hash(key);</span><br><span class="line">  for(; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">    if(keys[i] == key) &#123;</span><br><span class="line">      return vals[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">void </span><br><span class="line">LinearProbingHashST&lt;Value&gt;::delet(int key)</span><br><span class="line">&#123;</span><br><span class="line">  if(!contain(key))</span><br><span class="line">    return ;</span><br><span class="line">  int i = hash(key);</span><br><span class="line">  for(; keys[i] != -1; i = (i + 1) % M)</span><br><span class="line">    if(keys[i] == key)</span><br><span class="line">      break;</span><br><span class="line">  keys[i] = -1;</span><br><span class="line">  vals[i] = Value();</span><br><span class="line">  i = (i + 1) % M;</span><br><span class="line">  int k;</span><br><span class="line">  Value v;</span><br><span class="line">  while(keys[i] != -1) &#123;</span><br><span class="line">    k = keys[i];</span><br><span class="line">    v = vals[i];</span><br><span class="line">    N--;</span><br><span class="line">    keys[i] = -1;</span><br><span class="line">    vals[i] = Value();</span><br><span class="line">    put(k, v);</span><br><span class="line">    i = (i + 1) % M; </span><br><span class="line">  &#125;</span><br><span class="line">  N--;</span><br><span class="line">  if(N &gt; 0 &amp;&amp; N == M/8)</span><br><span class="line">    resize(M / 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Value&gt;</span><br><span class="line">bool </span><br><span class="line">LinearProbingHashST&lt;Value&gt;::contain(int key) const</span><br><span class="line">&#123;</span><br><span class="line">  int i = hash(key);</span><br><span class="line">  for(; keys[i] != -1; i = (i + 1) % M) &#123;</span><br><span class="line">    if(keys[i] == key)</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98.验证二叉搜索树</title>
      <link href="/2020/01/22/leetcode98/"/>
      <url>/2020/01/22/leetcode98/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧中序遍历"><a href="#🥧中序遍历" class="headerlink" title="🥧中序遍历"></a>🥧中序遍历</h4><p>&emsp;&emsp;二叉搜索树的<strong>中序遍历</strong>得到的是一个递增的序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return true;</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        helper(root, vec);</span><br><span class="line">        if(vec.size() &lt;  2)</span><br><span class="line">            return true;</span><br><span class="line">        for(int i = 0; i &lt;= vec.size() - 2; ++i) &#123;</span><br><span class="line">            if(vec[i] &gt;= vec[i+1])</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return ;</span><br><span class="line">        if(root-&gt;left)</span><br><span class="line">            helper(root-&gt;left, vec);</span><br><span class="line">        vec.push_back(root-&gt;val);</span><br><span class="line">        if(root-&gt;right)</span><br><span class="line">            helper(root-&gt;right, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>75/75 cases passed (20 ms)<br><br>Your runtime beats 49.34 % of cpp submissions<br><br>Your memory usage beats 5.03 % of cpp submissions (21.3 MB)<br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110.平衡二叉树</title>
      <link href="/2020/01/22/leetcode110/"/>
      <url>/2020/01/22/leetcode110/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧递归"><a href="#🥧递归" class="headerlink" title="🥧递归"></a>🥧递归</h4><p>&emsp;&emsp;和一般递归不同的地方在于，不能返回<strong>平衡因子</strong>，必须返回高度，并且设置一个-1的特殊值来作为失败的结果（用来代替bool）。<br>这里不能返回bool类型，因为bool无法传递高度值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return helper(root) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int helper(TreeNode* h) &#123;</span><br><span class="line">        if(!h)</span><br><span class="line">            return 0;</span><br><span class="line">        int lf = helper(h-&gt;left),</span><br><span class="line">            rf = helper(h-&gt;right);</span><br><span class="line">        if(lf == -1 || rf == -1)</span><br><span class="line">            return -1;</span><br><span class="line">        return abs(rf - lf) &lt;= 1 ? max(lf, rf) + 1: -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>227/227 cases passed (20 ms) <br><br>Your runtime beats 44.47 % of cpp submissions <br><br>Your memory usage beats 9.13 % of cpp submissions (17.6 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>96.不同的二叉搜索树</title>
      <link href="/2020/01/21/leetcode96/"/>
      <url>/2020/01/21/leetcode96/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧动态规划"><a href="#🥧动态规划" class="headerlink" title="🥧动态规划"></a>🥧动态规划</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        int tr[n + 1] = &#123;0&#125;;</span><br><span class="line">        tr[0] = 1;</span><br><span class="line">        tr[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)</span><br><span class="line">            for(int j = 1; j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tr[i] += tr[j - 1] * tr[i - j];</span><br><span class="line">            &#125; </span><br><span class="line">        return tr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>19/19 cases passed (0 ms) <br><br>Your runtime beats 100 % of cpp submissions <br><br>Your memory usage beats 32.61 % of cpp submissions (8.3 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>95.不同的二叉搜索树 II</title>
      <link href="/2020/01/21/leetcode95/"/>
      <url>/2020/01/21/leetcode95/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧递归"><a href="#🥧递归" class="headerlink" title="🥧递归"></a>🥧递归</h4><p>&emsp;&emsp;写递归最重要的点在于：<br> 不要在乎递归是如何运行的，你要在乎的是，通过设计什么样的递归公式，递归出口，就一定可以通过递归获得最终的值。而不是去考虑递归在计算机中以什么样的形式和流程去执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">        if(!n)</span><br><span class="line">            return vector&lt;TreeNode*&gt;();</span><br><span class="line">        return helper(1, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;TreeNode*&gt; helper(int start, int end) &#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; ret;</span><br><span class="line">        if(start &gt; end) &#123;</span><br><span class="line">            ret.push_back(nullptr);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            auto leftList = helper(start, i - 1);</span><br><span class="line">            auto rightList = helper(i + 1, end);</span><br><span class="line">            for(auto l : leftList) </span><br><span class="line">                for(auto r: rightList) </span><br><span class="line">                &#123;</span><br><span class="line">                    auto newOne = new TreeNode(i);</span><br><span class="line">                    newOne-&gt;left = l;</span><br><span class="line">                    newOne-&gt;right = r;</span><br><span class="line">                    ret.push_back(newOne);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>9/9 cases passed (12 ms) <br><br>Your runtime beats 99.22 % of cpp submissions <br><br>Your memory usage beats 8.96 % of cpp submissions (17.6 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>315.计算右侧小于当前元素的个数</title>
      <link href="/2020/01/17/leetcode315/"/>
      <url>/2020/01/17/leetcode315/</url>
      
        <content type="html"><![CDATA[<h4 id="😝二叉查找树实现"><a href="#😝二叉查找树实现" class="headerlink" title="😝二叉查找树实现"></a>😝二叉查找树实现</h4><p>&emsp;&emsp;有几个难点</p><ul><li>递归插入的时候要通过一个辅助变量来更新每个节点的值（low_count）</li><li>处理值相同时的情况<br>因为插入是沿着一条路径下去的，所以是<strong>没有办法在插入的时候更新全部节点的</strong>。 <br><br>😳方案一是：选择单独在插入之后再来更新节点。 <br><br>😳方案二是：更新一边的节点，在这个题目中，我们的选择就是只更新左边的节点，这时Node-&gt;low_count代表的就不是全体中比它小的节点数量，而是<strong>当前根节点下比它小的数量</strong>，而向右移动就是切换根节点。<br><br>因为我们是<strong>以根节点标准</strong>开始进行比较，所以我们用辅助变量更新节点是更新不到起点以外的地方的。</li></ul><p>🥦方案二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct Node &#123;</span><br><span class="line">        int low_count;  //统计比它小的节点</span><br><span class="line">        int val;</span><br><span class="line">        shared_ptr&lt;Node&gt; left, right;</span><br><span class="line">        Node(int val, int count) : </span><br><span class="line">        low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">        int compareTo(int k) &#123;</span><br><span class="line">            if(val &lt; k) </span><br><span class="line">                return -1;</span><br><span class="line">            else if (val &gt; k) </span><br><span class="line">                return 1;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    int low_c = 0;</span><br><span class="line">    shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123;</span><br><span class="line">        if(!h) </span><br><span class="line">            return make_shared&lt;Node&gt;(val ,0);</span><br><span class="line">        int cmp = h-&gt;compareTo(val);</span><br><span class="line">        if(cmp &gt;= 0) &#123;</span><br><span class="line">            h-&gt;low_count += 1;</span><br><span class="line">            h-&gt;left = insert(h-&gt;left, val);</span><br><span class="line">        &#125; </span><br><span class="line">        else if(cmp &lt; 0) &#123;</span><br><span class="line">            low_c += h-&gt;low_count + 1;</span><br><span class="line">            h-&gt;right = insert(h-&gt;right, val);</span><br><span class="line">        &#125; </span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; counts(nums.size());</span><br><span class="line">        if(!nums.size())</span><br><span class="line">            return counts;</span><br><span class="line">        counts[0] = 0;</span><br><span class="line">        if(nums.size() == 1) &#123;</span><br><span class="line">            return counts;</span><br><span class="line">        &#125;</span><br><span class="line">        shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0);</span><br><span class="line">        for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123;</span><br><span class="line">            low_c = 0;</span><br><span class="line">            head = insert(head, nums[i]);</span><br><span class="line">            counts[i] = low_c;</span><br><span class="line">        &#125;</span><br><span class="line">        return counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>16/16 cases passed (64 ms) <br><br>Your runtime beats 55.66 % of cpp submissions <br><br>Your memory usage beats 10.86 % of cpp submissions (29.7 MB)<br></p></blockquote><p>🍅方案一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct Node &#123;</span><br><span class="line">        int low_count;</span><br><span class="line">        int val;</span><br><span class="line">        shared_ptr&lt;Node&gt; left, right;</span><br><span class="line">        Node(int val, int count) : </span><br><span class="line">        low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">        int compareTo(int k) &#123;</span><br><span class="line">            if(val &lt; k) </span><br><span class="line">                return -1;</span><br><span class="line">            else if (val &gt; k) </span><br><span class="line">                return 1;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    int Nsize( shared_ptr&lt;Node&gt; h) &#123;</span><br><span class="line">        if(h)</span><br><span class="line">            return h-&gt;low_count;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123;</span><br><span class="line">        if(!h) </span><br><span class="line">            return make_shared&lt;Node&gt;(val ,0);</span><br><span class="line">        int cmp = h-&gt;compareTo(val);</span><br><span class="line">        if(cmp &gt;= 0) &#123;</span><br><span class="line">            h-&gt;left = insert(h-&gt;left, val);</span><br><span class="line">        &#125; </span><br><span class="line">        else if(cmp &lt; 0) &#123;</span><br><span class="line">            h-&gt;right = insert(h-&gt;right, val);</span><br><span class="line">        &#125; </span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">    int g = 0;</span><br><span class="line">    void rank(shared_ptr&lt;Node&gt; h) &#123;</span><br><span class="line">        if(!h)</span><br><span class="line">            return ;</span><br><span class="line">        if(h-&gt;left) </span><br><span class="line">            rank(h-&gt;left);</span><br><span class="line">        h-&gt;low_count = g;</span><br><span class="line">        g += 1;</span><br><span class="line">        if(h-&gt;right)</span><br><span class="line">            rank(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int xx(shared_ptr&lt;Node&gt; h,int val) &#123;</span><br><span class="line">        if(!h)</span><br><span class="line">            return 0;</span><br><span class="line">        while(h) &#123;</span><br><span class="line">            int cmp = h-&gt;compareTo(val);</span><br><span class="line">            if(cmp &lt; 0 )</span><br><span class="line">                h = h-&gt;right;</span><br><span class="line">            else if(cmp &gt; 0)</span><br><span class="line">                h = h-&gt;left;</span><br><span class="line">            else if(cmp == 0 &amp;&amp; !h-&gt;left)</span><br><span class="line">                break;</span><br><span class="line">            else </span><br><span class="line">                h = h-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        return h-&gt;low_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; counts(nums.size());</span><br><span class="line">        if(!nums.size())</span><br><span class="line">            return counts;</span><br><span class="line">        counts[0] = 0;</span><br><span class="line">        if(nums.size() == 1) &#123;</span><br><span class="line">            return counts;</span><br><span class="line">        &#125;</span><br><span class="line">        shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0);</span><br><span class="line">        for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123;</span><br><span class="line">            head = insert(head, nums[i]);</span><br><span class="line">            g = 0;</span><br><span class="line">            rank(head);</span><br><span class="line">            counts[i] = xx(head, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Time Limit Exceeded <br><br>15/16 cases passed (N/A) <br><br>Testcase<br>[5183,2271,3067,539,8939,2999,9264,737,3974,5846,-210,9278,5800,2675,6608,1133,-1,6018,9672,5179,9842,7424,-209,2988,2757,5984,1107,2644,-499,7234,7539,6525,347,5718,-742,1797,5292,976,8752,8297,1312,3385,5924,2882,6091,-282,2595,96,1906,8014,7667,5895,7283,7974,-167,7068,3946,6223,189,1589,2058,9277,-302,8157,8256,5261,8067,1071,9470,2682,8197,5632,753,3179,8187,9042,8167,4657,7080,7801,5627,7917,8085,928,-892,-427,3685,4676,2431,8064,8537,343,505,4352,2108,4399,66,2086,1922,9126,9460,393,443,5689,7595,850,8493,2866,732,3738,7933,3666,2370,5804,4045,7903,8009,5387,5542,7593,6862,1547,6934,-160,9693,4560,7429,9989,7232,-594,587,6476,9277,4471,5979,6268,2419,6706,-727,1927,7361,9684,5519,2703,1723…..</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>449.序列化和反序列化二叉搜索树</title>
      <link href="/2020/01/17/leetcode449/"/>
      <url>/2020/01/17/leetcode449/</url>
      
        <content type="html"><![CDATA[<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>&emsp;&emsp;先序遍历，类似于数组表示二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">    void se_helper(TreeNode* root, string&amp; str) &#123;</span><br><span class="line">        if(!root) &#123; </span><br><span class="line">            str += &quot;x#&quot;;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        str += to_string(root-&gt;val) + &apos;#&apos;;</span><br><span class="line">        se_helper(root-&gt;left, str);</span><br><span class="line">        se_helper(root-&gt;right, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Encodes a tree to a single string.</span><br><span class="line">    string serialize(TreeNode* root) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        se_helper(root, s);</span><br><span class="line">        // cout &lt;&lt;s &lt;&lt; endl;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        if(data == &quot;x#&quot;)</span><br><span class="line">            return nullptr;</span><br><span class="line">        auto iter = data.begin();</span><br><span class="line">        return deserialize1(iter, data.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* deserialize1(string::iterator&amp; iter, string::iterator end) </span><br><span class="line">    &#123;</span><br><span class="line">        if(iter == end) </span><br><span class="line">            return nullptr;</span><br><span class="line">        string s;</span><br><span class="line">        while(*iter != &apos;#&apos;) &#123;</span><br><span class="line">            s += *iter++;</span><br><span class="line">        &#125;    </span><br><span class="line">        ++iter;</span><br><span class="line">        if(s == &quot;x&quot;) </span><br><span class="line">            return nullptr;</span><br><span class="line">        int val = atoi(s.c_str());</span><br><span class="line">        TreeNode* newOne = new TreeNode(val);</span><br><span class="line">        newOne-&gt;left = deserialize1(iter, end);</span><br><span class="line">        newOne-&gt;right = deserialize1(iter, end);</span><br><span class="line">        return newOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>62/62 cases passed (32 ms) <br><br>Your runtime beats 87.21 % of cpp submissions <br><br>Your memory usage beats 43.82 % of cpp submissions (24.2 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>538.把二叉搜索树转换为累加树</title>
      <link href="/2020/01/17/leetcode538/"/>
      <url>/2020/01/17/leetcode538/</url>
      
        <content type="html"><![CDATA[<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int k = 0;</span><br><span class="line">    TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">        if(!root) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        k += root-&gt;val;</span><br><span class="line">        root-&gt;val = k;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>450.删除二叉搜索树中的节点</title>
      <link href="/2020/01/16/leetcode450/"/>
      <url>/2020/01/16/leetcode450/</url>
      
        <content type="html"><![CDATA[<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int compar(int a, int b) &#123;</span><br><span class="line">        if(a &gt; b) return 1;</span><br><span class="line">        else if(b &gt; a) return -1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if(!root) </span><br><span class="line">            return nullptr;</span><br><span class="line">        int cmp = compar(root-&gt;val, key);</span><br><span class="line">        if(cmp &lt; 0) &#123;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        &#125; else if(cmp &gt; 0) &#123;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if(!root-&gt;left) return root-&gt;right;</span><br><span class="line">            if(!root-&gt;right) return root-&gt;left;</span><br><span class="line">            auto rm = min(root-&gt;right);</span><br><span class="line">            root-&gt;right = deleteMin(root-&gt;right);</span><br><span class="line">            rm-&gt;left = root-&gt;left;</span><br><span class="line">            rm-&gt;right = root-&gt;right;</span><br><span class="line">            root = rm;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* min(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left) </span><br><span class="line">            return root;</span><br><span class="line">        return min(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* deleteMin(TreeNode* root) &#123;</span><br><span class="line">        if(!root-&gt;left) </span><br><span class="line">            return root-&gt;right;</span><br><span class="line">        root-&gt;left = deleteMin(root-&gt;left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108.将有序数组转换为二叉搜索树</title>
      <link href="/2020/01/16/leetcode108/"/>
      <url>/2020/01/16/leetcode108/</url>
      
        <content type="html"><![CDATA[<h4 id="🥛中序构造"><a href="#🥛中序构造" class="headerlink" title="🥛中序构造"></a>🥛中序构造</h4><p>&emsp;&emsp;不用担心mid+1超出范围，因为nums[mid]是存在的，所以在构造r时，nums.begin() + mid + 1极限时就是与nums.end()相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        if(!nums.size())</span><br><span class="line">            return nullptr;</span><br><span class="line">        int mid = nums.size() / 2;</span><br><span class="line">        TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; l(nums.begin(), nums.begin() + mid);</span><br><span class="line">        vector&lt;int&gt; r(nums.begin() + mid + 1, nums.end());</span><br><span class="line">        root-&gt;left = sortedArrayToBST(l);</span><br><span class="line">        root-&gt;right =  sortedArrayToBST(r);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在C++中是否有替代INT_MIN这些宏定义的功能？</title>
      <link href="/2020/01/13/problems4/"/>
      <url>/2020/01/13/problems4/</url>
      
        <content type="html"><![CDATA[<p>📣在C++中我们依然可以包含 <cstdint>头文件，然后去使用INT_MIN这些宏定义,但是其实在C++中是存在更加优雅的方式的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;limits&gt;</span><br><span class="line">std::numeric_limits&lt;int&gt;::min() //INT_MIN</span><br><span class="line">std::numeric_limits&lt;int&gt;::max() //INT_MAX</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建数组的共享指针</title>
      <link href="/2020/01/12/problems3/"/>
      <url>/2020/01/12/problems3/</url>
      
        <content type="html"><![CDATA[<p>C++11在shared_ptr是没有shared_ptr&lt;int []&gt;这样的东西的，<br>但是std::unique_ptr&lt;int[]&gt;是有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int[]&gt; a(new int[10]()); // 错误，c++17前不能传递数组类型作为shared_ptr的模板参数</span><br><span class="line">std::unique_ptr&lt;int[]&gt; b(new int[10]()); // ok, unique_ptr对此做了特化</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;int&gt; c(new int[10]()); // 错误，可以编译，但会产生未定义行为，请不要这么做</span><br><span class="line">std::shared_ptr&lt;int&gt; sp3(new int[10](), std::default_delete&lt;int[]&gt;()); //正确做法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典</title>
      <link href="/2020/01/12/alg5/"/>
      <url>/2020/01/12/alg5/</url>
      
        <content type="html"><![CDATA[<h4 id="🥣链表实现"><a href="#🥣链表实现" class="headerlink" title="🥣链表实现"></a>🥣链表实现</h4><p>链表实现插入、查询的时间复杂度都是N，并非一个高效的实现方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 链表实现</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">class SequentialSearchST &#123;</span><br><span class="line">  public:</span><br><span class="line">    struct Node &#123;</span><br><span class="line">      Node(const S&amp; key, const T&amp; val, shared_ptr&lt;Node&gt; next = nullptr)</span><br><span class="line">      :key(key), val(val), next(next) &#123;&#125;</span><br><span class="line">      </span><br><span class="line">      const S key;</span><br><span class="line">      T val;</span><br><span class="line">      shared_ptr&lt;Node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    void show() const; </span><br><span class="line">    void put(S key, T val);</span><br><span class="line">    const T get(const S&amp; key) const;</span><br><span class="line">    bool contain(const S&amp; key) const;</span><br><span class="line">    const vector&lt;S&gt; keys() const;</span><br><span class="line">  private:</span><br><span class="line">    shared_ptr&lt;Node&gt; head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const T SequentialSearchST&lt;S,T&gt;::get(const S&amp; key) const &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; sk(head);</span><br><span class="line">  while(sk &amp;&amp; sk-&gt;key != key) &#123;</span><br><span class="line">    sk = sk-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!sk) </span><br><span class="line">    return T();</span><br><span class="line">  return sk-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void SequentialSearchST&lt;S,T&gt;::put(S key, T val) &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; sk(head);</span><br><span class="line">  while(sk &amp;&amp; sk-&gt;key != key) &#123;</span><br><span class="line">    sk = sk-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  if(sk) </span><br><span class="line">    sk-&gt;val = val;</span><br><span class="line">  else &#123;</span><br><span class="line">    shared_ptr&lt;Node&gt; newOne(make_shared&lt;Node&gt;(key, val, head));</span><br><span class="line">    head = newOne;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void SequentialSearchST&lt;S,T&gt;::show() const &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; sk(head);</span><br><span class="line">  while(sk) &#123;</span><br><span class="line">    cout &lt;&lt; sk-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; sk-&gt;val &lt;&lt; endl;</span><br><span class="line">    sk = sk-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">bool SequentialSearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; sk(head);</span><br><span class="line">  while(sk &amp;&amp; sk-&gt;key != key) &#123;</span><br><span class="line">    sk = sk-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!sk) </span><br><span class="line">    return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const vector&lt;S&gt; SequentialSearchST&lt;S,T&gt;::keys() const &#123;</span><br><span class="line">  vector&lt;S&gt; res;</span><br><span class="line">  shared_ptr&lt;Node&gt; sk(head);</span><br><span class="line">  while(sk) &#123;</span><br><span class="line">    res.push_back(sk-&gt;key);</span><br><span class="line">    sk = sk-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🚆改进1：改用数组实现，二分查找"><a href="#🚆改进1：改用数组实现，二分查找" class="headerlink" title="🚆改进1：改用数组实现，二分查找"></a>🚆改进1：改用数组实现，二分查找</h4><p>查找的时间复杂度降低为lgN，但是因为数组移位的原因，插入的时间复杂度还是N</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 数组实现</span><br><span class="line"> **/</span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">class BinarySearchST &#123;</span><br><span class="line">  public:</span><br><span class="line">    BinarySearchST(int size = 10000);</span><br><span class="line">    ~BinarySearchST();</span><br><span class="line">    void put(const S&amp;, const T&amp;);</span><br><span class="line">    const T get(const S&amp;);</span><br><span class="line">    bool contain(const S&amp; key) const;</span><br><span class="line">    const vector&lt;S&gt; keys() const;</span><br><span class="line">    void show() const;</span><br><span class="line">  private:</span><br><span class="line">    const int rank(const S&amp;) const;</span><br><span class="line">    S* _keys;</span><br><span class="line">    T* vals;</span><br><span class="line">    int _capacity;</span><br><span class="line">    int n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">BinarySearchST&lt;S,T&gt;::BinarySearchST(int size) </span><br><span class="line">  : _keys(new S[size]),</span><br><span class="line">  vals(new T[size]),</span><br><span class="line">  _capacity(size),</span><br><span class="line">  n(0)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">BinarySearchST&lt;S,T&gt;::~BinarySearchST()&#123;</span><br><span class="line">  delete []_keys;</span><br><span class="line">  delete []vals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const int BinarySearchST&lt;S,T&gt;::rank(const S&amp; key) const&#123;</span><br><span class="line">  if(n == 0) </span><br><span class="line">    return 0;</span><br><span class="line">  int lo = 0,</span><br><span class="line">    hi = n - 1,</span><br><span class="line">    mid;</span><br><span class="line">  while(lo &lt; hi) &#123;</span><br><span class="line">    mid = lo + (hi - lo) / 2;</span><br><span class="line">    if(_keys[mid] &lt; key) </span><br><span class="line">      lo = mid + 1;</span><br><span class="line">    else </span><br><span class="line">      hi = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  if(_keys[lo] &lt; key)</span><br><span class="line">    return lo + 1;</span><br><span class="line">  else </span><br><span class="line">    return lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BinarySearchST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">  int pos = rank(key);</span><br><span class="line">  if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; </span><br><span class="line">    vals[pos] = val;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  //暂时不考虑超出容量的情况</span><br><span class="line">  for(int i = n; i &gt; pos; --i) &#123;</span><br><span class="line">    _keys[i] = _keys[i - 1];</span><br><span class="line">    vals[i] = vals[i - 1];</span><br><span class="line">  &#125;</span><br><span class="line">  _keys[pos] = key;</span><br><span class="line">  vals[pos] = val;</span><br><span class="line">  ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const T BinarySearchST&lt;S,T&gt;::get(const S&amp; key) &#123;</span><br><span class="line">  int pos = rank(key);</span><br><span class="line">  if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; </span><br><span class="line">    return vals[pos];</span><br><span class="line">  &#125;</span><br><span class="line">  return T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">bool BinarySearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123;</span><br><span class="line">  if(!n) </span><br><span class="line">    return false;</span><br><span class="line">  int pos = rank(key);</span><br><span class="line">  return _keys[pos] == key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const vector&lt;S&gt; BinarySearchST&lt;S,T&gt;::keys() const &#123;</span><br><span class="line">  return vector&lt;S&gt;(_keys, _keys + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BinarySearchST&lt;S,T&gt;::show() const &#123;</span><br><span class="line">  for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; _keys[i] &lt;&lt; &quot; &quot; &lt;&lt; vals[i] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🚆改进2：改用二叉查找树"><a href="#🚆改进2：改用二叉查找树" class="headerlink" title="🚆改进2：改用二叉查找树"></a>🚆改进2：改用二叉查找树</h4><p>查找、修改的平均时间复杂度都是lgN，但是最坏情况两者都退回到N</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉查找树的实现</span><br><span class="line"> **/</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 二叉查找树的实现</span><br><span class="line"> **/</span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">class BST&#123;</span><br><span class="line">  public:</span><br><span class="line">    struct Node &#123;</span><br><span class="line">      const S key;</span><br><span class="line">      T val;</span><br><span class="line">      shared_ptr&lt;Node&gt; left, right;</span><br><span class="line">      int N;</span><br><span class="line">      Node(const S&amp;key, const T&amp; val, int N) :</span><br><span class="line">        key(key), val(val), left(), right(), N(N) &#123;&#125;</span><br><span class="line">      int compareTo(shared_ptr&lt;Node&gt; node) const;</span><br><span class="line">      int compareTo(const S&amp;) const;</span><br><span class="line">      static int Nsize(shared_ptr&lt;Node&gt; x);  </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    const S min() const;</span><br><span class="line">    const S max() const;</span><br><span class="line">    bool contain(const S&amp;) const;</span><br><span class="line">    const T get(const S&amp;) const;</span><br><span class="line">    void put(const S&amp; key, const T&amp; val);</span><br><span class="line">    void show() const; //调试</span><br><span class="line">    const vector&lt;S&gt; keys() const;</span><br><span class="line">    const S floor(const S&amp; key) const;</span><br><span class="line">    const S ceiling(const S&amp;key) const;</span><br><span class="line">    const S select(int x) const;</span><br><span class="line">    const int rank(const T&amp;) const;</span><br><span class="line">    void deleteMin();</span><br><span class="line">    void delet(const T&amp; key);</span><br><span class="line">  private:</span><br><span class="line">    shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt; nd, const T&amp; key);</span><br><span class="line">    shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;);</span><br><span class="line">    const int _rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _select(shared_ptr&lt;Node&gt; nd, int x) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _min(shared_ptr&lt;Node&gt; x) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _max(shared_ptr&lt;Node&gt; x) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; _put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val);</span><br><span class="line">    const T _get(shared_ptr&lt;Node&gt; x,const S&amp;) const;</span><br><span class="line">    void _show(shared_ptr&lt;Node&gt; x) const;</span><br><span class="line">    void _keys(vector&lt;S&gt;&amp;, shared_ptr&lt;Node&gt; x) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val) &#123;</span><br><span class="line">  head = _put(head, key, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val) </span><br><span class="line">&#123;</span><br><span class="line">  if(!x) </span><br><span class="line">    return make_shared&lt;Node&gt;(key, val, 1);</span><br><span class="line">  int cmp = x-&gt;compareTo(key);</span><br><span class="line">  if(cmp &gt; 0) x-&gt;left = _put(x-&gt;left, key, val); </span><br><span class="line">  else if(cmp &lt; 0) x-&gt;right = _put(x-&gt;right, key, val);</span><br><span class="line">  else x-&gt;val = val;</span><br><span class="line">  x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &gt; 1</span><br><span class="line"> * = 0</span><br><span class="line"> * &lt; -1</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">int BST&lt;S,T&gt;::Node::compareTo(shared_ptr&lt;Node&gt; node) const &#123;</span><br><span class="line">  return compareTo(node-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">int BST&lt;S,T&gt;::Node::compareTo(const S&amp; key2) const &#123;</span><br><span class="line">  return key &gt; key2 ? 1 : key &lt; key2 ? -1 : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">int BST&lt;S,T&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x) &#123;</span><br><span class="line">  if(!x) </span><br><span class="line">    return 0;</span><br><span class="line">  else </span><br><span class="line">    return x-&gt;N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const T BST&lt;S,T&gt;::get(const S&amp; key) const &#123;</span><br><span class="line">  return _get(head, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const T BST&lt;S,T&gt;::_get(shared_ptr&lt;Node&gt; x,const S&amp; key) const &#123;</span><br><span class="line">  if(!x) </span><br><span class="line">    return T();</span><br><span class="line">  int cmp = x-&gt;compareTo(key);</span><br><span class="line">  if(cmp &gt; 0) return _get(x-&gt;right, key);</span><br><span class="line">  else if(cmp &lt; 0) return _get(x-&gt;left, key);</span><br><span class="line">  else return x-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">bool BST&lt;S,T&gt;::contain(const S&amp; key) const &#123;</span><br><span class="line">  return get(key) != T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::show() const &#123;</span><br><span class="line">  _show(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::_show(shared_ptr&lt;Node&gt; x) const &#123;</span><br><span class="line">  if(!x) </span><br><span class="line">    return ;</span><br><span class="line">  if(x-&gt;left) </span><br><span class="line">    _show(x-&gt;left);</span><br><span class="line">  cout &lt;&lt; x-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; x-&gt;val &lt;&lt; endl;</span><br><span class="line">  if(x-&gt;right)</span><br><span class="line">    _show(x-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const vector&lt;S&gt; BST&lt;S,T&gt;::keys() const &#123;</span><br><span class="line">  vector&lt;S&gt; res;</span><br><span class="line">  _keys(res, head);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::_keys(vector&lt;S&gt;&amp; res, shared_ptr&lt;Node&gt; x) const &#123;</span><br><span class="line">  if(!x) </span><br><span class="line">    return ;</span><br><span class="line">  res.push_back(x-&gt;key);</span><br><span class="line">  _keys(res,x-&gt;left);</span><br><span class="line">  _keys(res, x-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const S BST&lt;S,T&gt;::min() const &#123;</span><br><span class="line">  if(!head) </span><br><span class="line">    return S();</span><br><span class="line">  return _min(head)-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_min(shared_ptr&lt;Node&gt; x) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!x || !x-&gt;left)</span><br><span class="line">    return x;</span><br><span class="line">  else</span><br><span class="line">    return _min(x-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const S BST&lt;S,T&gt;::max() const &#123;</span><br><span class="line">  if(!head) </span><br><span class="line">    return S();</span><br><span class="line">  return _max(head)-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_max(shared_ptr&lt;Node&gt; x) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!x || !x-&gt;right)</span><br><span class="line">    return x;</span><br><span class="line">  else</span><br><span class="line">    return _max(x-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const S BST&lt;S,T&gt;::floor(const S&amp; key) const &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; nd = _floor(head, key);</span><br><span class="line">  if(!nd) return S();</span><br><span class="line">  return nd-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const S BST&lt;S,T&gt;::ceiling(const S&amp;key) const &#123;</span><br><span class="line">  shared_ptr&lt;Node&gt; nd = _ceiling(head, key);</span><br><span class="line">  if(!nd) return S();</span><br><span class="line">  return nd-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!x) return x;</span><br><span class="line">  int cmp = x-&gt;compareTo(key);</span><br><span class="line">  if(cmp == 0) return x;</span><br><span class="line">  else if (cmp &gt; 0) return _floor(x-&gt;left, key);</span><br><span class="line">  shared_ptr&lt;Node&gt; y = _floor(x-&gt;right, key);</span><br><span class="line">  if(!y) return x;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!x) return x;</span><br><span class="line">  int cmp = x-&gt;compareTo(key);</span><br><span class="line">  if(!cmp) return x;</span><br><span class="line">  else if(cmp &lt; 0) return _ceiling(x-&gt;right, key);</span><br><span class="line">  shared_ptr&lt;Node&gt; y = _ceiling(x-&gt;left, key);</span><br><span class="line">  if(!y) return x;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const S BST&lt;S,T&gt;::select(int x) const &#123;</span><br><span class="line">  if(x &lt; 0 || x &gt;= head-&gt;N)</span><br><span class="line">    return S();</span><br><span class="line">  auto nd =  _select(head, x);</span><br><span class="line">  if(!nd) </span><br><span class="line">    return S();</span><br><span class="line">  return nd-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::_select(shared_ptr&lt;Node&gt; nd, int x) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!nd) </span><br><span class="line">    return nd;</span><br><span class="line">  int nd_rank = Node::Nsize(nd-&gt;left);</span><br><span class="line">  if(nd_rank &gt; x) </span><br><span class="line">    return _select(nd-&gt;left, x);</span><br><span class="line">  else if (nd_rank &lt; x)</span><br><span class="line">    return _select(nd-&gt;right, x - nd_rank - 1);</span><br><span class="line">  return nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const int BST&lt;S,T&gt;::rank(const T&amp; key) const &#123;</span><br><span class="line">  int rk = _rank(head, key);</span><br><span class="line">  // if(select(rk) != key)</span><br><span class="line">  //   return -1;</span><br><span class="line">  return rk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">const int BST&lt;S,T&gt;::_rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!nd) return 0;</span><br><span class="line">  int nd_rank = Node::Nsize(nd-&gt;left);</span><br><span class="line">  if(nd-&gt;key &lt; key) </span><br><span class="line">    return nd_rank + 1 + _rank(nd-&gt;right, key);</span><br><span class="line">  else if(nd-&gt;key &gt; key) </span><br><span class="line">    return _rank(nd-&gt;left, key);</span><br><span class="line">  return nd_rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个函数只能删除根节点左边的</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::deleteMin() &#123;</span><br><span class="line">  deleteMin(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::deleteMin(shared_ptr&lt;Node&gt; x) </span><br><span class="line">&#123;</span><br><span class="line">  if(!x-&gt;left)</span><br><span class="line">    return x-&gt;right;</span><br><span class="line">  x-&gt;left = deleteMin(x-&gt;left);</span><br><span class="line">  x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">void BST&lt;S,T&gt;::delet(const T&amp; key) &#123;</span><br><span class="line">  head = delet(head, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename S, typename T&gt;</span><br><span class="line">shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; </span><br><span class="line">BST&lt;S,T&gt;::delet(shared_ptr&lt;Node&gt; nd, const T&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  if(!nd) &#123;</span><br><span class="line">    return nd;</span><br><span class="line">  &#125;</span><br><span class="line">  int cmp = nd-&gt;compareTo(key);</span><br><span class="line">  if(cmp &lt; 0) </span><br><span class="line">  &#123;</span><br><span class="line">    nd-&gt;right = delet(nd-&gt;right, key);</span><br><span class="line">  &#125; else if(cmp &gt; 0) &#123;</span><br><span class="line">    nd -&gt;left = delet(nd-&gt;left, key);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(!nd-&gt;left) return nd-&gt;right;</span><br><span class="line">    if(!nd-&gt;right) return nd-&gt;left;</span><br><span class="line">    auto minO = _min(nd-&gt;right);</span><br><span class="line">    minO-&gt;right = deleteMin(nd-&gt;right);</span><br><span class="line">    minO-&gt;left = nd-&gt;left;</span><br><span class="line">    nd = minO;</span><br><span class="line">  &#125;</span><br><span class="line">  nd-&gt;N = Node::Nsize(nd-&gt;left) + Node::Nsize(nd-&gt;right) + 1;</span><br><span class="line">  return nd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🚆改进3：红黑树"><a href="#🚆改进3：红黑树" class="headerlink" title="🚆改进3：红黑树"></a>🚆改进3：红黑树</h4><p>查找、插入的时间复杂度恒定为logN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @Author: XiaoGongBai </span><br><span class="line"> * @Date: 2020-01-19 10:21:20 </span><br><span class="line"> * @Last Modified by: XiaoGongBai</span><br><span class="line"> * @Last Modified time: 2020-01-19 11:31:04</span><br><span class="line"> */</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 红黑树</span><br><span class="line"> **/</span><br><span class="line">enum class Color&#123;</span><br><span class="line">  Red ,</span><br><span class="line">  Black </span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">class RedBlackBST&#123;</span><br><span class="line">  public:</span><br><span class="line">    struct Node&#123;</span><br><span class="line">      Key key;</span><br><span class="line">      Val val;</span><br><span class="line">      shared_ptr&lt;Node&gt; left,right;</span><br><span class="line">      int N;</span><br><span class="line">      Color color;</span><br><span class="line">      Node(const Key&amp; key, const Val&amp; val, int N, Color color)</span><br><span class="line">        :key(key), val(val), left(), right(), N(N), color(color) &#123;&#125;</span><br><span class="line">      static int Nsize(shared_ptr&lt;Node&gt; x);  </span><br><span class="line">      int compareTo(const Key&amp; key) const;</span><br><span class="line">    &#125;;</span><br><span class="line">    void put(const Key&amp; key, const Val&amp; val);</span><br><span class="line">    shared_ptr&lt;Node&gt; get(const Key&amp; key) const;</span><br><span class="line">    void deleteMin();</span><br><span class="line">    void deleteMax();</span><br><span class="line">    void delet(const Key&amp;);</span><br><span class="line">    Key min() const;</span><br><span class="line">    Key max() const;</span><br><span class="line">    vector&lt;Key&gt; keys(const Key&amp; m, const Key&amp; e) const;</span><br><span class="line">    vector&lt;Key&gt; keys() const;</span><br><span class="line"></span><br><span class="line">    const int size() const &#123;return root ? root-&gt;N : 0;&#125;</span><br><span class="line">  private:</span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;Node&gt; root;</span><br><span class="line"></span><br><span class="line">    void keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; max(shared_ptr&lt;Node&gt; h) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; min(shared_ptr&lt;Node&gt;) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const;</span><br><span class="line">    shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt;, const Key&amp;);</span><br><span class="line">    shared_ptr&lt;Node&gt; balance(shared_ptr&lt;Node&gt;);</span><br><span class="line">    shared_ptr&lt;Node&gt; removeRedLeft(shared_ptr&lt;Node&gt;);</span><br><span class="line">    shared_ptr&lt;Node&gt; removeRedRight(shared_ptr&lt;Node&gt;);</span><br><span class="line">    shared_ptr&lt;Node&gt; deleteMax(shared_ptr&lt;Node&gt;);</span><br><span class="line">    shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;);</span><br><span class="line">    shared_ptr&lt;Node&gt; put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val);</span><br><span class="line">    void flipColor(shared_ptr&lt;Node&gt; h);</span><br><span class="line">    shared_ptr&lt;Node&gt; rotateLeft(shared_ptr&lt;Node&gt; node);</span><br><span class="line">    shared_ptr&lt;Node&gt; rotateRight(shared_ptr&lt;Node&gt; h);</span><br><span class="line">    bool isRed(shared_ptr&lt;Node&gt; node)  const;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">int </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">  return x ? x-&gt;N : 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">int </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::Node::compareTo(const Key&amp; key) const</span><br><span class="line">&#123;</span><br><span class="line">  if(key &gt; this-&gt;key) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;  else if(key &lt; this-&gt;key) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::rotateLeft(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  if(!h) </span><br><span class="line">    return nullptr;</span><br><span class="line">  auto rh = h-&gt;right;</span><br><span class="line">  if(!rh)</span><br><span class="line">    return h;</span><br><span class="line">  h-&gt;right = rh-&gt;left;</span><br><span class="line">  rh-&gt;left = h;</span><br><span class="line">  rh-&gt;N = h-&gt;N;</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  swap(h-&gt;color, rh-&gt;color);</span><br><span class="line">  return rh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::rotateRight(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  if(!h) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  auto lh = h-&gt;left;</span><br><span class="line">  if(!lh)</span><br><span class="line">    return h;</span><br><span class="line">  h-&gt;left = lh-&gt;right;;</span><br><span class="line">  lh-&gt;right = h;</span><br><span class="line">  lh-&gt;N = h-&gt;N;</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  swap(h-&gt;color, lh-&gt;color);</span><br><span class="line">  return lh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">bool </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::isRed(shared_ptr&lt;Node&gt; h)  const</span><br><span class="line">&#123;</span><br><span class="line">  if(!h || h-&gt;color == Color::Black)</span><br><span class="line">    return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::put(const Key&amp; key, const Val&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">  root = put(root, key, val);</span><br><span class="line">  root-&gt;color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">  if(!h)</span><br><span class="line">    return make_shared&lt;Node&gt;(key, val, 1, Color::Red);</span><br><span class="line">  int cmp = h-&gt;compareTo(key);</span><br><span class="line">  if(cmp &lt; 0) &#123;</span><br><span class="line">    h-&gt;right = put(h-&gt;right, key, val);</span><br><span class="line">  &#125; else if (cmp &gt; 0) &#123;</span><br><span class="line">    h-&gt;left = put(h-&gt;left, key, val);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    h-&gt;val =val;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right))</span><br><span class="line">    h = rotateLeft(h);</span><br><span class="line">  if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left))</span><br><span class="line">    h = rotateRight(h);</span><br><span class="line">  if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123;</span><br><span class="line">    flipColor(h);</span><br><span class="line">  &#125;</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::flipColor(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  h-&gt;color = h-&gt;color == Color::Black ? Color::Red : Color::Black;</span><br><span class="line">  h-&gt;right-&gt;color = h-&gt;right-&gt;color == Color::Black ? Color::Red : Color::Black;</span><br><span class="line">  h-&gt;left-&gt;color = h-&gt;left-&gt;color == Color::Black ? Color::Red : Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::get(const Key&amp; key) const</span><br><span class="line">&#123;</span><br><span class="line">  return get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const</span><br><span class="line">&#123;</span><br><span class="line">  if(!h)</span><br><span class="line">    return nullptr;</span><br><span class="line">  int cmp = h-&gt;compareTo(key);</span><br><span class="line">  if(cmp &gt; 0) &#123;</span><br><span class="line">    return get(h-&gt;left, key);</span><br><span class="line">  &#125; else if (cmp &lt; 0) &#123;</span><br><span class="line">    return get(h-&gt;right, key);</span><br><span class="line">  &#125; else </span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void RedBlackBST&lt;Key,Val&gt;::deleteMin()</span><br><span class="line">&#123;</span><br><span class="line">  if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right))</span><br><span class="line">    root-&gt;color = Color::Red;</span><br><span class="line">  root = deleteMin(root);</span><br><span class="line">  if(root)</span><br><span class="line">    root-&gt;color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::deleteMin(shared_ptr&lt;Node&gt; h) </span><br><span class="line">&#123;</span><br><span class="line">  if(!h-&gt;left) </span><br><span class="line">    return h-&gt;right;</span><br><span class="line">  if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left))</span><br><span class="line">  &#123;</span><br><span class="line">    h = removeRedLeft(h);</span><br><span class="line">  &#125;</span><br><span class="line">  h-&gt;left = deleteMin(h-&gt;left);</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  return balance(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::removeRedLeft(shared_ptr&lt;Node&gt; h) </span><br><span class="line">&#123;</span><br><span class="line">  flipColor(h);</span><br><span class="line">  if(isRed(h-&gt;right) &amp;&amp; isRed(h-&gt;right-&gt;left)) </span><br><span class="line">  &#123;</span><br><span class="line">    h-&gt;right = rotateRight(h-&gt;right);</span><br><span class="line">    h = rotateLeft(h);</span><br><span class="line">    flipColor(h);</span><br><span class="line">  &#125;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::balance(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right))</span><br><span class="line">    h = rotateLeft(h);</span><br><span class="line">  if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left))</span><br><span class="line">    h = rotateRight(h);</span><br><span class="line">  if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123;</span><br><span class="line">    flipColor(h);</span><br><span class="line">  &#125;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">Key</span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::min() const</span><br><span class="line">&#123;</span><br><span class="line">  if(!root)</span><br><span class="line">    return Val();</span><br><span class="line">  return min(root)-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::min(shared_ptr&lt;Node&gt; h) const </span><br><span class="line">&#123;</span><br><span class="line">  if(!h-&gt;left)</span><br><span class="line">    return h;</span><br><span class="line">  return min(h-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">Key </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::max() const</span><br><span class="line">&#123;</span><br><span class="line">  if(!root) </span><br><span class="line">    return Val();</span><br><span class="line">  return max(root)-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::max(shared_ptr&lt;Node&gt; h) const</span><br><span class="line">&#123;</span><br><span class="line">  if(!h-&gt;right)</span><br><span class="line">    return h;</span><br><span class="line">  return max(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void RedBlackBST&lt;Key,Val&gt;::deleteMax()</span><br><span class="line">&#123;</span><br><span class="line">  if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right))</span><br><span class="line">    root-&gt;color = Color::Red;</span><br><span class="line">  root = deleteMax(root);</span><br><span class="line">  if(root)</span><br><span class="line">    root-&gt;color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::deleteMax(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  if(isRed(h-&gt;left))</span><br><span class="line">    h = rotateRight(h);</span><br><span class="line">  if(!h-&gt;right)</span><br><span class="line">    return h-&gt;left;</span><br><span class="line">  if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left))</span><br><span class="line">    h = removeRedRight(h);</span><br><span class="line">  h-&gt;right = deleteMax(h-&gt;right);</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  return balance(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::removeRedRight(shared_ptr&lt;Node&gt; h)</span><br><span class="line">&#123;</span><br><span class="line">  flipColor(h);</span><br><span class="line">  if(isRed(h-&gt;left-&gt;left)) &#123;</span><br><span class="line">    h = rotateRight(h);</span><br><span class="line">    flipColor(h);</span><br><span class="line">  &#125;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void RedBlackBST&lt;Key,Val&gt;::delet(const Key&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right))</span><br><span class="line">    root-&gt;color = Color::Red;</span><br><span class="line">  root = delet(root, key);</span><br><span class="line">  if(root)</span><br><span class="line">    root-&gt;color = Color::Black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::delet(shared_ptr&lt;Node&gt; h, const Key&amp; key) </span><br><span class="line">&#123;</span><br><span class="line">  int cmp = h-&gt;compareTo(key);</span><br><span class="line">  if(cmp &gt; 0) &#123;</span><br><span class="line">    if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) </span><br><span class="line">      h = removeRedLeft(h);</span><br><span class="line">    h-&gt;left = delet(h-&gt;left, key);</span><br><span class="line">  &#125; else if(cmp &lt; 0)&#123;</span><br><span class="line">    if(isRed(h-&gt;left))</span><br><span class="line">      h = rotateRight(h);</span><br><span class="line">    if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) &#123;</span><br><span class="line">      h = removeRedRight(h);</span><br><span class="line">    &#125;</span><br><span class="line">    h-&gt;right = delet(h-&gt;right, key);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if(!h-&gt;right)</span><br><span class="line">      return h-&gt;left;</span><br><span class="line">    h-&gt;val = get(h-&gt;right, min(h-&gt;right)-&gt;key)-&gt;val;</span><br><span class="line">    h-&gt;key = min(h-&gt;right)-&gt;key;</span><br><span class="line">    h-&gt;right = deleteMin(h-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1;</span><br><span class="line">  return balance(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">vector&lt;Key&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::keys(const Key&amp; m, const Key&amp; e) const</span><br><span class="line">&#123;</span><br><span class="line">  vector&lt;Key&gt; res;</span><br><span class="line">  keys(root, res, m, e);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">void </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const</span><br><span class="line">&#123;</span><br><span class="line">  if(!h)</span><br><span class="line">    return ;</span><br><span class="line">  int cmp1 = h-&gt;compareTo(m),</span><br><span class="line">    cmp2 = h-&gt;compareTo(e);</span><br><span class="line">  if(cmp1 &gt;= 0 &amp;&amp; cmp2 &lt;= 0) &#123;</span><br><span class="line">    res.push_back(h-&gt;key);</span><br><span class="line">  &#125;</span><br><span class="line">  if(cmp1 &gt; 0) &#123;</span><br><span class="line">    keys(h-&gt;left, res, m, e);</span><br><span class="line">  &#125; </span><br><span class="line">  if(cmp2 &lt; 0) &#123;</span><br><span class="line">    keys(h-&gt;right, res, m, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename Key, typename Val&gt;</span><br><span class="line">vector&lt;Key&gt; </span><br><span class="line">RedBlackBST&lt;Key,Val&gt;::keys() const</span><br><span class="line">&#123;</span><br><span class="line">  return keys(min(), max());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179.最大数</title>
      <link href="/2020/01/11/leetcode179/"/>
      <url>/2020/01/11/leetcode179/</url>
      
        <content type="html"><![CDATA[<h4 id="🥩堆排序"><a href="#🥩堆排序" class="headerlink" title="🥩堆排序"></a>🥩堆排序</h4><p>&emsp;&emsp;堆排序，然后将数字拼接成字符串，但是两个数字之间的比较并不能直接用&gt;&lt;来进行。我的方法是定义compare函数，进行比较。compare比较两个数的方法是：比如121，12，那么就比较121|12和12|121的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; a) &#123;</span><br><span class="line">        if(!a.size())</span><br><span class="line">          return &quot;&quot;;</span><br><span class="line">        string s;</span><br><span class="line"></span><br><span class="line">        //堆排序</span><br><span class="line">        a.insert(a.begin(), -1);</span><br><span class="line">        int n = a.size() - 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">          swim(a, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        // for(auto x : a) &#123;</span><br><span class="line">        //   cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        // cout &lt;&lt; endl;</span><br><span class="line">        while(n &gt; 1) &#123;</span><br><span class="line">          swap(a[1], a[n--]);</span><br><span class="line">          sink(a, 1, n);</span><br><span class="line">        &#125;</span><br><span class="line">        // for(auto x : a) &#123;</span><br><span class="line">        //   cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        for(int i = 1; i &lt; a.size(); ++i) </span><br><span class="line">          s += to_string(a[i]);</span><br><span class="line">        int ct = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;; ++i) &#123;</span><br><span class="line">          ++ct;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ct == s.size()) return &quot;0&quot;;</span><br><span class="line">        return s.substr(ct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void swim(vector&lt;int&gt;&amp; a, int k, int n) &#123;</span><br><span class="line">      cout &lt;&lt; &quot;swim&quot; &lt;&lt; endl;</span><br><span class="line">      int j;</span><br><span class="line">      while(k &gt; 1) &#123;</span><br><span class="line">        j = k /2;</span><br><span class="line">        if(j &gt;= 1 &amp;&amp; compare(a[j],a[k]) != 1) break;</span><br><span class="line">        swap(a[j], a[k]);</span><br><span class="line">        k = j;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sink(vector&lt;int&gt;&amp; a, int k, int n) &#123;</span><br><span class="line">      int j ;</span><br><span class="line">      while(k &lt;= n / 2) &#123;</span><br><span class="line">        j = 2 * k;</span><br><span class="line">        if(j + 1 &lt;= n &amp;&amp; compare(a[j + 1], a[j]) == -1) ++j;</span><br><span class="line">        if(compare(a[j], a[k]) != -1) break;</span><br><span class="line">        swap(a[j], a[k]);</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int compare(int i, int j) &#123;</span><br><span class="line">      if(i == j) </span><br><span class="line">        return 0;</span><br><span class="line">      int com = 0, ix = 0, jx = 0, ii = i, jj = j;</span><br><span class="line">      while(ii / 10 &gt; 0) &#123;</span><br><span class="line">        ix++;</span><br><span class="line">        ii /=  10;</span><br><span class="line">      &#125;</span><br><span class="line">      while(jj / 10 &gt; 0) &#123;</span><br><span class="line">        jx++;</span><br><span class="line">        jj /= 10;</span><br><span class="line">      &#125;</span><br><span class="line">      long long ir ,jr;</span><br><span class="line">      jr = j * pow(10, ix + 1) + i;</span><br><span class="line">      ir = i * pow(10, jx + 1) + j;</span><br><span class="line">      // cout &lt;&lt; &quot;i, j: &quot; &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; jr &lt;&lt; endl;</span><br><span class="line">      if(ir &gt; jr) return 1;</span><br><span class="line">      else if(jr &gt; ir) return -1;</span><br><span class="line">      else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>222/222 cases passed (8 ms) <br><br>Your runtime beats 91.43 % of cpp submissions <br><br>Your memory usage beats 79.45 % of cpp submissions (9.1 MB) <br></p></blockquote><h4 id="🈶改进"><a href="#🈶改进" class="headerlink" title="🈶改进"></a>🈶改进</h4><p>&emsp;&emsp;相比与我将两个数拼在一起比较，更加好的方法是<strong>转化为字符串比较</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (all_of(nums.begin(), nums.end(), [](int x) &#123; return x == 0; &#125;)) &#123;</span><br><span class="line">            return string(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; strNums(nums.size());</span><br><span class="line">        std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123;</span><br><span class="line">            return std::to_string(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        std::sort(strNums.begin(), strNums.end(), [](const string&amp; x, const string&amp; y) &#123;</span><br><span class="line">            /* x为后面元素，y为前面元素，return true则将x移动到前面 */</span><br><span class="line">            return x + y &gt; y + x;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return std::accumulate(strNums.begin(), strNums.end(), string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>147.对链表进行插入排序</title>
      <link href="/2020/01/11/leetcode147/"/>
      <url>/2020/01/11/leetcode147/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧模仿数组的实现"><a href="#🥧模仿数组的实现" class="headerlink" title="🥧模仿数组的实现"></a>🥧模仿数组的实现</h4><p>&emsp;&emsp;注意pre指针的调整，在内循环改变一个节点ptr的位置后，外层循环的ptr的下一个循环就不是ptr-&gt;next了，而是pre-&gt;next</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) </span><br><span class="line">            return head;</span><br><span class="line">        ListNode* ptr = head-&gt;next, *nex, *pre = head,*ptr2, *pre2,</span><br><span class="line">        npre = ListNode(INT_MIN);</span><br><span class="line">        npre.next = head;</span><br><span class="line">        for( ; ptr != nullptr; ) &#123;</span><br><span class="line">            for(ptr2 = npre.next, pre2 = &amp;npre; ptr2 != ptr; ptr2 = ptr2-&gt;next, pre2 = pre2-&gt;next)&#123;</span><br><span class="line">                if(ptr2-&gt;val &gt;= ptr-&gt;val) &#123;</span><br><span class="line">                    pre-&gt;next = ptr-&gt;next;</span><br><span class="line">                    ptr-&gt;next = ptr2;</span><br><span class="line">                    pre2-&gt;next = ptr;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ptr2 == ptr) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ptr = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            // for(auto x = &amp;npre; x != nullptr; x = x-&gt;next) &#123;</span><br><span class="line">            //     cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            // &#125;</span><br><span class="line">            // cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return npre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>22/22 cases passed (100 ms) <br><br>Your runtime beats 6.64 % of cpp submissions <br><br>Your memory usage beats 13.73 % of cpp submissions (9.7 MB) <br></p></blockquote><h4 id="🏆改进版"><a href="#🏆改进版" class="headerlink" title="🏆改进版"></a>🏆改进版</h4><p>&emsp;&emsp;对于插入排序来说，我们没有必要记录那么多前置节点的位置，<strong>我们只要保证ptr左边的序列有序即可</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next) </span><br><span class="line">            return head;</span><br><span class="line">        ListNode* ptr = head, *nex,*ptr2, </span><br><span class="line">        npre = ListNode(INT_MIN);</span><br><span class="line">        while(ptr) &#123;</span><br><span class="line">            nex = ptr-&gt;next;</span><br><span class="line">            ptr2 = &amp;npre;</span><br><span class="line">            while(ptr2-&gt;next &amp;&amp; ptr2-&gt;next-&gt;val &lt; ptr-&gt;val)</span><br><span class="line">                ptr2 = ptr2-&gt;next;</span><br><span class="line">            ptr-&gt;next = ptr2-&gt;next;</span><br><span class="line">            ptr2-&gt;next = ptr;</span><br><span class="line">            // for(auto x = &amp;npre; x != NULL; x = x-&gt;next) &#123;</span><br><span class="line">            //     cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            // &#125;</span><br><span class="line">            // cout &lt;&lt; &quot; cur: &quot; &lt;&lt; ptr-&gt;val  &lt;&lt; endl;</span><br><span class="line">            ptr = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return npre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>22/22 cases passed (48 ms)<br><br>Your runtime beats 73.88 % of cpp submissions <br><br>Your memory usage beats 15.9 % of cpp submissions (9.7 MB)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56.合并区间</title>
      <link href="/2020/01/11/leetcode56/"/>
      <url>/2020/01/11/leetcode56/</url>
      
        <content type="html"><![CDATA[<h4 id="🥛使用数组"><a href="#🥛使用数组" class="headerlink" title="🥛使用数组"></a>🥛使用数组</h4><p>&emsp;&emsp;使用数组来进行操作，特别[0,1][2,4]这样连在一起。却没有相交的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        char arr[3000] = &quot;&quot;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(auto x : intervals) &#123;</span><br><span class="line">            memset(arr + x[0], &apos;1&apos; ,x[1] - x[0]);</span><br><span class="line">            if(arr[x[1]] != &apos;1&apos;)</span><br><span class="line">                arr[x[1]] = &apos;2&apos;;</span><br><span class="line">            else </span><br><span class="line">                arr[x[1]] = &apos;1&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0, k;</span><br><span class="line">        for(int i = 0; i &lt; 3000; ++i) &#123;</span><br><span class="line">            if(arr[i] != &apos;\0&apos;) &#123;</span><br><span class="line">                count = 0;</span><br><span class="line">                for(k = i; k &lt; 3000 &amp;&amp; arr[k] == &apos;1&apos;; ++k) &#123;</span><br><span class="line">                    arr[k] = &apos;\0&apos;;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k] = &apos;\0&apos;;</span><br><span class="line">                res.push_back(vector&lt;int&gt;&#123;i, i + count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>169/169 cases passed (20 ms)<br><br>Your runtime beats 90.61 % of cpp submissions<br><br>Your memory usage beats 5.08 % of cpp submissions (13.3 MB)</p></blockquote><hr><h4 id="🚆排序后比较"><a href="#🚆排序后比较" class="headerlink" title="🚆排序后比较"></a>🚆排序后比较</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a ,const vector&lt;int&gt;&amp; b)&#123;</span><br><span class="line">            return a[0] &lt; b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        // for(auto x : intervals) &#123;</span><br><span class="line">        //     cout &lt;&lt; x[0] &lt;&lt; x[1] &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line">        int i = 0, beg, endx, n = intervals.size();</span><br><span class="line">        while(i &lt; n) &#123;</span><br><span class="line">            beg = intervals[i][0];</span><br><span class="line">            endx = intervals[i][1];</span><br><span class="line">            while(i &lt; n - 1&amp;&amp; intervals[i + 1][0] &lt;= endx) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                if(intervals[i][1] &gt; endx) </span><br><span class="line">                    endx = intervals[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">            // cout &lt;&lt; beg &lt;&lt; &quot; &quot; &lt;&lt; endx &lt;&lt; endl;</span><br><span class="line">            res.push_back(vector&lt;int&gt;&#123;beg, endx&#125;);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>169/169 cases passed (12 ms)<br><br>Your runtime beats 99.88 % of cpp submissions<br><br>Your memory usage beats 5.08 % of cpp submissions (12.7 MB)<br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75.颜色分类</title>
      <link href="/2020/01/11/leetcode75/"/>
      <url>/2020/01/11/leetcode75/</url>
      
        <content type="html"><![CDATA[<h4 id="🥧典型的堆排序题目"><a href="#🥧典型的堆排序题目" class="headerlink" title="🥧典型的堆排序题目"></a>🥧典型的堆排序题目</h4><p>&emsp;&emsp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        nums.insert(nums.begin(), 0);</span><br><span class="line">        int n = nums.size() - 1;</span><br><span class="line">        for(int i = n / 2; i &gt;= 1; --i) &#123;</span><br><span class="line">            sink(nums, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        while(n &gt; 1) &#123;</span><br><span class="line">            swap(nums[1], nums[n--]);</span><br><span class="line">            sink(nums, 1, n);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.erase(nums.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    void sink(vector&lt;int&gt;&amp; nums, int k,int n) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        while(k &lt;= n / 2) &#123;</span><br><span class="line">            j = k * 2;</span><br><span class="line">            if(nums[j] &lt; nums[j + 1] &amp;&amp; j + 1 &lt;= n) ++j;</span><br><span class="line">            if(nums[k] &gt;= nums[j]) break;</span><br><span class="line">            swap(nums[k], nums[j]);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>87/87 cases passed (0 ms)<br><br>Your runtime beats 100 % of cpp submissions<br><br>Your memory usage beats 5.17 % of cpp submissions (8.9 MB)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.合并两个有序链表</title>
      <link href="/2020/01/11/leetcode21/"/>
      <url>/2020/01/11/leetcode21/</url>
      
        <content type="html"><![CDATA[<h4 id="🥛迭代"><a href="#🥛迭代" class="headerlink" title="🥛迭代"></a>🥛迭代</h4><p>&emsp;&emsp;类似与归并排序的合并函数，实际还要更简单一些，没有长度的限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode nd(0), *pre = &amp;nd;</span><br><span class="line">        while(l1 || l2) &#123;</span><br><span class="line">            if(!l1) &#123;</span><br><span class="line">                pre-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; else if(!l2) &#123;</span><br><span class="line">                pre-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else if(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                pre-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pre-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nd.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>208/208 cases passed (8 ms)<br><br>Your runtime beats 93.28 % of cpp submissions<br><br>Your memory usage beats 76.07 % of cpp submissions (9 MB)<br></p></blockquote><h4 id="🥛递归"><a href="#🥛递归" class="headerlink" title="🥛递归"></a>🥛递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if(!l1)</span><br><span class="line">            return l2;</span><br><span class="line">        else if(!l2) </span><br><span class="line">            return l1;</span><br><span class="line">        else if(l2-&gt;val &lt; l1-&gt;val) &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            return l2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>208/208 cases passed (8 ms) <br><br>Your runtime beats 93.28 % of cpp submissions<br><br>Your memory usage beats 75.58 % of cpp submissions (9 MB) <br></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. 排序链表</title>
      <link href="/2020/01/11/leetcode148/"/>
      <url>/2020/01/11/leetcode148/</url>
      
        <content type="html"><![CDATA[<h4 id="🥩自顶向下归并排序"><a href="#🥩自顶向下归并排序" class="headerlink" title="🥩自顶向下归并排序"></a>🥩自顶向下归并排序</h4><p>&emsp;&emsp;基础版，根据算法4中的数组的归并算法改得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if(!head) return head; </span><br><span class="line">        n = 1;</span><br><span class="line">         ListNode* h = head;</span><br><span class="line">        while(h-&gt;next != NULL) &#123;</span><br><span class="line">            h = h-&gt;next;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; &quot;count : &quot; &lt;&lt; n  &lt;&lt; endl;</span><br><span class="line">        aux = new int[n]();</span><br><span class="line">        sortList(head, 0, n - 1);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    void sortList(ListNode* head, int i, int j) &#123;</span><br><span class="line">        if(i &gt;= j) return ;</span><br><span class="line">        int mid = i + (j - i) / 2; </span><br><span class="line">        sortList(head, i, mid);</span><br><span class="line">        sortList(head, mid + 1, j);</span><br><span class="line">        merge(head, i, mid, j);</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(ListNode* head, int i,int mid, int j) &#123;</span><br><span class="line">        //cout &lt;&lt; &quot;i,m.j : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        ListNode* inode = at(head, i),* inode2 = inode;</span><br><span class="line">        //cout &lt;&lt; &quot;inode-&gt;val: &quot; &lt;&lt;  inode2-&gt;val &lt;&lt; endl;</span><br><span class="line">        int lo = i - i, hi = mid + 1 - i;</span><br><span class="line">        for(int k = 0; k &lt;= j - i; ++k , inode = inode-&gt;next)</span><br><span class="line">            aux[k + i] = inode-&gt;val;</span><br><span class="line">        // for(int k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">            //cout &lt;&lt; aux[k] &lt;&lt; &quot; &quot;;</span><br><span class="line">        // &#125;</span><br><span class="line">        //cout &lt;&lt; endl;</span><br><span class="line">        for(int k = 0; k &lt;= j - i; ++k) &#123;</span><br><span class="line">            if(lo &gt; mid - i)&#123; </span><br><span class="line">                inode2-&gt;val = aux[hi + i];</span><br><span class="line">                ++hi;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (hi &gt; j - i) &#123;</span><br><span class="line">                inode2-&gt;val = aux[lo + i];</span><br><span class="line">                ++lo;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (aux[lo + i] &gt; aux[hi + i]) &#123;</span><br><span class="line">                inode2-&gt;val = aux[hi + i];</span><br><span class="line">                ++hi;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                inode2-&gt;val = aux[lo + i];</span><br><span class="line">                ++lo;</span><br><span class="line">            &#125;</span><br><span class="line">            //cout &lt;&lt; &quot;lo, hi : &quot; &lt;&lt; lo &lt;&lt;  &quot; &quot; &lt;&lt; hi &lt;&lt; endl;</span><br><span class="line">            inode2 = inode2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* at(ListNode* head, int n) &#123;</span><br><span class="line">        while(n--)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125; </span><br><span class="line">    int* aux;</span><br><span class="line">    int n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>16/16 cases passed (1108 ms) <br><br>Your runtime beats 5.09 % of cpp submissions<br><br>Your memory usage beats 62.56 % of cpp submissions (12.3 MB)</p></blockquote><h4 id="🥧自顶向下归并排序2"><a href="#🥧自顶向下归并排序2" class="headerlink" title="🥧自顶向下归并排序2"></a>🥧自顶向下归并排序2</h4><p>&emsp;&emsp;学习自<a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/" target="_blank" rel="noopener">链接</a>,以一种链表得方式来做，而不是以数组得方式来思考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next)</span><br><span class="line">            return head;</span><br><span class="line">        ListNode* slow = head, </span><br><span class="line">            * fast = head-&gt;next;</span><br><span class="line">        while(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = nullptr;</span><br><span class="line">        ListNode* left = sortList(head);</span><br><span class="line">        ListNode* right = sortList(tmp);</span><br><span class="line">        ListNode thead = ListNode(-1), *thd = &amp;thead;</span><br><span class="line">        while(left || right) &#123;</span><br><span class="line">            if(!left) &#123;</span><br><span class="line">                thd-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125; else if(!right) &#123;</span><br><span class="line">                thd-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; else if (right-&gt;val &gt; left-&gt;val) &#123;</span><br><span class="line">                thd-&gt;next = left;</span><br><span class="line">                left = left-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                thd-&gt;next = right;</span><br><span class="line">                right = right-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            thd = thd-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return thead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted <br><br>16/16 cases passed (24 ms)<br><br>Your runtime beats 100 % of cpp submissions<br><br>Your memory usage beats 72.66 % of cpp submissions (11.9 MB)</p></blockquote><h4 id="🥣自底向上归并排序"><a href="#🥣自底向上归并排序" class="headerlink" title="🥣自底向上归并排序"></a>🥣自底向上归并排序</h4><p>&emsp;&emsp;学习自<a href="https://leetcode-cn.com/problems/sort-list/solution/java-zi-di-xiang-shang-gui-bing-by-lava-4/" target="_blank" rel="noopener">链接</a>，自底向上得链表，有几个难点:</p><ul><li>如何每次merge后与后面得链表接上</li><li>如何串联成一个长得链表最后返回<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if(!head || !head-&gt;next)</span><br><span class="line">            return head;</span><br><span class="line">        ListNode* preNode = new ListNode(0), *pre = preNode;</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while((pre = pre-&gt;next) &amp;&amp; ++count) ;</span><br><span class="line">        // cout &lt;&lt; &quot;count : &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">        pre = preNode;</span><br><span class="line">        for(int sz = 1; sz &lt; count; sz *=2) &#123;</span><br><span class="line">            while(pre = sortList(pre, sz)) ;</span><br><span class="line">            pre = preNode;</span><br><span class="line">        &#125;</span><br><span class="line">        return preNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* pre, int sz) &#123;</span><br><span class="line">        ListNode* fl = pre-&gt;next, </span><br><span class="line">            *ll = pre-&gt;next;</span><br><span class="line">        for(int i = 0; i &lt; sz ; ++i) &#123;</span><br><span class="line">            if(!ll) </span><br><span class="line">                return nullptr;</span><br><span class="line">            ll =ll-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        int lc = 0, fc = 0;</span><br><span class="line">        while(fc &lt; sz) &#123;</span><br><span class="line">            if(lc == sz || ll == nullptr || ll-&gt;val &gt; fl-&gt;val) &#123;</span><br><span class="line">                ++fc;</span><br><span class="line">                pre-&gt;next = fl;</span><br><span class="line">                fl = fl-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++lc;</span><br><span class="line">                pre-&gt;next = ll;</span><br><span class="line">                ll = ll-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(lc &lt; sz &amp;&amp; ll) &#123;</span><br><span class="line">            ++lc;</span><br><span class="line">            pre-&gt;next = ll;</span><br><span class="line">            ll = ll-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = ll;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Accepted<br><br>16/16 cases passed (24 ms)<br><br>Your runtime beats 100 % of cpp submissions<br><br>Your memory usage beats 93.48 % of cpp submissions (11.5 MB)<br></p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2020/01/10/alg4/"/>
      <url>/2020/01/10/alg4/</url>
      
        <content type="html"><![CDATA[<h4 id="😘代码实现"><a href="#😘代码实现" class="headerlink" title="😘代码实现"></a>😘代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> **/</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class HeapSort &#123;</span><br><span class="line">  public:</span><br><span class="line">    static void sort(vector&lt;T&gt;&amp;);</span><br><span class="line">  private:</span><br><span class="line">    static void sink(vector&lt;T&gt;&amp; a, int k, int N);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123;</span><br><span class="line">  int N = a.size() - 1;</span><br><span class="line">  for(int i = N / 2; i &gt;= 1; --i)</span><br><span class="line">    sink(a, i, N);</span><br><span class="line">  while(N &gt; 1) &#123;</span><br><span class="line">    swap(a[1], a[N--]);</span><br><span class="line">    sink(a, 1, N);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123;</span><br><span class="line">  int j;</span><br><span class="line">  while(k &lt;= N / 2) &#123;</span><br><span class="line">    j = 2 * k;</span><br><span class="line">    if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;</span><br><span class="line">    if(a[k] &gt;= a[j]) break;</span><br><span class="line">    swap(a[k], a[j]);</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="👿注意"><a href="#👿注意" class="headerlink" title="👿注意"></a>👿注意</h4><ul><li>要注意父节点只有一个子节点时的情况，在sink函数中（if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;）一定要注意j&lt;N，不能超出范围</li><li>构造最大堆时，for循环从i = N / 2开始的原因是：sink中有限制条件while(k &lt;= N / 2)，所以N/2&lt;i&lt;N部分无法进入sink的while循环，是没有意义的，徒增N/2次比较</li><li>递增排序使用最大堆，递减排序使用最小堆</li><li>vector的第一个值（下标为0）不使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引优先队列</title>
      <link href="/2020/01/10/alg3/"/>
      <url>/2020/01/10/alg3/</url>
      
        <content type="html"><![CDATA[<h4 id="🥛分析"><a href="#🥛分析" class="headerlink" title="🥛分析"></a>🥛分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class IndexMaxPQ...&#123;</span><br><span class="line">    private int maxN;        // maximum number of elements on PQ</span><br><span class="line">    private int n;           // number of elements on PQ</span><br><span class="line">    private int[] pq;        // binary heap using 1-based indexing</span><br><span class="line">    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i</span><br><span class="line">    private Key[] keys;      // keys[i] = priority of i</span><br><span class="line"></span><br><span class="line">//中间省略...</span><br><span class="line">public void insert(int i, Key key) &#123;</span><br><span class="line">        ...</span><br><span class="line">        n++;</span><br><span class="line">        qp[i] = n;</span><br><span class="line">        pq[n] = i;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        swim(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据《算法4》给出的代码，分析这两段代码我们可以看出来：</p><ul><li>在定义处可知pq是<strong>二叉堆的数组</strong></li><li>由qp[i] = n;<pre><code>pq[n] = i;可以看出来，qp这个数组的用处就是为了记录**pq中值为i的下标是多少**，这样当我们要改下标为i的元素的值时，我们就不用遍历pq来获得位置了，**用空间来换取时间**</code></pre></li><li>并且这个索引i仅仅为了找到元素对象key，并没实际的意义。n才是对应二叉堆的位置。<br></li></ul><h4 id="😍代码实现"><a href="#😍代码实现" class="headerlink" title="😍代码实现"></a>😍代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include  &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 索引最小优先队列</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class IndexMinPQ &#123;</span><br><span class="line">  public:</span><br><span class="line">    IndexMinPQ(int max);</span><br><span class="line">    void show() const;</span><br><span class="line">    int size() const &#123;return N;&#125;</span><br><span class="line">    int capacity() const &#123;return _capacity;&#125;</span><br><span class="line">    void insert(int k, T item);</span><br><span class="line">    void change(int k, T item);</span><br><span class="line">    bool contain(int k) const &#123;return qp[k] != -1;&#125;;</span><br><span class="line">    int delMin();</span><br><span class="line">  private:</span><br><span class="line">    void sink(int i);</span><br><span class="line">    void swim(int i);</span><br><span class="line">    T* element; //元素</span><br><span class="line">    int* pq; //二叉堆</span><br><span class="line">    int *qp; //index</span><br><span class="line">    int N;</span><br><span class="line">    int _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) :</span><br><span class="line">  element(new T[max + 1]), pq(new int[max + 1])</span><br><span class="line">  , qp(new int[max + 1]), N(0), _capacity(max) </span><br><span class="line">&#123;</span><br><span class="line">  for(int i = 0; i &lt; max + 1; ++i)</span><br><span class="line">    qp[i] = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void IndexMinPQ&lt;T&gt;::sink(int n)&#123;</span><br><span class="line">  while(n &lt; N) &#123;</span><br><span class="line">    int m = n * 2;</span><br><span class="line">    if(element[pq[m]] &gt; element[pq[m + 1]]) ++m;</span><br><span class="line">    if(element[pq[m]] &lt; element[pq[n]]) break;</span><br><span class="line">    swap(pq[m], pq[n]);</span><br><span class="line">    swap(qp[pq[m]], qp[pq[n]]);</span><br><span class="line">    n = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void IndexMinPQ&lt;T&gt;::swim(int n) &#123;</span><br><span class="line">  while(n &gt; 1) &#123;</span><br><span class="line">    int m = n / 2;</span><br><span class="line">    if(element[pq[m]] &lt;= element[pq[n]]) break;</span><br><span class="line">    swap(pq[m], pq[n]);</span><br><span class="line">    swap(qp[pq[m]], qp[pq[n]]);</span><br><span class="line">    n = m; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123;</span><br><span class="line">  // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">  if(capacity() == size())&#123;</span><br><span class="line">    cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line">  pq[++N] = k;</span><br><span class="line">  element[k] = item;</span><br><span class="line">  qp[k] = N;</span><br><span class="line">  swim(N);</span><br><span class="line">  // show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void IndexMinPQ&lt;T&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; &quot;pq: &quot;;</span><br><span class="line">  for(int i = 1; i &lt;= capacity(); ++i) </span><br><span class="line">    cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot;qp: &quot;;</span><br><span class="line">  for(int i = 1; i &lt;= capacity(); ++i) </span><br><span class="line">    cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot;element: &quot;;</span><br><span class="line">  for(int i = 1; i &lt;= capacity(); ++i) </span><br><span class="line">    cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123;</span><br><span class="line">  if(!contain(k)) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl;</span><br><span class="line">    return ;   </span><br><span class="line">  &#125;</span><br><span class="line">  T old_one = element[k];</span><br><span class="line">  element[k] = item;</span><br><span class="line">  if(item &gt; old_one) </span><br><span class="line">    sink(qp[k]);</span><br><span class="line">  else if(item &lt; old_one)</span><br><span class="line">    swim(qp[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int IndexMinPQ&lt;T&gt;::delMin() &#123;</span><br><span class="line">  int max = pq[1];</span><br><span class="line">  swap(pq[1], pq[N]);</span><br><span class="line">  swap(qp[pq[1]], qp[pq[N]]);</span><br><span class="line">  --N;</span><br><span class="line">  show();</span><br><span class="line">  sink(1);</span><br><span class="line">  show();</span><br><span class="line">  qp[max] = -1;</span><br><span class="line">  element[max] = -1;</span><br><span class="line">  pq[N + 1] = -1;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  IndexMinPQ&lt;int&gt; pq(6);</span><br><span class="line">  vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6);</span><br><span class="line">  for(size_t i = 0; i &lt; v.size(); ++i) &#123;</span><br><span class="line">    pq.insert(i + 1, v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pq.show();</span><br><span class="line">  pq.delMin();</span><br><span class="line">  pq.show();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🍠参考资料：链接"><a href="#🍠参考资料：链接" class="headerlink" title="🍠参考资料：链接"></a>🍠参考资料：<a href="https://www.cnblogs.com/nullzx/p/6624731.html" target="_blank" rel="noopener">链接</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先队列</title>
      <link href="/2020/01/10/alg2/"/>
      <url>/2020/01/10/alg2/</url>
      
        <content type="html"><![CDATA[<h4 id="🍠优先队列的实现有三种："><a href="#🍠优先队列的实现有三种：" class="headerlink" title="🍠优先队列的实现有三种："></a>🍠优先队列的实现有三种：</h4><ul><li>有序数组</li><li>无序数组</li><li>堆</li></ul><h5 id="🍅有序数组"><a href="#🍅有序数组" class="headerlink" title="🍅有序数组"></a>🍅有序数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include  &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 优先队列</span><br><span class="line"> * 2.4.3 有序数组实现</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class OrderArrayMaxPQ &#123;</span><br><span class="line">  private:</span><br><span class="line">    pair&lt;int, T&gt;* arr;</span><br><span class="line">    int N;</span><br><span class="line">    int _capacity;</span><br><span class="line">  public:</span><br><span class="line">    void show() const ;</span><br><span class="line">    explicit OrderArrayMaxPQ(int max);</span><br><span class="line">    ~OrderArrayMaxPQ() &#123;delete [] arr;&#125;</span><br><span class="line">    // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;);</span><br><span class="line">    void insert(pair&lt;int, T&gt;);</span><br><span class="line">    pair&lt;int, T&gt; delMax();</span><br><span class="line">    bool isEmpty() const &#123; return N == 0;&#125;</span><br><span class="line">    int size() const &#123;return N;&#125; </span><br><span class="line">    int capacity() const &#123;return _capacity;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) :</span><br><span class="line">  arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// template&lt;typename T&gt;</span><br><span class="line">// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) </span><br><span class="line">//   : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())</span><br><span class="line">// &#123;</span><br><span class="line">//   copy(l.begin(), l.end(), arr);</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123;</span><br><span class="line">  if(capacity() == size()) </span><br><span class="line">    return ;</span><br><span class="line">  arr[N++] = x;</span><br><span class="line">  for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i)</span><br><span class="line">    swap(arr[i], arr[i - 1]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123;</span><br><span class="line">  pair&lt;int ,T&gt; res;</span><br><span class="line">  if(isEmpty())</span><br><span class="line">    return res;</span><br><span class="line">  res = arr[N - 1];</span><br><span class="line">  arr[--N] = pair&lt;int , T&gt;();</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void OrderArrayMaxPQ&lt;T&gt;::show() const &#123;</span><br><span class="line">  cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;;</span><br><span class="line">  for(int i = 0; i &lt; N; ++i)</span><br><span class="line">    cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  OrderArrayMaxPQ&lt;int&gt; pq(20);</span><br><span class="line">  vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12);</span><br><span class="line">  for(auto x: v) &#123;</span><br><span class="line">    pq.insert(&#123;x, x&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  while(pq.size()) &#123;</span><br><span class="line">    pq.show();</span><br><span class="line">    pq.delMax();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="🥦无序数组"><a href="#🥦无序数组" class="headerlink" title="🥦无序数组"></a>🥦无序数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include  &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 优先队列</span><br><span class="line"> * 2.4.3 无序数组实现</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class UnOrderArrayMaxPQ &#123;</span><br><span class="line">  private:</span><br><span class="line">    pair&lt;int, T&gt;* arr;</span><br><span class="line">    int N;</span><br><span class="line">    int _capacity;</span><br><span class="line">  public:</span><br><span class="line">    void show() const ;</span><br><span class="line">    explicit UnOrderArrayMaxPQ(int max);</span><br><span class="line">    ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125;</span><br><span class="line">    explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;);</span><br><span class="line">    void insert(pair&lt;int, T&gt;);</span><br><span class="line">    pair&lt;int, T&gt; delMax();</span><br><span class="line">    bool isEmpty() const &#123; return N == 0;&#125;</span><br><span class="line">    int size() const &#123;return N;&#125; </span><br><span class="line">    int capacity() const &#123;return _capacity;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) :</span><br><span class="line">  arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) </span><br><span class="line">  : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())</span><br><span class="line">&#123;</span><br><span class="line">  copy(l.begin(), l.end(), arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123;</span><br><span class="line">  if(capacity() == size()) </span><br><span class="line">    return ;</span><br><span class="line">  arr[N++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123;</span><br><span class="line">  if(isEmpty())</span><br><span class="line">    return pair&lt;int, T&gt;();</span><br><span class="line">  int max_one = 0;</span><br><span class="line">  for(int i = 0; i &lt; N; ++i) </span><br><span class="line">    if(arr[max_one].first &lt; arr[i].first) &#123;</span><br><span class="line">      max_one = i;</span><br><span class="line">    &#125;</span><br><span class="line">  swap(arr[max_one], arr[--N]);</span><br><span class="line">  pair&lt;int,T&gt; res = arr[N];</span><br><span class="line">  arr[N] = pair&lt;int,T&gt;();</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123;</span><br><span class="line">  cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;;</span><br><span class="line">  for(int i = 0; i &lt; N; ++i)</span><br><span class="line">    cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  UnOrderArrayMaxPQ&lt;int&gt; pq(20);</span><br><span class="line">  vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12);</span><br><span class="line">  for(auto x: v) &#123;</span><br><span class="line">    pq.insert(&#123;x, x&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  while(pq.size()) &#123;</span><br><span class="line">    pq.show();</span><br><span class="line">    pq.delMax();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="🥧堆"><a href="#🥧堆" class="headerlink" title="🥧堆"></a>🥧堆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include  &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Common.hpp&quot;</span><br><span class="line">#include &lt;limits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 优先队列</span><br><span class="line"> * 二叉堆实现</span><br><span class="line"> **/ </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class MaxPQ &#123;</span><br><span class="line">  private:</span><br><span class="line">    pair&lt;int, T&gt;* arr;</span><br><span class="line">    int N;</span><br><span class="line">    int _capacity;</span><br><span class="line">    void swim(int i);</span><br><span class="line">    void sink(int i);</span><br><span class="line">  public:</span><br><span class="line">    void show() const ;</span><br><span class="line">    explicit MaxPQ(int max);</span><br><span class="line">    ~MaxPQ() &#123;delete [] arr;&#125;</span><br><span class="line">    void insert(pair&lt;int, T&gt;);</span><br><span class="line">    pair&lt;int, T&gt; delMax();</span><br><span class="line">    bool isEmpty() const &#123; return N == 0;&#125;</span><br><span class="line">    int size() const &#123;return N;&#125; </span><br><span class="line">    int capacity() const &#123;return _capacity;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">MaxPQ&lt;T&gt;::MaxPQ(int max) :</span><br><span class="line">  arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)</span><br><span class="line">&#123;</span><br><span class="line">  arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123;</span><br><span class="line">  if(capacity() == size()) </span><br><span class="line">    return ;</span><br><span class="line">  arr[++N] = x;</span><br><span class="line">  swim(N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123;</span><br><span class="line">  pair&lt;int ,T&gt; res;</span><br><span class="line">  if(isEmpty())</span><br><span class="line">    return res;</span><br><span class="line">  swap(arr[N--], arr[1]);</span><br><span class="line">  res =  arr[N + 1];</span><br><span class="line">  arr[N + 1] = pair&lt;int ,T&gt;();</span><br><span class="line">  sink(1);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void MaxPQ&lt;T&gt;::show() const &#123;</span><br><span class="line">  cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;;</span><br><span class="line">  for(int i = 1; i &lt;= N; ++i)</span><br><span class="line">    cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void MaxPQ&lt;T&gt;::swim(int i) &#123;</span><br><span class="line">  while(i &gt; 1) &#123;</span><br><span class="line">    if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]);</span><br><span class="line">    i /= 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void MaxPQ&lt;T&gt;::sink(int i) &#123;</span><br><span class="line">  int k;</span><br><span class="line">  while(i &lt; N) &#123;</span><br><span class="line">    k = 2 * i;</span><br><span class="line">    if(arr[k].first &lt; arr[k + 1].first) ++k;</span><br><span class="line">    if(arr[k].first &lt;= arr[i].first) break;</span><br><span class="line">    swap(arr[k], arr[i]);</span><br><span class="line">    i = k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  MaxPQ&lt;int&gt; pq(20);</span><br><span class="line">  vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12);</span><br><span class="line">  for(auto x: v) &#123;</span><br><span class="line">    pq.insert(&#123;x, x&#125;);</span><br><span class="line">    // pq.show();</span><br><span class="line">  &#125;</span><br><span class="line">  while(pq.size()) &#123;</span><br><span class="line">    pq.show();</span><br><span class="line">    pq.delMax();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🥨时间复杂度对比"><a href="#🥨时间复杂度对比" class="headerlink" title="🥨时间复杂度对比"></a>🥨时间复杂度对比</h4><ul><li>有序数组： 插入：N，删除：1</li><li>无序数组： 插入：1，删除：N</li><li>堆：插入、删除：lgN</li><li>理想情况：都是1</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为甚么异或能够确定两个数的符号是否相同？</title>
      <link href="/2020/01/08/problems2/"/>
      <url>/2020/01/08/problems2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int a  = -1;</span><br><span class="line">printf(&quot;%d,%u,%x&quot;,a,a,a);</span><br></pre></td></tr></table></figure><p>-1,4294967295,ffffffff<br><br>从结果上来说,验证了C++中使用的是<strong>补码</strong>。</p><h4 id="🍠现在说一说为什么异或能够确定两个数的符号是否相同？"><a href="#🍠现在说一说为什么异或能够确定两个数的符号是否相同？" class="headerlink" title="🍠现在说一说为什么异或能够确定两个数的符号是否相同？"></a>🍠现在说一说为什么异或能够确定两个数的符号是否相同？</h4><p>&emsp;&emsp;这里还有一个前提，两个数都是int类型，因为补码的原因，如果两个数的正负不同，那么它们的第一位就不同，因为int的第一位是正负的标志位。<br>通过异或，那么正数的第一位为0，负数的第一位为1，异或后第一位就为1，所以可以得到计算出的值为负值。相反如果两者符号相同，那么通过异或后，第一位就为0，所以为正数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2020/01/07/alg1/"/>
      <url>/2020/01/07/alg1/</url>
      
        <content type="html"><![CDATA[<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>logN</p><h4 id="二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的"><a href="#二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的" class="headerlink" title="二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的"></a>二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的</h4><p>😜递归式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123;</span><br><span class="line">  // if(lo &gt; ho) return -1;</span><br><span class="line">  // int mid = (lo + ho) / 2;</span><br><span class="line">  // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key);</span><br><span class="line">  // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key);</span><br><span class="line">  // else return mid;</span><br><span class="line">  if(lo &gt;= ho) return -1;</span><br><span class="line">  int mid = (lo + ho) / 2;</span><br><span class="line">  if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key);</span><br><span class="line">  else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key);</span><br><span class="line">  else return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<del>区间的开闭自由选取，主要是要<strong>统一</strong>，如果要求传入左闭右开区间，那么在函数内部的处理也要保持左闭右开。</del><br>一般的选择应该时左右都是闭区间，而在特殊情况时（数组中有多个相同的目标时），这时选择左闭右开。<br><br><br>🥛参考：<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="noopener">wiki链接</a><br><br><br>&emsp;&emsp;为了避免ho + lo 大于INT_MAX最好改用lo + (ho - lo) / 2</p><p>🈶非递归式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123;</span><br><span class="line">  int lo = 0,</span><br><span class="line">    ho = a.size(),</span><br><span class="line">  mid;</span><br><span class="line">  while(lo &lt; ho) &#123;</span><br><span class="line">    mid = (lo + ho) / 2;</span><br><span class="line">    if(a[mid] &gt; key) ho = mid;</span><br><span class="line">    else if(a[mid] &lt; key) lo = mid + 1;</span><br><span class="line">    else return mid;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归要满足三个原则：</p><ol><li>递归总有一个最简单的情况—方法的第一句总是一个包含return的条件语句。</li><li>递归调用总要尝试取解决一个<strong>规模更小</strong>的子问题。</li><li>递归调用的父问题和子问题之间不应该有<strong>交集</strong>。</li></ol><p>🥘推荐相关资料：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">讲解</a></p><h5 id="👍练习题目1：4-寻找两个有序数组的中位数"><a href="#👍练习题目1：4-寻找两个有序数组的中位数" class="headerlink" title="👍练习题目1：4. 寻找两个有序数组的中位数"></a>👍练习题目1：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/submissions/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        //首先要判定拿个序列更加长</span><br><span class="line">        if(nums1.size() &gt; nums2.size())</span><br><span class="line">            swap(nums1, nums2);</span><br><span class="line">        //左闭右开</span><br><span class="line">        int imin = 0,</span><br><span class="line">            imax = nums1.size(),</span><br><span class="line">            j, i,</span><br><span class="line">            m = nums1.size(),</span><br><span class="line">            n = nums2.size(),</span><br><span class="line">            halflen = (m + n + 1) / 2;</span><br><span class="line">        while(imin &lt;= imax) &#123;</span><br><span class="line">            i = (imax + imin ) / 2;</span><br><span class="line">            j =  halflen - i;</span><br><span class="line">            // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123;</span><br><span class="line">                imin = i + 1;</span><br><span class="line">            &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123;</span><br><span class="line">                imax = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;</span><br><span class="line">                int leftMax, rightMin;</span><br><span class="line">                if(i == 0 ) leftMax = nums2[j - 1];</span><br><span class="line">                else if(j == 0) leftMax = nums1[i - 1];</span><br><span class="line">                else leftMax = max(nums1[i - 1], nums2[j - 1]);</span><br><span class="line">                if((m + n) % 2) return leftMax;</span><br><span class="line"></span><br><span class="line">                if(i == m) rightMin = nums2[j ];</span><br><span class="line">                else if (j == n) rightMin = nums1[ i ];</span><br><span class="line">                else rightMin = min(nums1[i], nums2[j]) ;</span><br><span class="line">                // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl;</span><br><span class="line">                return static_cast&lt;double&gt;(leftMax + rightMin) / 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="👍练习题目2：35-搜索插入位置"><a href="#👍练习题目2：35-搜索插入位置" class="headerlink" title="👍练习题目2：35. 搜索插入位置"></a>👍练习题目2：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int lo = 0,</span><br><span class="line">            ho = nums.size() - 1,</span><br><span class="line">            mid;</span><br><span class="line">        while(lo &lt; ho) &#123;</span><br><span class="line">            mid = (lo + ho + 1) / 2;</span><br><span class="line">            if(nums[mid] &gt; target) &#123;</span><br><span class="line">                ho = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[lo] &lt; target) return lo + 1;</span><br><span class="line">        else return lo;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（6）uv_queue_work</title>
      <link href="/2019/11/26/libuv6/"/>
      <url>/2019/11/26/libuv6/</url>
      
        <content type="html"><![CDATA[<h4 id="🏤问题来由"><a href="#🏤问题来由" class="headerlink" title="🏤问题来由"></a>🏤问题来由</h4><p>&emsp;&emsp;在使用libuv的过程中，我们难免遇见的一个问题是，有一些库没有异步、只能同步运行，这种情况该怎么办呢？比如mysql-connector-cpp。</p><p>&emsp;&emsp;首先要说的是，直接在回调函数中执行mysql-connector-cpp这种会阻塞的操作是不符合Libuv的reactor模式的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_json_lab</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;smpHttp::HttpRequest&gt; req,<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;smpHttp::HttpResponse&gt; res)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Session mq = cli.getSession();</span><br><span class="line">    <span class="keyword">auto</span> sqlres = mq.sql(<span class="string">"Select content FROM labimformation where type = 'labIntroduction'"</span>).execute();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>上面这样便是错误的案例</strong>。我在写<a href="https://github.com/LurenAA/smpHttp" target="_blank" rel="noopener">这个项目</a>时，之前就采用了这样的错误做法。<br><br>&emsp;&emsp;我的这个项目是个http后台，我在接受到POST请求，直接在回调函数中执行mysql操作，这时<strong>整个主线程就阻塞住了<sup>1</sup></strong>，而这就意味着我的http后台不再能接受任何请求，只能等待mysql操作完成后，回调函数返回。而这个mysql的操作耗时一般在3s以上，这对我这个Http后台来说是毁灭性的打击。。。。</p><font size=2 color=#483D8B>1：用户的回调函数是在work->done函数的最后执行的，而work->done是在主线程uv_run中的is_poll中唤醒loop->wq_async后执行的,在work->done函数中阻塞意味着在主线程阻塞住了，uv_run中的事件循环卡住，不再能接受request（这部分不清楚可以去看我的libuv源码分析文章）</font><h4 id="🌆解决办法"><a href="#🌆解决办法" class="headerlink" title="🌆解决办法"></a>🌆解决办法</h4><p>&emsp;&emsp;在<a href="http://docs.libuv.org/en/v1.x/threadpool.html" target="_blank" rel="noopener">手册Thread pool work scheduling</a>中为我们这样的需求提供了这样一个函数：<br><strong>uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)</strong>。<br></p><p>&emsp;&emsp;这个函数就是上面我们问题的解决办法。但是要注意的是uv_async_t不可以替代这个。虽然都是执行用户的函数。async是让用户函数直接被<strong>主线程</strong>在uv_run中运行，而uv_queue_work是将work_cb提交给<strong>子线程</strong>执行，完成后通知主线程，主线程在uv_run中执行after_work_cb。</p><p>&emsp;&emsp;总结下来就是：uv_async_t用来执行不阻塞的任务，uv_queue_work执行要阻塞的任务（考虑到线程切换的消耗一般不用来执行不阻塞的任务）</p><h4 id="🉐看看源码"><a href="#🉐看看源码" class="headerlink" title="🉐看看源码"></a>🉐看看源码</h4><p>&emsp;&emsp;这一部分可以结合这<a href="https://lurenaa.github.io/2019/11/26/libuv5/" target="_blank" rel="noopener">我的这篇文章-libuv源码分析（5）uv_fs_*</a>来看。可以作为佐证，libuv中对着这类没有自带异步版本的阻塞操作的处理是一样的：让子线程去执行这个任务，避免阻塞主线程的事件循环，完成后子线程通知主线程。<br><br><br>uv_queue_work源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_queue_work</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">uv_work_t</span>* req,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_work_cb work_cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                  uv_after_work_cb after_work_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (work_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> UV_EINVAL;</span><br><span class="line"></span><br><span class="line">  uv__req_init(loop, req, UV_WORK);</span><br><span class="line">  req-&gt;loop = loop;</span><br><span class="line">  req-&gt;work_cb = work_cb;</span><br><span class="line">  req-&gt;after_work_cb = after_work_cb;</span><br><span class="line">  uv__work_submit(loop,</span><br><span class="line">                  &amp;req-&gt;work_req,</span><br><span class="line">                  UV__WORK_CPU,</span><br><span class="line">                  uv__queue_work,</span><br><span class="line">                  uv__queue_done);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再结合<a href="https://lurenaa.github.io/2019/11/26/libuv5/" target="_blank" rel="noopener">我的这篇文章-libuv源码分析（5）uv_fs_*</a>中uv_fs_*函数的源码，这些操作可以总结成以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UV_REQ_INIT(req, typ);          <span class="comment">//初始化基类uv_req_t                               </span></span><br><span class="line">uv__req_register(loop, req);   <span class="comment">//添加loop中request的计数，避免uv_run中uv__loop_alive返回0，使得主线程uv_run退出</span></span><br><span class="line">...<span class="comment">//这里是针对不同类型的操作特有的初始化部分</span></span><br><span class="line">uv__work_submit(loop,</span><br><span class="line">                &amp;req-&gt;work_req,</span><br><span class="line">                UV__WORK_CPU, <span class="comment">//操作类型</span></span><br><span class="line">                uv__queue_work, <span class="comment">//要阻塞的操作，在fs中是uv__fs_work</span></span><br><span class="line">                uv__queue_done); <span class="comment">//完成后的回调，在fs中是uv__fs_done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（5）uv_fs_*</title>
      <link href="/2019/11/26/libuv5/"/>
      <url>/2019/11/26/libuv5/</url>
      
        <content type="html"><![CDATA[<h4 id="uv-fs"><a href="#uv-fs" class="headerlink" title="uv_fs_*"></a>uv_fs_*</h4><p>&emsp;&emsp;uv_fs_*这一系列的函数基本是一致的，它们的逻辑大概是如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x代表一种操作open、write等</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_fs_x</span><span class="params">(...<span class="keyword">uv_fs_t</span>* req...)</span> </span>&#123;</span><br><span class="line">  INIT(x); <span class="comment">//uv_fs_t和其基类uv_req_t的基本初始化</span></span><br><span class="line">  ... <span class="comment">//这里是每个操作各自不同对于req的初始化</span></span><br><span class="line">  POST; <span class="comment">//提交这个任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h4><p>&emsp;&emsp;INIT这个宏定义函数没有特别的地方，就是把req初始化，该置0的置0。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>&emsp;&emsp;其实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POST                          </span></span><br><span class="line">  <span class="keyword">do</span> &#123;   <span class="comment">//dowhile包裹作用域          </span></span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>) &#123;                 </span><br><span class="line">      uv__req_register(loop, req);    </span><br><span class="line">      uv__work_submit(loop,           </span><br><span class="line">      &amp;req-&gt;work_req,                 </span><br><span class="line">      UV__WORK_FAST_IO,               </span><br><span class="line">      uv__fs_work,                    </span><br><span class="line">      uv__fs_done);                   </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                       </span><br><span class="line">    &#125;                                 </span><br><span class="line">    <span class="keyword">else</span> &#123;                            </span><br><span class="line">      uv__fs_work(&amp;req-&gt;work_req);    </span><br><span class="line">      <span class="keyword">return</span> req-&gt;result;             </span><br><span class="line">    &#125;                                 </span><br><span class="line">  &#125;                                   </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里通过有无回调函数来决定调用同步版本还是异步版本。</p><blockquote><p><a href="http://docs.libuv.org/en/v1.x/fs.html" target="_blank" rel="noopener">http://docs.libuv.org/en/v1.x/fs.html</a><br>libuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously.</p></blockquote><p>&emsp;&emsp;uv__fs_work这个函数就是<strong>文件操作的封装</strong>，所有的文件操作都通过这个函数来完成，即使是异步，最终也要在别的线程中同步执行这个函数。 <br><br>&emsp;&emsp;uv__fs_done这个函数会调用用户给的回调函数，这个函数会在uv_run中的is_poll函数中得到执行。</p><p>&emsp;&emsp;uv__work_submit函数的实现是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop,struct uv__work* w,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">enum</span> uv__work_kind kind, <span class="keyword">void</span> (*work)(struct uv__work* w),</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> (*done)(struct uv__work* w, <span class="keyword">int</span> status))</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  w-&gt;loop = loop;</span><br><span class="line">  w-&gt;work = work;</span><br><span class="line">  w-&gt;done = done;</span><br><span class="line">  post(&amp;w-&gt;wq, kind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv_once(&amp;once, init_once);是初始化多个线程，我在<a href="https://lurenaa.github.io/2019/11/18/libuv3/" target="_blank" rel="noopener">我的第三篇文章</a>中有介绍。不过当时对于子线程运行的worker函数没有提及，work函数大概是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_mutex_lock(&amp;mutex);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">while</span> (QUEUE_EMPTY(&amp;wq)...) &#123;</span><br><span class="line">      idle_threads += <span class="number">1</span>;</span><br><span class="line">      uv_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">      idle_threads -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q = QUEUE_HEAD(&amp;wq);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);  </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, struct uv__work, wq);</span><br><span class="line">    w-&gt;work(w);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line">    w-&gt;work = <span class="literal">NULL</span>;  </span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br><span class="line">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br><span class="line">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br><span class="line"></span><br><span class="line">    uv_mutex_lock(&amp;mutex);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我去掉了对于slow_io的处理，大致是这样一个过程。</p><p>&emsp;&emsp;一开始线程会卡在uv_cond_wait这里，直到被uv_cond_signal唤醒，如果唤醒时wq队列中有任务，它就会执行任务，w-&gt;work(w)也就是调用uv__fs_work。然后把w放入loop-&gt;wq（为了uv__fs_done的执行）。</p><p>&emsp;&emsp;uv_async_send调用让loop-&gt;wq_async可读，主线程就从uv_run中的uv__io_poll的epoll_pwait中醒来，wq_async的回调函数会遍历loop-&gt;wq执行w-&gt;done。（<a href="https://lurenaa.github.io/2019/11/25/libuv4/" target="_blank" rel="noopener">我的第四篇文章</a>有讲这一部分的详细内容）</p><h4 id="谁来触发uv-cond-signal唤醒子线程呢？"><a href="#谁来触发uv-cond-signal唤醒子线程呢？" class="headerlink" title="谁来触发uv_cond_signal唤醒子线程呢？"></a>谁来触发uv_cond_signal唤醒子线程呢？</h4><p>🥣uv__work_submit中的post函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uv_mutex_lock(&amp;mutex);</span><br><span class="line">...</span><br><span class="line">QUEUE_INSERT_TAIL(&amp;wq, q);</span><br><span class="line"><span class="keyword">if</span> (idle_threads &gt; <span class="number">0</span>)</span><br><span class="line">  uv_cond_signal(&amp;cond);</span><br><span class="line">uv_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我再次省略了slow_io的部分，因为它们只是特殊处理。</p><p>&emsp;&emsp;该函数有空闲的线程就唤醒，不然就阻塞该线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（4）async</title>
      <link href="/2019/11/25/libuv4/"/>
      <url>/2019/11/25/libuv4/</url>
      
        <content type="html"><![CDATA[<h4 id="uv-async-init"><a href="#uv-async-init" class="headerlink" title="uv_async_init"></a>uv_async_init</h4><p>&emsp;&emsp;libuv中async的开端在uv_loop_init函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面省略</span></span><br><span class="line">err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">goto</span> fail_async_init;</span><br><span class="line"></span><br><span class="line">uv__handle_unref(&amp;loop-&gt;wq_async);</span><br><span class="line">loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;</span><br><span class="line"><span class="comment">//后面省略</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;wq_async是个uv_async_t类型，它用于线程work函数调用最后处理loop-&gt;wq中的回调，暂时不用管,我在<a href="https://lurenaa.github.io/2019/11/26/libuv5/" target="_blank" rel="noopener">我的第五篇文章</a>会讲到它的用途。<br/><br>&emsp;&emsp;我们来看uv_async_init内部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">err = uv__async_start(loop);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_ASYNC);</span><br><span class="line">handle-&gt;async_cb = async_cb;</span><br><span class="line">handle-&gt;pending = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;<span class="built_in">queue</span>);</span><br><span class="line">uv__handle_start(handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第五行以后的操作就是初始化基类uv_handle_t以及子类uv_async_t，然后将这个handle放入loop-&gt;queue(放uv_handle_t的队列)以及放入loop-&gt;async_handles（放uv_async_t的队列）中，然后uv__handle_start中将loop-&gt;active_handles加一。<br/><br>&emsp;&emsp;总而言之，第五行以后的内容就是初始化uv_async_t，可以理解成<strong>uv_async_t的构造函数</strong>。<br/><br>&emsp;&emsp;uv__async_start则不一样，它是初始化函数，它<strong>只会调用一次</strong>（一般情况是在uv_loop_init中调用），我们先看下它的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__async_start</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;async_io_watcher.fd != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err = uv__async_eventfd();</span><br><span class="line">  <span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    pipefd[<span class="number">0</span>] = err;</span><br><span class="line">    pipefd[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//中间省略</span></span><br><span class="line"></span><br><span class="line">  uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[<span class="number">0</span>]);</span><br><span class="line">  uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN);</span><br><span class="line">  loop-&gt;async_wfd = pipefd[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看第三行loop-&gt;async_io_watcher.fd，当你调用过一次这个函数后，loop-&gt;async_io_watcher.fd不会等于-1，以后你初始化uv_async_t类型变量，调用uv_async_init函数时，uv__async_start都是直接返回的。<br><br>&emsp;&emsp;我省略掉了中间如果eventfd没有在当前系统下实现时的兼容性处理。总的来说，就是<strong>初始化loop-&gt;async_io_watcher</strong>。uv__io_t是为epoll设计的结构体。<del>这里你肯定感觉很懵逼，请坚持一下，最后我会梳理一下总体的整个过程。</del><br><br>&emsp;&emsp;uv__io_t的实现是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uv__io_t</span>&#123;</span><br><span class="line">  uv__io_cb cb;  <span class="comment">//回调函数 </span></span><br><span class="line">  <span class="keyword">void</span>* watcher_queue[<span class="number">2</span>]; <span class="comment">//放入loop-&gt;watcher_queue</span></span><br><span class="line">  <span class="keyword">void</span>* pending_queue[<span class="number">2</span>]; <span class="comment">//同理</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pevents; <span class="comment">/* Pending event mask i.e. mask at next tick. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> events;  <span class="comment">/* Current event mask. */</span></span><br><span class="line">  <span class="keyword">int</span> fd;  <span class="comment">//文件描述符，用于epoll注册</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里uv__io_init函数是初始化loop-&gt;async_io_watcher这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QUEUE_INIT(&amp;w-&gt;pending_queue);</span><br><span class="line">QUEUE_INIT(&amp;w-&gt;watcher_queue);</span><br><span class="line">w-&gt;cb = cb;</span><br><span class="line">w-&gt;fd = fd; <span class="comment">//前面我们的eventfd</span></span><br><span class="line">w-&gt;events = <span class="number">0</span>;</span><br><span class="line">w-&gt;pevents = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__io_start将loop-&gt;async_io_watcher放入loop-&gt;watcher_queue。还有对于loop-&gt;nfds大小的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (QUEUE_EMPTY(&amp;w-&gt;watcher_queue))</span><br><span class="line">  QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (loop-&gt;watchers[w-&gt;fd] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  loop-&gt;watchers[w-&gt;fd] = w;</span><br><span class="line">  loop-&gt;nfds++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第四行以后的操作是为了在epoll后，我们得到struct event结构体，我们从event-&gt;data.fd可以得到fd，那<strong>我们如何获取到对应的uv__io_t呢？</strong> 就是通过loop-&gt;watchers这个数组。</p><h4 id="uv-async-send"><a href="#uv-async-send" class="headerlink" title="uv_async_send"></a>uv_async_send</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_async_send</span><span class="params">(<span class="keyword">uv_async_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Do a cheap read first. */</span></span><br><span class="line">  <span class="keyword">if</span> (ACCESS_ONCE(<span class="keyword">int</span>, handle-&gt;pending) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the other thread we're busy with the handle. */</span></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wake up the other thread's event loop. */</span></span><br><span class="line">  uv__async_send(handle-&gt;loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell the other thread we're done. */</span></span><br><span class="line">  <span class="keyword">if</span> (cmpxchgi(&amp;handle-&gt;pending, <span class="number">1</span>, <span class="number">2</span>) != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ACCESS_ONCE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCESS_ONCE(type, var)  \</span></span><br><span class="line">  (*(<span class="keyword">volatile</span> type*) &amp;(var))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里调用一次ACCESS_ONCE，是为了告诉编译器，handle-&gt;pending可能被其他线程修改，所以别给我乱优化。<br><br>&emsp;&emsp;cmpxchgi是原子操作compare_and_change。pending的有三个取值0，1，2。0代表闲置、1代表忙（比如uv_async_send调用途中）、2代表完成。loop-&gt;async_io_watcher调用uv__async_io时，会遍历loop-&gt;async_handles，通过pending来判断哪些回调该被执行。<br><br>&emsp;&emsp;uv__async_send就是向loop-&gt;async_io_watcher.fd（eventfd）写（这里关系到eventfd的机制，不懂可以man eventfd）。</p><h4 id="整体调用过程"><a href="#整体调用过程" class="headerlink" title="整体调用过程"></a>整体调用过程</h4><p>&emsp;&emsp;这里总体归纳一下async的过程。<br><br>&emsp;&emsp;1.在loop_uv_init中初始化async_io_watcher，它的fd为eventfd，值为0，不可读。<br><br>&emsp;&emsp;2.用户uv_async_init注册uv_async_t变量，被添加到loop-&gt;async_handles，设置回调函数。<br><br>&emsp;&emsp;3.如果对uv_async_t变量调用uv_async_send，那么uv_async_t变量的pending变为2（done），并且向eventfd写，loop-&gt;async_io_watcher可读了。<br><br>&emsp;&emsp;4.在uv_run的uv__io_poll中，每次都会把loop-&gt;watchers注册到epoll中，<strong>第四步这个过程在每次事件循环中都在执行</strong>。如果async_io_watcher的fd不可读，就没它事儿。如果可读，async_io_watcher的回调函数uv__async_io执行，它遍历loop-&gt;async_handles，将其中pending为2的uv_async_t变量移除队列，并执行其回调函数。</p><h4 id="看源码后写的小DEMO：-https-github-com-LurenAA-simple-imitation-of-libuv"><a href="#看源码后写的小DEMO：-https-github-com-LurenAA-simple-imitation-of-libuv" class="headerlink" title="看源码后写的小DEMO： https://github.com/LurenAA/simple_imitation_of_libuv"></a>看源码后写的小DEMO： <a href="https://github.com/LurenAA/simple_imitation_of_libuv" target="_blank" rel="noopener">https://github.com/LurenAA/simple_imitation_of_libuv</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh: connect to host github.com port 22: Connection refused</title>
      <link href="/2019/11/24/problems1/"/>
      <url>/2019/11/24/problems1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> </span><br><span class="line">vim .ssh/config</span><br></pre></td></tr></table></figure><p>你会发现这是一个新文件，在其中添加以下文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 你的用户名（例如97860xx@qq.com）</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>然后保存退出（代码如下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接下来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现下面的画面：<br><img src="../assets/ssh-connect.PNG" alt=""><br>在图片倒数第五行的地方会询问是否建立连接，输入yes即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（3）init_threads</title>
      <link href="/2019/11/18/libuv3/"/>
      <url>/2019/11/18/libuv3/</url>
      
        <content type="html"><![CDATA[<h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>&emsp;&emsp;在我们第一次提交io操作时，会有uv_once被调用，来检测是否初始化过线程池，如果没有则立刻<strong>初始化线程池</strong>。所以说线程池并非一开始在uv_run的时候或者在loop中初始化的，而是在io操作开始前。<br><strong>我以uv_open为例子画一下UML图如下：</strong><br><img src="https://img-blog.csdnimg.cn/20191118023241696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在uv_open中先初始化req，然后准备提交work，提交前会调用uv_once检测是否初始化线程池，没有则初始化。</p><h4 id="init-once"><a href="#init-once" class="headerlink" title="init_once"></a>init_once</h4><p>uv_once实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_ONCE_INIT PTHREAD_ONCE_INIT</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uv_once_t</span> once = UV_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="comment">/* Re-initialize the threadpool after fork.</span></span><br><span class="line"><span class="comment">   * Note that this discards the global mutex and condition as well</span></span><br><span class="line"><span class="comment">   * as the work queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_atfork(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;reset_once))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  init_threads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在uv__work_submit中uv_once是这样被调用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分可以参看TLPI 31.2部分，libuv多做了pthread_atfork的处理。<br>&emsp;&emsp;pthread_atfork注册reset_once函数，在fork之后重置once，保证在libuv循环中如果你fork了一个进程，如果在那个新的进程中你也启动一个libuv，init_threads()能被调用。</p><h4 id="init-threads"><a href="#init-threads" class="headerlink" title="init_threads"></a>init_threads</h4><h6 id="🐤条件变量"><a href="#🐤条件变量" class="headerlink" title="🐤条件变量"></a>🐤条件变量</h6><p>&emsp;&emsp;libuv初始化<strong>条件变量</strong>时，调用自己的uv_cond_init，这个函数只做了一件事情，就是将<strong>条件变量</strong>的时钟设置为相对时间，这一点是值得我们自己写代码时参考的，相对时间不受系统时间的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_cond_init</span><span class="params">(<span class="keyword">uv_cond_t</span>* cond)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="🥛互斥锁"><a href="#🥛互斥锁" class="headerlink" title="🥛互斥锁"></a>🥛互斥锁</h6><p>&emsp;&emsp;初始化<strong>互斥锁</strong>时，调用uv_mutex_init，在DEBUG时，libuv会将<strong>互斥锁</strong>设置为PTHREAD_MUTEX_ERRORCHECK，这样能自我检测是否为死锁，不过这会消耗性能，所以在运行时设置为默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_mutex_init</span><span class="params">(<span class="keyword">uv_mutex_t</span>* mutex)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK)</span></span><br><span class="line">  <span class="keyword">return</span> UV__ERR(pthread_mutex_init(mutex, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PTHREAD_MUTEX_ERRORCHECK<br>This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error.</p></blockquote><h6 id="🥡信号量"><a href="#🥡信号量" class="headerlink" title="🥡信号量"></a>🥡信号量</h6><p>&emsp;&emsp;初始化每个线程时，libuv用<strong>信号量</strong>来保证init_threads函数在初始化完所有线程后退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br></pre></td></tr></table></figure><p>在linux下并且glibc版本大于2.21时，uv_sem_init(&amp;sem, 0)和sem_init(&amp;sem, 0)是一样的，没有额外的处理。<br>线程创建好后，在worker函数中会调用uv_sem_post释放<strong>信号量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="🥚uv-thread-create"><a href="#🥚uv-thread-create" class="headerlink" title="🥚uv_thread_create"></a>🥚uv_thread_create</h6><p>&emsp;&emsp;uv_thread_create做的事情就是<strong>设置线程的stack大小</strong>，然后创建它。<br><img src="https://img-blog.csdnimg.cn/20191118025701932.png" alt="在这里插入图片描述"><br>thread_stack_size函数获取栈大小，有一些是跨平台兼容性的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize(); 和</span><br><span class="line"><span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br></pre></td></tr></table></figure><p>上面两行的限制是来源于pthread_attr_setstacksize函数，一下是pthread_attr_setstacksize函数man手册的一部分。</p><blockquote><p>ERRORS<br>       pthread_attr_setstacksize() can fail with the following error:<br>EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.<br> On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of<br>       the system page size.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">thread_stack_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_STACK, &amp;lim))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lim.rlim_cur != RLIM_INFINITY) &#123;</span><br><span class="line">    <span class="comment">/* pthread_attr_setstacksize() expects page-aligned values. */</span></span><br><span class="line">    lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is</span></span><br><span class="line"><span class="comment">     * too small to safely receive signals on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has</span></span><br><span class="line"><span class="comment">     * the largest MINSIGSTKSZ of the architectures that musl supports) so</span></span><br><span class="line"><span class="comment">     * let's use that as a lower bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ</span></span><br><span class="line"><span class="comment">     * is between 28 and 133 KB when compiling against glibc, depending</span></span><br><span class="line"><span class="comment">     * on the architecture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (lim.rlim_cur &gt;= <span class="number">8192</span>)</span><br><span class="line">      <span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; <span class="number">20</span>;  <span class="comment">/* glibc default. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>😂无趣的是在linux Ubuntus我的环境下测试时，attr的默认stacksize和thread_stack_size函数设置到的是一样的值。下面是我的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_page() &#123;</span><br><span class="line">  rlimit x;</span><br><span class="line">  assert(getrlimit(RLIMIT_STACK, &amp;x) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size = x.rlim_cur - x.rlim_cur % getpagesize();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(stack_size &gt; PTHREAD_STACK_MIN) </span><br><span class="line">    <span class="keyword">return</span> stack_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  assert(pthread_attr_init(&amp;attr) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size;</span><br><span class="line">  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  stack_size = stack_page();</span><br><span class="line">  pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  <span class="keyword">pthread_t</span> p1;</span><br><span class="line">  pthread_create(&amp;p1, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))a, <span class="literal">nullptr</span>);</span><br><span class="line">  pthread_attr_destroy(&amp;attr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（2）uv__loop_alive</title>
      <link href="/2019/11/16/libuv2/"/>
      <url>/2019/11/16/libuv2/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>&emsp;&emsp;上一篇说了一下整体的事件循环，对于UV_RUN_DEFAULT模式来调用uv_run来说，uv__loop_alive就决定了是否退出，这一篇看一下uv__loop_alive的源码。</p><h5 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见loop的状态取决于三个方面：handles、reqs、closing_handles </p><h5 id="handles"><a href="#handles" class="headerlink" title="handles"></a>handles</h5><p>&emsp;&emsp;uv__has_active_handles就是检查loop-&gt;active_handles值是否大于0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_handles(loop)                                          \</span></span><br><span class="line">  ((loop)-&gt;active_handles &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_loop_s</span> <span class="title">uv_loop_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_handle_s</span> <span class="title">uv_handle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_dir_s</span> <span class="title">uv_dir_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> <span class="title">uv_async_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_process_s</span> <span class="title">uv_process_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_event_s</span> <span class="title">uv_fs_event_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_poll_s</span> <span class="title">uv_fs_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_signal_s</span> <span class="title">uv_signal_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;handles列表如上。handle在调用时，会包含一个函数的调用，就是<br>uv__handle_start。下图所示，是哪些函数调用了uv__handle_start。<del>有一些handle不在其中，可能与其调用方式有关，我暂时无法解释</del><br><img src="https://img-blog.csdnimg.cn/20191116181231294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != <span class="number">0</span>) <span class="keyword">break</span>;                          \</span><br><span class="line">    (h)-&gt;flags |= UV_HANDLE_ACTIVE;                                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_REF) != <span class="number">0</span>) uv__active_handle_add(h);          \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__handle_start函数在调用时，会调用uv__active_handle_add，uv__active_handle_add就是将loop-&gt;active_handles++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_add(h)                                              \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相应的在handle结束时有uv__active_handle_rm的调用，(h)-&gt;loop-&gt;active_handles减一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_rm(h)                                               \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="req"><a href="#req" class="headerlink" title="req"></a>req</h5><p>&emsp;&emsp;uv__has_active_reqs和handle的道理一样，是检测(loop)-&gt;active_reqs.count &gt; 0。active_reqs是个共用体，它的另一个用途暂时我还不知道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_reqs(loop)                                             \</span></span><br><span class="line">  ((loop)-&gt;active_reqs.count &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_req_s</span> <span class="title">uv_req_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getaddrinfo_s</span> <span class="title">uv_getaddrinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getnameinfo_s</span> <span class="title">uv_getnameinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_shutdown_s</span> <span class="title">uv_shutdown_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_write_s</span> <span class="title">uv_write_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_connect_s</span> <span class="title">uv_connect_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_send_s</span> <span class="title">uv_udp_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_s</span> <span class="title">uv_fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_work_s</span> <span class="title">uv_work_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__req_register(loop, req)等同于handle的uv__active_handle_add。uv__req_register在uv__req_init中调用，几乎（<del>漏网的暂时没法解释</del> ）每个req在初始化时都调用了uv__req_init。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_init(loop, req, typ)                                          \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    UV_REQ_INIT(req, typ);                                                    \</span><br><span class="line">    uv__req_register(loop, req);                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_register(loop, req)                                           \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图所示是那些函数调用了uv__req_init，由名称我们可以看出来它们是属于哪些req的。<br><img src="https://img-blog.csdnimg.cn/20191116181900253.png" alt="在这里插入图片描述"><br>&emsp;&emsp;同理，还有uv__req_unregister。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_unregister(loop, req)                                         \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(uv__has_active_reqs(loop));                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="closing-handles"><a href="#closing-handles" class="headerlink" title="closing_handles"></a>closing_handles</h5><p>&emsp;&emsp;要关闭的handle会以链表的形式挂在loop-&gt;closing_handles上。这个操作通过调用uv__make_close_pending来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__make_close_pending</span><span class="params">(<span class="keyword">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class="line">  assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class="line">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class="line">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果closing_handles不为空，那么还需要进入事件循环，去调用关闭的handle的回调函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（1）事件循环分析</title>
      <link href="/2019/11/16/libuv1/"/>
      <url>/2019/11/16/libuv1/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>&emsp;&emsp;libuv总是报出一些让人难以理解的错误😂，作为一个C的项目，不具有Java、JavaScript、php那样的人气，很难百度到一些问题的答案，甚至google也不行。为了用好libuv，也为了学习吧。我开始看libuv的源码，不知道自己能走多远。。。</p></blockquote><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><img src="https://img-blog.csdnimg.cn/20191116165040610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" width="400" height="500" alt="Event Loop" align=center><p>这是官方事件循环的示意图。<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">链接-&gt;官方图片位置</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;整个事件循环就是在主线程的uv_run（）调用中执行的。我就跟着官方的介绍一步一步来看（<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方介绍</a>）。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><blockquote><p>The loop concept of ‘now’ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls.</p></blockquote><p>&emsp;&emsp;第一步是更新时间。对应代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__update_time(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结来说就是调用这个函数，更新时间。<del>uv__update_time实现我下一篇来介绍</del> </p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><blockquote><p>If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and ref’d handles, active requests or closing handles it’s considered to be alive.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用uv__loop_alive函数获取loop状态。<br>&emsp;&emsp;如果uv__loop_alive返回零或者loop-&gt;stop_flag == 1说明loop终止，直接跳过循环，到代码最下面（<del>这里有一些性能的处理暂时不管</del> ），退出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;stop_flag == 0的一个来源是调用了uv_stop，这个函数在手册中看见。它的源代码也很清晰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv_stop</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  loop-&gt;stop_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果loop状态OK，那么就进入循环中。</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><blockquote><p>Due timers are run. All active timers scheduled for a time before the loop’s concept of now get their callbacks called.</p></blockquote><p>&emsp;&emsp;对应代码这一部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uv__run_timers(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min(timer_heap(loop));</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将堆里面已经超时的拿出来运行。</p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><blockquote><p>Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point.</p></blockquote><p>对应：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ran_pending = uv__run_pending(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将loop-&gt;pending_queue中的任务拿出来运行。</p><h5 id="第五、六、九步"><a href="#第五、六、九步" class="headerlink" title="第五、六、九步"></a>第五、六、九步</h5><blockquote><p>5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active</p></blockquote><blockquote><p> 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O.</p></blockquote><blockquote><p>9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv__run_idle(loop);</span><br><span class="line">uv__run_prepare(loop);</span><br><span class="line">uv__run_check(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三部为什么要一起说呢？因为它们的实质是一样的。在每次循环固定的位置调用。<br>&emsp;&emsp;这三个函数定义在loop-watcher.c这个文件里面，它们是用宏定义定义的。只改了idle、prepare、check这三个名字的部分，其余部分函数都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the "Software"), to</span></span><br><span class="line"><span class="comment"> * deal in the Software without restriction, including without limitation the</span></span><br><span class="line"><span class="comment"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></span><br><span class="line"><span class="comment"> * sell copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"> * all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></span><br><span class="line"><span class="comment"> * IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"internal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \</span></span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123;              \</span></span><br><span class="line">    uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_##type);                   \</span><br><span class="line">    handle-&gt;name##_cb = <span class="literal">NULL</span>;                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line">    <span class="keyword">if</span> (uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                      \</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) <span class="keyword">return</span> UV_EINVAL;                                         \</span><br><span class="line">    QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;<span class="built_in">queue</span>);         \</span><br><span class="line">    handle-&gt;name##_cb = cb;                                                   \</span><br><span class="line">    uv__handle_start(handle);                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line">    <span class="keyword">if</span> (!uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                     \</span><br><span class="line">    QUEUE_REMOVE(&amp;handle-&gt;<span class="built_in">queue</span>);                                             \</span><br><span class="line">    uv__handle_stop(handle);                                                  \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__run_#<span class="meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">    uv_#<span class="meta">#name##_t* h;                                                         \</span></span><br><span class="line">    QUEUE <span class="built_in">queue</span>;                                                              \</span><br><span class="line">    QUEUE* q;                                                                 \</span><br><span class="line">    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="built_in">queue</span>);                                \</span><br><span class="line">    <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;                                            \</span><br><span class="line">      q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);                                                 \</span><br><span class="line">      h = QUEUE_DATA(q, uv_##name##<span class="keyword">_t</span>, <span class="built_in">queue</span>);                                \</span><br><span class="line">      QUEUE_REMOVE(q);                                                        \</span><br><span class="line">      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">      h-&gt;name##_cb(h);                                                        \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__#<span class="meta">#name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line">    uv_#<span class="meta">#name##_stop(handle);                                                 \</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(check, CHECK)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(idle, IDLE)</span><br></pre></td></tr></table></figure><h5 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h5><blockquote><p>Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:<br>If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.<br>If the loop is going to be stopped (uv_stop() was called), the timeout is 0.<br>If there are no active handles or requests, the timeout is 0.<br>If there are any idle handles active, the timeout is 0.<br>If there are any handles pending to be closed, the timeout is 0.<br>If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这部分是取决于uv_run的模式的特殊处理，暂时不细看。</p><h5 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h5><blockquote><p>The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__io_poll(loop, timeout);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分对于不同操作系统有所不同，linux是poll，mac是kqueue。</p><h5 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h5><blockquote><p>Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__run_closing_handles(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用各类的close回调函数。</p><h5 id="第十一、十二步"><a href="#第十一、十二步" class="headerlink" title="第十一、十二步"></a>第十一、十二步</h5><blockquote><p>11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.<br>12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if it’s still alive, otherwise it will also end.</p></blockquote><p>&emsp;&emsp;对于uv_run不同模式的一点特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;宏观上梳理一下整个事件循环的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(2.5)</title>
      <link href="/2019/08/14/rax3/"/>
      <url>/2019/08/14/rax3/</url>
      
        <content type="html"><![CDATA[<h5 id="点点废话"><a href="#点点废话" class="headerlink" title="点点废话"></a>点点废话</h5><p>&emsp;&emsp;最近没有再将rax的源码往下看，rax对于一个新手来说还是体量过大，在尝试自己写写，在写的时候遇到了一些坑，也体会到了rax的一些写法的精妙之处，记录一下。</p><hr><h5 id="宏定义函数的注意点："><a href="#宏定义函数的注意点：" class="headerlink" title="宏定义函数的注意点："></a>宏定义函数的注意点：</h5><p>&emsp;&emsp;我定义了这样一个宏定义函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define radixNthChild(h, n) \</span><br><span class="line">  (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*))</span><br></pre></td></tr></table></figure><p>我这样调用这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radixNthChild(new_cur, new_cur-&gt;size - 1)</span><br></pre></td></tr></table></figure><p>这样一个调用大家觉得有问题吗？嗯，肯定是有问题的，不然我说啥?。</p><p>这里，按照我们一般的调用函数的思路，这样一个调用的运行过程是这样的：</p><ol><li>计算出new_cur-&gt;size - 1</li><li>带入radixNthChild函数</li></ol><p>实际上恰恰相反，<strong>宏定义的处理在预编译时（g++ -E）</strong>，宏定义是将对于的定义替换掉，所以在<br>预编译后的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 363 &quot;radix_tree.c&quot;</span><br><span class="line">    memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*));</span><br></pre></td></tr></table></figure><p>可以看到是 ： + new_cur-&gt;size - 1 * sizeof(void<em>)<br>而不是我所想的： + （new_cur-&gt;size - 1） * sizeof(void</em>)</p><p><strong>可以得出其过程其实是：</strong></p><ol><li>函数宏定义替换</li><li>运行时计算</li></ol><p> <strong>结论： 在宏定义函数调用时注意括号的问题</strong>，不加括号可能会<del>由于运算符优先级而</del> 导致表达式意义与我们想的有出入?</p><hr><h5 id="地址运算注意点"><a href="#地址运算注意点" class="headerlink" title="地址运算注意点"></a>地址运算注意点</h5><p>先给出这样一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct test &#123;</span><br><span class="line">void* a, *b, *c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>int main(void) {cout &lt;&lt; sizeof(test) &lt;&lt; endl;test* p = new test;fprintf(stdout, &quot;%p:%p:%p:%p\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1);return 0;}</code></pre><p>&emsp;&emsp;在这样一个测试代码中，大家觉得p + 1, (char<em>)p + 1, (int</em>)p+1这三个结果，相对于p的数值相差多少呢？<br><img src="https://img-blog.csdnimg.cn/20190814211800282.png" alt="在这里插入图片描述"><br>&emsp;&emsp;运行结果是这样的。类型与地址的运算是有着密切关系的。</p><ul><li>p + 1是一个默认情况， 这时1的意义是一个p的地址宽度</li><li>(char*)p + 1，p被解释为char类型指针，指向的地址被解释为char，于是1就是一个char的地址宽度。</li></ul><p><strong>总结：</strong> 在计算地址时，要注意运算符左边值的类型。你加上的1可能并不是一个字节的大小。</p><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(2)</title>
      <link href="/2019/08/12/rax2/"/>
      <url>/2019/08/12/rax2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天我想要说的是rax中的padding这个函数，我查了很多的资料，大家的博客都告诉我们内存对齐提高性能，却没有去分析为什么，是有根据让作者选择这样做？如果只是这样简单的放过，总感觉让人有一丝的遗憾。</p></blockquote><hr><p>&emsp;&emsp;<br><strong>先把主角拉出来：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define raxPadding(nodesize) </span><br><span class="line">((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先要说的是raxPadding的作用是：让raxNewNode申请的内存nodesize是8的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">raxNode *raxNewNode(size_t children, int datafield) &#123;</span><br><span class="line">    size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+</span><br><span class="line">                      sizeof(raxNode*)*children;</span><br><span class="line">    if (datafield) nodesize += sizeof(void*);</span><br><span class="line">    raxNode *node = rax_malloc(nodesize);</span><br><span class="line">    if (node == NULL) return NULL;</span><br><span class="line">    node-&gt;iskey = 0;</span><br><span class="line">    node-&gt;isnull = 0;</span><br><span class="line">    node-&gt;iscompr = 0;</span><br><span class="line">    node-&gt;size = children;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第一个问题：对齐的优势"><a href="#第一个问题：对齐的优势" class="headerlink" title="第一个问题：对齐的优势"></a>第一个问题：对齐的优势</h6><p>&emsp;&emsp;这个并不是我想说的重点，这里是大家都谈到的，也就是<strong>经过内存对齐之后，CPU的内存访问速度大大提升</strong>。对于我来说，这个结论感觉还是太模糊，这是一个定性的结论，具体的底层细节对于我们初学者来说倒是没必要去深究。</p><h6 id="第二个问题：为什么要这么去做？"><a href="#第二个问题：为什么要这么去做？" class="headerlink" title="第二个问题：为什么要这么去做？"></a>第二个问题：为什么要这么去做？</h6><p>&emsp;&emsp;rax的作者这样的做法其实是<strong>参考结构体的做法</strong>。<br><strong>举个例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct X</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line">    int c;</span><br><span class="line">    double b;</span><br><span class="line">&#125;S2;</span><br></pre></td></tr></table></figure><p>这样一个结构体，它的大小是多少？答案是16。<br>在c语言的内部，做了这样的内存对齐处理：<br><img src="https://img-blog.csdnimg.cn/20190812190523897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>这里转载了<a href="https://www.cnblogs.com/zhoujiayi/p/7872262.html" target="_blank" rel="noopener">这篇文章</a>中的很多资源，大家也可以去看看这篇文章，写的很不错。也有更多例子。</p></blockquote><h5 id="回到rax上来"><a href="#回到rax上来" class="headerlink" title="回到rax上来"></a>回到rax上来</h5><p>&emsp;&emsp; 在rax的raxNode这个结构体中，<del>因为使用了<strong>柔性数组</strong>，所以在c语言本身是无法帮助我们实现像上面一样的内存对齐的（sizeof(raxNode) == 4,我们申请的内存大小决定了柔性数组的长度，详情请百度柔性数组）</del> ，c语言对于结构体的优化没有包含柔性数组这个部分，所以<strong>我们必须自己来接管这一部分的内存对齐，保证程序的运行效率。</strong></p><pre><code>typedef struct raxNode {uint32_t iskey:1;     /* Does this node contain a key? */uint32_t isnull:1;    /* Associated value is NULL (don&apos;t store it). */uint32_t iscompr:1;   /* Node is compressed. */uint32_t size:29;     /* Number of children, or compressed string len. */unsigned char data[];} raxNode;</code></pre><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基数树rax源码分析(1)</title>
      <link href="/2019/08/12/rax1/"/>
      <url>/2019/08/12/rax1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;最近想用libuv写个http服务器，看到了这个开源项目<a href="https://github.com/haywire/haywire" target="_blank" rel="noopener">haywire</a>，在看到第39次提交的时候，作者用基数树来存储不同路由的controller，不过在后续版本中改为了使用hash，不过想来不如正好学学基数树，作者使用的基数树是这个版本<a href="https://github.com/j0sh/radixtree" target="_blank" rel="noopener">radix_tree</a>，这个版本缺少注释，且和一般思路不一样的使用的是二叉树而非N叉树，为了理解方便，我选择了注释较多的<a href="https://github.com/antirez/rax" target="_blank" rel="noopener">rax</a></p></blockquote><hr><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>&emsp;&emsp;首先要提到的是rax的数据结构设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct raxNode &#123;</span><br><span class="line">    uint32_t iskey:1;     /* Does this node contain a key? */</span><br><span class="line">    uint32_t isnull:1;    /* Associated value is NULL (don&apos;t store it). */</span><br><span class="line">    uint32_t iscompr:1;   /* Node is compressed. */</span><br><span class="line">    uint32_t size:29;     /</span><br><span class="line">    unsigned char data[];</span><br><span class="line">&#125; raxNode;</span><br></pre></td></tr></table></figure><p>这里第一个要说到的点是：你觉得这样一个数据结构的大小是多少？24？ 16？ 还是8？<br><img src="https://img-blog.csdnimg.cn/20190811233343948.png" alt="在这里插入图片描述"><br>&emsp;&emsp;<strong>第一个原因</strong>是位域，也就是结构体中的<strong>冒号：</strong>  ，冒号在这里声明实际需要使用的位数，iskey，isnull，iscompr，size四个一共加起来32位，占4个字节。<br>&emsp;&emsp;<strong>第二个原因</strong>是data[]占0个字节。unsigned char data[];这样一个结构在这里并不是理解成一个指针8个字节。而是一个<strong>柔性数组</strong>的概念，实现一个可变长度。data[1]占结构体1个字节，data[2]占结构体2个字节…….data[13]占13个字节。数组类型的内存是结构体中直接分配的，而不是像指针一样需要我们后来分配。如下图可见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct raxNode &#123;</span><br><span class="line">    unsigned char data[13];</span><br><span class="line">&#125; raxNode;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, sizeof(raxNode));</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812000143659.png" alt="在这里插入图片描述"></p><hr><h5 id="data"><a href="#data" class="headerlink" title="data[]"></a>data[]</h5><p>&emsp;&emsp;接下来我们还是要谈data，在这里data的意义并不是一个简单的unsigned char数组，它存储的是键值key和radixNode指针两种变量。<br><img src="https://img-blog.csdnimg.cn/20190812001425256.png" alt="在这里插入图片描述"><br>图来自：<a href="https://my.oschina.net/yunqi/blog/3039132" target="_blank" rel="noopener">https://my.oschina.net/yunqi/blog/3039132</a><br>data的实际使用方式在大多数时候是以<strong>内存地址</strong>的方式进行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define raxNodeLastChildPtr(n) ((raxNode**) ( \</span><br><span class="line">    ((char*)(n)) + \</span><br><span class="line">    raxNodeCurrentLength(n) - \</span><br><span class="line">    sizeof(raxNode*) - \</span><br><span class="line">    (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是访问最后一个节点的函数（也就是访问图中的A-ptr）。n是一个raxNode*指针，对这个指针指向的地址进行＋操作来得到最后一个节点的地址。</p><hr><h5 id="节点的表示"><a href="#节点的表示" class="headerlink" title="节点的表示"></a>节点的表示<img src="https://img-blog.csdnimg.cn/20190812001723801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h5><p>图来自：<a href="https://my.oschina.net/yunqi/blog/3039132" target="_blank" rel="noopener">https://my.oschina.net/yunqi/blog/3039132</a><br>&emsp;&emsp;假设基数树中有“abcd”这个键值的节点。那么它的表示形式是像上图这样的。“abcd”这个节点的value-data存储在图片下半部分的节点处，并且下面一个节点iskey设为1.<br>&emsp;&emsp;<strong>为什么不是直接只有图片的上半部分，由图片上半部分那个节点将iskey设置为1并且将值存储在其value·data中呢？</strong><br>像这样： <strong>[iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr]</strong></p><h4 id="先给出结论：-在rax中一个节点的存在（iskey-1）是由data中对应的子节点来表示的。"><a href="#先给出结论：-在rax中一个节点的存在（iskey-1）是由data中对应的子节点来表示的。" class="headerlink" title="先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。"></a>先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。</h4><p><strong>原因很简单：</strong><br><img src="https://img-blog.csdnimg.cn/20190812002913974.png" alt="在这里插入图片描述"><br>在这个例子里面，这是一个没有压缩的节点，这一层由a和A两个子节点，如果在当前层次表示，如何分辨你指定的是a还是A？所以用引出子节点来表示。</p><blockquote><p>这是我边看rax边实现的一个小练习，欢迎大家指教：<a href="https://github.com/LurenAA/radix_tree" target="_blank" rel="noopener">https://github.com/LurenAA/radix_tree</a> ，好想要个star，求求了，兄弟萌:kissing_heart:</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> rax源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
