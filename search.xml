<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ssh: connect to host github.com port 22: Connection refused</title>
      <link href="/2019/11/24/ssh-connect-to-host-github-com-port-22-Connection-refused/"/>
      <url>/2019/11/24/ssh-connect-to-host-github-com-port-22-Connection-refused/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> </span><br><span class="line">vim .ssh/config</span><br></pre></td></tr></table></figure><p>你会发现这是一个新文件，在其中添加以下文字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 你的用户名（例如97860xx@qq.com）</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><p>然后保存退出（代码如下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure><p>接下来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现下面的画面：<br><img src="../assets/ssh-connect.PNG" alt=""><br>在图片倒数第五行的地方会询问是否建立连接，输入yes即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 遇见的问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（3）init_threads</title>
      <link href="/2019/11/18/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89init_threads/"/>
      <url>/2019/11/18/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89init_threads/</url>
      
        <content type="html"><![CDATA[<h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>&emsp;&emsp;在我们第一次提交io操作时，会有uv_once被调用，来检测是否初始化过线程池，如果没有则立刻<strong>初始化线程池</strong>。所以说线程池并非一开始在uv_run的时候或者在loop中初始化的，而是在io操作开始前。<br><strong>我以uv_open为例子画一下UML图如下：</strong><br><img src="https://img-blog.csdnimg.cn/20191118023241696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在uv_open中先初始化req，然后准备提交work，提交前会调用uv_once检测是否初始化线程池，没有则初始化。</p><h4 id="init-once"><a href="#init-once" class="headerlink" title="init_once"></a>init_once</h4><p>uv_once实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_ONCE_INIT PTHREAD_ONCE_INIT</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uv_once_t</span> once = UV_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="comment">/* Re-initialize the threadpool after fork.</span></span><br><span class="line"><span class="comment">   * Note that this discards the global mutex and condition as well</span></span><br><span class="line"><span class="comment">   * as the work queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_atfork(<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;reset_once))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  init_threads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在uv__work_submit中uv_once是这样被调用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__work_submit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  uv_once(&amp;once, init_once);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分可以参看TLPI 31.2部分，libuv多做了pthread_atfork的处理。<br>&emsp;&emsp;pthread_atfork注册reset_once函数，在fork之后重置once，保证在libuv循环中如果你fork了一个进程，如果在那个新的进程中你也启动一个libuv，init_threads()能被调用。</p><h4 id="init-threads"><a href="#init-threads" class="headerlink" title="init_threads"></a>init_threads</h4><h6 id="🐤条件变量"><a href="#🐤条件变量" class="headerlink" title="🐤条件变量"></a>🐤条件变量</h6><p>&emsp;&emsp;libuv初始化<strong>条件变量</strong>时，调用自己的uv_cond_init，这个函数只做了一件事情，就是将<strong>条件变量</strong>的时钟设置为相对时间，这一点是值得我们自己写代码时参考的，相对时间不受系统时间的影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_cond_init</span><span class="params">(<span class="keyword">uv_cond_t</span>* cond)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="🥛互斥锁"><a href="#🥛互斥锁" class="headerlink" title="🥛互斥锁"></a>🥛互斥锁</h6><p>&emsp;&emsp;初始化<strong>互斥锁</strong>时，调用uv_mutex_init，在DEBUG时，libuv会将<strong>互斥锁</strong>设置为PTHREAD_MUTEX_ERRORCHECK，这样能自我检测是否为死锁，不过这会消耗性能，所以在运行时设置为默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_mutex_init</span><span class="params">(<span class="keyword">uv_mutex_t</span>* mutex)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK)</span></span><br><span class="line">  <span class="keyword">return</span> UV__ERR(pthread_mutex_init(mutex, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PTHREAD_MUTEX_ERRORCHECK<br>This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error.</p></blockquote><h6 id="🥡信号量"><a href="#🥡信号量" class="headerlink" title="🥡信号量"></a>🥡信号量</h6><p>&emsp;&emsp;初始化每个线程时，libuv用<strong>信号量</strong>来保证init_threads函数在初始化完所有线程后退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uv_sem_init(&amp;sem, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    <span class="keyword">if</span> (uv_thread_create(threads + i, worker, &amp;sem))</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">    uv_sem_wait(&amp;sem);</span><br><span class="line"></span><br><span class="line">  uv_sem_destroy(&amp;sem);</span><br></pre></td></tr></table></figure><p>在linux下并且glibc版本大于2.21时，uv_sem_init(&amp;sem, 0)和sem_init(&amp;sem, 0)是一样的，没有额外的处理。<br>线程创建好后，在worker函数中会调用uv_sem_post释放<strong>信号量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  uv_sem_post((<span class="keyword">uv_sem_t</span>*) arg);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="🥚uv-thread-create"><a href="#🥚uv-thread-create" class="headerlink" title="🥚uv_thread_create"></a>🥚uv_thread_create</h6><p>&emsp;&emsp;uv_thread_create做的事情就是<strong>设置线程的stack大小</strong>，然后创建它。<br><img src="https://img-blog.csdnimg.cn/20191118025701932.png" alt="在这里插入图片描述"><br>thread_stack_size函数获取栈大小，有一些是跨平台兼容性的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize(); 和</span><br><span class="line"><span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br></pre></td></tr></table></figure><p>上面两行的限制是来源于pthread_attr_setstacksize函数，一下是pthread_attr_setstacksize函数man手册的一部分。</p><blockquote><p>ERRORS<br>       pthread_attr_setstacksize() can fail with the following error:<br>EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes.<br> On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of<br>       the system page size.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">thread_stack_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__) || defined(__linux__)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">lim</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getrlimit(RLIMIT_STACK, &amp;lim))</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lim.rlim_cur != RLIM_INFINITY) &#123;</span><br><span class="line">    <span class="comment">/* pthread_attr_setstacksize() expects page-aligned values. */</span></span><br><span class="line">    lim.rlim_cur -= lim.rlim_cur % (<span class="keyword">rlim_t</span>) getpagesize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is</span></span><br><span class="line"><span class="comment">     * too small to safely receive signals on.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has</span></span><br><span class="line"><span class="comment">     * the largest MINSIGSTKSZ of the architectures that musl supports) so</span></span><br><span class="line"><span class="comment">     * let's use that as a lower bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ</span></span><br><span class="line"><span class="comment">     * is between 28 and 133 KB when compiling against glibc, depending</span></span><br><span class="line"><span class="comment">     * on the architecture.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (lim.rlim_cur &gt;= <span class="number">8192</span>)</span><br><span class="line">      <span class="keyword">if</span> (lim.rlim_cur &gt;= PTHREAD_STACK_MIN)</span><br><span class="line">        <span class="keyword">return</span> lim.rlim_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; <span class="number">20</span>;  <span class="comment">/* glibc default. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>😂无趣的是在linux Ubuntus我的环境下测试时，attr的默认stacksize和thread_stack_size函数设置到的是一样的值。下面是我的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_page() &#123;</span><br><span class="line">  rlimit x;</span><br><span class="line">  assert(getrlimit(RLIMIT_STACK, &amp;x) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size = x.rlim_cur - x.rlim_cur % getpagesize();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span>(stack_size &gt; PTHREAD_STACK_MIN) </span><br><span class="line">    <span class="keyword">return</span> stack_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  assert(pthread_attr_init(&amp;attr) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">size_t</span> stack_size;</span><br><span class="line">  pthread_attr_getstacksize(&amp;attr, &amp;stack_size);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; stack_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  stack_size = stack_page();</span><br><span class="line">  pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  <span class="keyword">pthread_t</span> p1;</span><br><span class="line">  pthread_create(&amp;p1, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))a, <span class="literal">nullptr</span>);</span><br><span class="line">  pthread_attr_destroy(&amp;attr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（2）uv__loop_alive</title>
      <link href="/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89uv__loop_alive/"/>
      <url>/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89uv__loop_alive/</url>
      
        <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>&emsp;&emsp;上一篇说了一下整体的事件循环，对于UV_RUN_DEFAULT模式来调用uv_run来说，uv__loop_alive就决定了是否退出，这一篇看一下uv__loop_alive的源码。</p><h5 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span><br><span class="line">         uv__has_active_reqs(loop) ||</span><br><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见loop的状态取决于三个方面：handles、reqs、closing_handles </p><h5 id="handles"><a href="#handles" class="headerlink" title="handles"></a>handles</h5><p>&emsp;&emsp;uv__has_active_handles就是检查loop-&gt;active_handles值是否大于0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_handles(loop)                                          \</span></span><br><span class="line">  ((loop)-&gt;active_handles &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_loop_s</span> <span class="title">uv_loop_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_handle_s</span> <span class="title">uv_handle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_dir_s</span> <span class="title">uv_dir_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> <span class="title">uv_async_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_process_s</span> <span class="title">uv_process_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_event_s</span> <span class="title">uv_fs_event_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_poll_s</span> <span class="title">uv_fs_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_signal_s</span> <span class="title">uv_signal_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;handles列表如上。handle在调用时，会包含一个函数的调用，就是<br>uv__handle_start。下图所示，是哪些函数调用了uv__handle_start。<del>有一些handle不在其中，可能与其调用方式有关，我暂时无法解释</del><br><img src="https://img-blog.csdnimg.cn/20191116181231294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__handle_start(h)                                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != <span class="number">0</span>) <span class="keyword">break</span>;                          \</span><br><span class="line">    (h)-&gt;flags |= UV_HANDLE_ACTIVE;                                           \</span><br><span class="line">    <span class="keyword">if</span> (((h)-&gt;flags &amp; UV_HANDLE_REF) != <span class="number">0</span>) uv__active_handle_add(h);          \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__handle_start函数在调用时，会调用uv__active_handle_add，uv__active_handle_add就是将loop-&gt;active_handles++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_add(h)                                              \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;相应的在handle结束时有uv__active_handle_rm的调用，(h)-&gt;loop-&gt;active_handles减一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__active_handle_rm(h)                                               \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (h)-&gt;loop-&gt;active_handles--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="req"><a href="#req" class="headerlink" title="req"></a>req</h5><p>&emsp;&emsp;uv__has_active_reqs和handle的道理一样，是检测(loop)-&gt;active_reqs.count &gt; 0。active_reqs是个共用体，它的另一个用途暂时我还不知道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__has_active_reqs(loop)                                             \</span></span><br><span class="line">  ((loop)-&gt;active_reqs.count &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_req_s</span> <span class="title">uv_req_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getaddrinfo_s</span> <span class="title">uv_getaddrinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getnameinfo_s</span> <span class="title">uv_getnameinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_shutdown_s</span> <span class="title">uv_shutdown_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_write_s</span> <span class="title">uv_write_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_connect_s</span> <span class="title">uv_connect_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_send_s</span> <span class="title">uv_udp_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_s</span> <span class="title">uv_fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_work_s</span> <span class="title">uv_work_t</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;uv__req_register(loop, req)等同于handle的uv__active_handle_add。uv__req_register在uv__req_init中调用，几乎（<del>漏网的暂时没法解释</del> ）每个req在初始化时都调用了uv__req_init。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_init(loop, req, typ)                                          \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    UV_REQ_INIT(req, typ);                                                    \</span><br><span class="line">    uv__req_register(loop, req);                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_register(loop, req)                                           \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count++;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图所示是那些函数调用了uv__req_init，由名称我们可以看出来它们是属于哪些req的。<br><img src="https://img-blog.csdnimg.cn/20191116181900253.png" alt="在这里插入图片描述"><br>&emsp;&emsp;同理，还有uv__req_unregister。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uv__req_unregister(loop, req)                                         \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                        \</span><br><span class="line">    assert(uv__has_active_reqs(loop));                                        \</span><br><span class="line">    (loop)-&gt;active_reqs.count--;                                              \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="closing-handles"><a href="#closing-handles" class="headerlink" title="closing_handles"></a>closing_handles</h5><p>&emsp;&emsp;要关闭的handle会以链表的形式挂在loop-&gt;closing_handles上。这个操作通过调用uv__make_close_pending来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__make_close_pending</span><span class="params">(<span class="keyword">uv_handle_t</span>* handle)</span> </span>&#123;</span><br><span class="line">  assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING);</span><br><span class="line">  assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED));</span><br><span class="line">  handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles;</span><br><span class="line">  handle-&gt;loop-&gt;closing_handles = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果closing_handles不为空，那么还需要进入事件循环，去调用关闭的handle的回调函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libuv源码分析（1）事件循环分析</title>
      <link href="/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90/"/>
      <url>/2019/11/16/libuv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>&emsp;&emsp;libuv总是报出一些让人难以理解的错误😂，作为一个C的项目，不具有Java、JavaScript、php那样的人气，很难百度到一些问题的答案，甚至google也不行。为了用好libuv，也为了学习吧。我开始看libuv的源码，不知道自己能走多远。。。</p></blockquote><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><img src="https://img-blog.csdnimg.cn/20191116165040610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDE1MDQ4,size_16,color_FFFFFF,t_70" width="400" height="500" alt="Event Loop" align=center><p>这是官方事件循环的示意图。<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">链接-&gt;官方图片位置</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;整个事件循环就是在主线程的uv_run（）调用中执行的。我就跟着官方的介绍一步一步来看（<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方介绍</a>）。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><blockquote><p>The loop concept of ‘now’ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls.</p></blockquote><p>&emsp;&emsp;第一步是更新时间。对应代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__update_time(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结来说就是调用这个函数，更新时间。<del>uv__update_time实现我下一篇来介绍</del> </p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><blockquote><p>If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and ref’d handles, active requests or closing handles it’s considered to be alive.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用uv__loop_alive函数获取loop状态。<br>&emsp;&emsp;如果uv__loop_alive返回零或者loop-&gt;stop_flag == 1说明loop终止，直接跳过循环，到代码最下面（<del>这里有一些性能的处理暂时不管</del> ），退出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The if statement lets gcc compile it to a conditional store. Avoids</span></span><br><span class="line"><span class="comment">   * dirtying a cache line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;loop-&gt;stop_flag == 0的一个来源是调用了uv_stop，这个函数在手册中看见。它的源代码也很清晰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv_stop</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  loop-&gt;stop_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果loop状态OK，那么就进入循环中。</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><blockquote><p>Due timers are run. All active timers scheduled for a time before the loop’s concept of now get their callbacks called.</p></blockquote><p>&emsp;&emsp;对应代码这一部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uv__run_timers(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__run_timers</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span><br><span class="line">  <span class="keyword">uv_timer_t</span>* handle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    heap_node = heap_min(timer_heap(loop));</span><br><span class="line">    <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span><br><span class="line">    <span class="keyword">if</span> (handle-&gt;timeout &gt; loop-&gt;time)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    uv_timer_stop(handle);</span><br><span class="line">    uv_timer_again(handle);</span><br><span class="line">    handle-&gt;timer_cb(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将堆里面已经超时的拿出来运行。</p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><blockquote><p>Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point.</p></blockquote><p>对应：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ran_pending = uv__run_pending(loop);</span><br><span class="line">其实现：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span><br><span class="line">  QUEUE* q;</span><br><span class="line">  QUEUE pq;</span><br><span class="line">  <span class="keyword">uv__io_t</span>* w;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;pq);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span><br><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将loop-&gt;pending_queue中的任务拿出来运行。</p><h5 id="第五、六、九步"><a href="#第五、六、九步" class="headerlink" title="第五、六、九步"></a>第五、六、九步</h5><blockquote><p>5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active</p></blockquote><blockquote><p> 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O.</p></blockquote><blockquote><p>9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv__run_idle(loop);</span><br><span class="line">uv__run_prepare(loop);</span><br><span class="line">uv__run_check(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这三部为什么要一起说呢？因为它们的实质是一样的。在每次循环固定的位置调用。<br>&emsp;&emsp;这三个函数定义在loop-watcher.c这个文件里面，它们是用宏定义定义的。只改了idle、prepare、check这三个名字的部分，其余部分函数都是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the "Software"), to</span></span><br><span class="line"><span class="comment"> * deal in the Software without restriction, including without limitation the</span></span><br><span class="line"><span class="comment"> * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></span><br><span class="line"><span class="comment"> * sell copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></span><br><span class="line"><span class="comment"> * all copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></span><br><span class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></span><br><span class="line"><span class="comment"> * IN THE SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"uv.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"internal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UV_LOOP_WATCHER_DEFINE(name, type)                                    \</span></span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123;              \</span></span><br><span class="line">    uv__handle_init(loop, (<span class="keyword">uv_handle_t</span>*)handle, UV_##type);                   \</span><br><span class="line">    handle-&gt;name##_cb = <span class="literal">NULL</span>;                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123;           \</span></span><br><span class="line">    <span class="keyword">if</span> (uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                      \</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>) <span class="keyword">return</span> UV_EINVAL;                                         \</span><br><span class="line">    QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;<span class="built_in">queue</span>);         \</span><br><span class="line">    handle-&gt;name##_cb = cb;                                                   \</span><br><span class="line">    uv__handle_start(handle);                                                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">int</span> uv_#<span class="meta">#name##_stop(uv_##name##_t* handle) &#123;                               \</span></span><br><span class="line">    <span class="keyword">if</span> (!uv__is_active(handle)) <span class="keyword">return</span> <span class="number">0</span>;                                     \</span><br><span class="line">    QUEUE_REMOVE(&amp;handle-&gt;<span class="built_in">queue</span>);                                             \</span><br><span class="line">    uv__handle_stop(handle);                                                  \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                 \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__run_#<span class="meta">#name(uv_loop_t* loop) &#123;                                      \</span></span><br><span class="line">    uv_#<span class="meta">#name##_t* h;                                                         \</span></span><br><span class="line">    QUEUE <span class="built_in">queue</span>;                                                              \</span><br><span class="line">    QUEUE* q;                                                                 \</span><br><span class="line">    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;<span class="built_in">queue</span>);                                \</span><br><span class="line">    <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;<span class="built_in">queue</span>)) &#123;                                            \</span><br><span class="line">      q = QUEUE_HEAD(&amp;<span class="built_in">queue</span>);                                                 \</span><br><span class="line">      h = QUEUE_DATA(q, uv_##name##<span class="keyword">_t</span>, <span class="built_in">queue</span>);                                \</span><br><span class="line">      QUEUE_REMOVE(q);                                                        \</span><br><span class="line">      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);                            \</span><br><span class="line">      h-&gt;name##_cb(h);                                                        \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">                                                                              \</span><br><span class="line">  <span class="keyword">void</span> uv__#<span class="meta">#name##_close(uv_##name##_t* handle) &#123;                            \</span></span><br><span class="line">    uv_#<span class="meta">#name##_stop(handle);                                                 \</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(check, CHECK)</span><br><span class="line">UV_LOOP_WATCHER_DEFINE(idle, IDLE)</span><br></pre></td></tr></table></figure><h5 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h5><blockquote><p>Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:<br>If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.<br>If the loop is going to be stopped (uv_stop() was called), the timeout is 0.<br>If there are no active handles or requests, the timeout is 0.<br>If there are any idle handles active, the timeout is 0.<br>If there are any handles pending to be closed, the timeout is 0.<br>If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这部分是取决于uv_run的模式的特殊处理，暂时不细看。</p><h5 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h5><blockquote><p>The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__io_poll(loop, timeout);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一部分对于不同操作系统有所不同，linux是poll，mac是kqueue。</p><h5 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h5><blockquote><p>Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv__run_closing_handles(loop);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用各类的close回调函数。</p><h5 id="第十一、十二步"><a href="#第十一、十二步" class="headerlink" title="第十一、十二步"></a>第十一、十二步</h5><blockquote><p>11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.<br>12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if it’s still alive, otherwise it will also end.</p></blockquote><p>&emsp;&emsp;对于uv_run不同模式的一点特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      <span class="comment">/* UV_RUN_ONCE implies forward progress: at least one callback must have</span></span><br><span class="line"><span class="comment">       * been invoked when it returns. uv__io_poll() can return without doing</span></span><br><span class="line"><span class="comment">       * I/O (meaning: no callbacks) when its timeout expires - which means we</span></span><br><span class="line"><span class="comment">       * have pending timers that satisfy the forward progress constraint.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from</span></span><br><span class="line"><span class="comment">       * the check.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;宏观上梳理一下整个事件循环的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> libuv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
