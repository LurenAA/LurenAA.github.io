{"meta":{"title":"lurenaaのblog","subtitle":"","description":"","author":"两天宇宙人","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-22T12:56:46.590Z","updated":"2020-01-22T12:56:46.590Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"重庆邮电大学的咸鱼大学生的博客记录，菜到可怜，真的可惜🐔"},{"title":"所有分类","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:51:06.685Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"&emsp;🍅旧CSDN博客"},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:49:21.826Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":"&emsp;🍺smpHttp 一个基于libuv的C++ http库 &emsp;🍻Algorithms 《算法第4版》的C++代码实现"},{"title":"所有标签","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2020-01-22T13:44:19.251Z","updated":"2020-01-22T13:44:19.251Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":"标签分类目录&emsp;🐺算法&emsp;🐶LeetCode&emsp;🐱遇见的问题&emsp;🐭Libuv&emsp;🐹rax源码阅读&emsp;🍠《TCP/IP详解》读书笔记"}],"posts":[{"title":"344.反转字符串","slug":"leetcode344","date":"2020-01-28T15:03:25.000Z","updated":"2020-01-28T15:29:27.404Z","comments":true,"path":"2020/01/28/leetcode344/","link":"","permalink":"http://yoursite.com/2020/01/28/leetcode344/","excerpt":"","text":"🥩递归&emsp;&emsp; 12345678910111213141516class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i = 0, e = s.size() - 1; rs(s, i, e); &#125; void rs(vector&lt;char&gt;&amp; s, int&amp; i, int&amp; e) &#123; if(i &gt;= e) return ; swap(s[i], s[e]); ++i; --e; rs(s, i, e); &#125;&#125;; Accepted 478/478 cases passed (52 ms) Your runtime beats 88.72 % of cpp submissions Your memory usage beats 5.04 % of cpp submissions (20.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"347.前 K 个高频元素","slug":"leetcode347","date":"2020-01-25T13:12:46.000Z","updated":"2020-01-25T13:13:53.358Z","comments":true,"path":"2020/01/25/leetcode347/","link":"","permalink":"http://yoursite.com/2020/01/25/leetcode347/","excerpt":"","text":"🉐查找 and 哈希表12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; count; for(auto x :nums) &#123; count[x] += 1; &#125; using value_t = pair&lt;int, int&gt;; vector&lt;value_t&gt; container(count.begin(), count.end()); auto comp = [](const value_t &amp;v1, const value_t &amp;v2) &#123;return v1.second &lt; v2.second;&#125;; make_heap(container.begin(), container.end(), comp); vector&lt;int&gt; result; for (int i = 0; i &lt; k; ++i) &#123; result.push_back(container.begin()-&gt;first); pop_heap(container.begin(), container.end() - i, comp); &#125; return result; &#125;&#125;; Accepted 21/21 cases passed (24 ms) Your runtime beats 62.88 % of cpp submissions Your memory usage beats 9.89 % of cpp submissions (11.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"454.四数相加 II","slug":"leetcode454","date":"2020-01-25T12:38:36.000Z","updated":"2020-01-25T12:50:29.814Z","comments":true,"path":"2020/01/25/leetcode454/","link":"","permalink":"http://yoursite.com/2020/01/25/leetcode454/","excerpt":"","text":"😂失败1.超出时间12345678910111213141516class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; set&lt;vector&lt;int&gt;&gt; st; for(int a = 0; a &lt; A.size(); ++a) for(int b = 0; b &lt;B.size(); ++b) for(int c = 0; c &lt; C.size(); ++c) for(int d = 0; d &lt; D.size(); ++d) &#123; if(A[a] + B[b] + C[c] + D[d] == 0) &#123; st.insert(&#123;a,b,c,d&#125;); &#125; &#125; return st.size(); &#125;&#125;; 😜分为两组123456789101112131415161718192021222324252627class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; map&lt;int,int&gt; st; int count = 0; int x; for(int a = 0; a &lt; A.size(); ++a) for(int b = 0; b &lt;B.size(); ++b) &#123; x = A[a] + B[b]; if(!st.count(x)) st.insert(&#123;x, 1&#125;); else st[x] += 1; &#125; for(int c = 0; c &lt; C.size(); ++c) for(int d = 0; d &lt; D.size(); ++d) &#123; x = C[c] + D[d]; if(st.count(-x)) &#123; count += st[-x]; &#125; &#125; return count; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"3.无重复字符的最长子串","slug":"leetcode3","date":"2020-01-24T11:59:06.000Z","updated":"2020-01-24T12:00:37.224Z","comments":true,"path":"2020/01/24/leetcode3/","link":"","permalink":"http://yoursite.com/2020/01/24/leetcode3/","excerpt":"","text":"🥛set &emsp;12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; set&lt;char&gt; st; int mx = 0; for(int i = 0; i &lt; s.size();) &#123; if(st.count(s[i]) &gt; 0) &#123; if(st.size()) &#123; st.erase(s[i - st.size()]); &#125; &#125; else &#123; st.insert(s[i]); ++i; &#125; mx = max(mx, (int)st.size()); &#125; return mx; &#125;&#125;; Accepted 987/987 cases passed (48 ms) Your runtime beats 25.3 % of cpp submissions Your memory usage beats 14.41 % of cpp submissions (16 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"771.宝石与石头","slug":"leetcode771","date":"2020-01-24T11:49:56.000Z","updated":"2020-01-25T03:35:48.772Z","comments":true,"path":"2020/01/24/leetcode771/","link":"","permalink":"http://yoursite.com/2020/01/24/leetcode771/","excerpt":"","text":"😂代码实现12345678910111213141516class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; set&lt;char&gt; mp; for(auto x : J) &#123; mp.insert(x); &#125; int tl = 0; for(auto a: S) &#123; if(mp.count(a) &gt; 0) &#123; tl += 1; &#125; &#125; return tl; &#125;&#125;; Accepted 254/254 cases passed (8 ms) Your runtime beats 25.05 % of cpp submissions Your memory usage beats 5.26 % of cpp submissions (8.8 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"652.寻找重复的子树","slug":"leetcode652","date":"2020-01-23T15:39:28.000Z","updated":"2020-01-23T15:50:03.381Z","comments":true,"path":"2020/01/23/leetcode652/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode652/","excerpt":"","text":"😔失败1&emsp;&emsp;不可以重载map的比较函数，因为map的实现是红黑树，用于红黑树排序比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;memory&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std; struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: struct Cmp &#123; bool compr(const TreeNode* lhs, const TreeNode* rhs) const &#123; if (!lhs &amp;&amp; !rhs) return true; if ((!lhs &amp;&amp; rhs) || (lhs &amp;&amp; !rhs)) return false; bool v = lhs-&gt;val == rhs-&gt;val; if (!v) return false; bool v1 = compr(lhs-&gt;left, rhs-&gt;left); if (!v1) return false; bool v2 = compr(lhs-&gt;right, rhs-&gt;right); if (!v2) return false; &#125; bool operator()(const TreeNode* lhs, const TreeNode* rhs) const &#123; return compr(lhs, rhs); &#125; &#125;; vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; map&lt;TreeNode*, int, Cmp&gt; st; vector&lt;TreeNode*&gt; vec; dg(root, st, vec); return vec; &#125; void dg(TreeNode* h, map&lt;TreeNode*, int, Cmp&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec) &#123; if (!h) return; dg(h-&gt;left, st, vec); dg(h-&gt;right, st, vec); size_t ct = st.count(h); if (ct &gt; 0) &#123; if (st.at(h) == 1) &#123; cout &lt;&lt; &quot;i&quot; &lt;&lt; endl; vec.push_back(h); &#125; st.at(h) += 1; cout &lt;&lt; &quot;t&quot; &lt;&lt; endl; &#125; else &#123; st.insert(&#123; h, 1 &#125;); cout &lt;&lt; &quot;f&quot; &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;right = new TreeNode(3); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;right-&gt;left = new TreeNode(2); root-&gt;right-&gt;right = new TreeNode(4); root-&gt;right-&gt;left-&gt;left = new TreeNode(4); Solution().findDuplicateSubtrees(root);&#125; 😍序列化&emsp;&emsp;序列化成字符串之后再来比较。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; map&lt;string, int&gt; st; vector&lt;TreeNode*&gt; vec; string s; dg(root, st, vec, s); return vec; &#125; void dg(TreeNode* h, map&lt;string, int&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec, string&amp; s) &#123; if(!h) return ; dg(h-&gt;left, st, vec, s); dg(h-&gt;right, st, vec, s); s.clear(); seril(h, s); if(st.count(s)) &#123; if(st.at(s) == 1) &#123; // cout &lt;&lt; &quot;i&quot; &lt;&lt; endl; vec.push_back(h); &#125; st.at(s) += 1; // cout &lt;&lt; &quot;t&quot; &lt;&lt; endl; &#125; else &#123; st.insert(&#123;s, 1&#125;); // cout &lt;&lt; &quot;f&quot; &lt;&lt; endl; &#125; &#125; void seril(TreeNode* h,string&amp; s) &#123; if(!h) &#123; s += &quot;@#&quot;; return ; &#125; s += to_string(h-&gt;val) + &apos;#&apos;; seril(h-&gt;left, s); seril(h-&gt;right, s); &#125;&#125;; Accepted 168/168 cases passed (684 ms) Your runtime beats 5.25 % of cpp submissions Your memory usage beats 15.17 % of cpp submissions (54.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"36.有效的数独","slug":"leetcode36","date":"2020-01-23T14:00:56.000Z","updated":"2020-01-23T14:02:10.506Z","comments":true,"path":"2020/01/23/leetcode36/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode36/","excerpt":"","text":"🚌1234567891011121314151617181920212223242526class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int columns[9][9] = &#123;0&#125;, rows[9][9] = &#123;0&#125;, boxes[9][9] = &#123;0&#125;; for(int r = 0; r &lt; 9; ++r) for(int c = 0; c &lt; 9; ++c) &#123; if(board[r][c] == &apos;.&apos;) continue; int val = board[r][c] - 48 - 1; // cout &lt;&lt; val &lt;&lt; endl; int box_num = r / 3 * 3 + c / 3; boxes[box_num][val] += 1; columns[c][val] += 1; rows[r][val] += 1; if(boxes[box_num][val] &gt; 1 || columns[c][val] &gt; 1 || rows[r][val] &gt; 1) &#123; return false; &#125; &#125; return true; &#125;&#125;; Accepted 504/504 cases passed (16 ms) Your runtime beats 71.31 % of cpp submissions Your memory usage beats 63.82 % of cpp submissions (9.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"49.字母异位词分组","slug":"leetcode49","date":"2020-01-23T12:52:51.000Z","updated":"2020-01-23T12:53:55.230Z","comments":true,"path":"2020/01/23/leetcode49/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode49/","excerpt":"","text":"12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; map&lt;string, vector&lt;string&gt;&gt; mp; for(auto str: strs) &#123; string s = respell(str); mp[s].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; vs; for(auto v : mp) vs.push_back(v.second); return vs; &#125; string respell(string s) &#123; vector&lt;char&gt; vec; for(auto i : s) &#123; vec.push_back(i); &#125; sort(vec.begin(), vec.end()); string ns = &quot;&quot;; for(auto x : vec) &#123; ns += x; &#125; return ns; &#125;&#125;; Accepted 101/101 cases passed (64 ms) Your runtime beats 47.5 % of cpp submissions Your memory usage beats 11.54 % of cpp submissions (22.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"219.存在重复元素 II","slug":"leetcode219","date":"2020-01-23T12:15:26.000Z","updated":"2020-01-23T12:17:36.825Z","comments":true,"path":"2020/01/23/leetcode219/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode219/","excerpt":"","text":"😝实现set的大小用来记录距离值K。 12345678910111213141516class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; set&lt;int&gt; st; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(st.count(nums[i]) == 1) return true; st.insert(nums[i]); if(st.size() &gt; k) &#123; st.erase(nums[i - k]); &#125; &#125; return false; &#125;&#125;; Accepted 23/23 cases passed (48 ms)Your runtime beats 41.06 % of cpp submissionsYour memory usage beats 6.78 % of cpp submissions (15.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"350.两个数组的交集 II","slug":"leetcode350","date":"2020-01-23T11:52:59.000Z","updated":"2020-01-23T11:54:17.893Z","comments":true,"path":"2020/01/23/leetcode350/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode350/","excerpt":"","text":"😂代码实现1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if(!nums1.size() || !nums2.size()) return vector&lt;int&gt;(); vector&lt;int&gt; res; int lo, ho, mid; sort(nums2.begin(), nums2.end()); for(auto x: nums1) &#123; lo = 0; ho = nums2.size() - 1; while(lo &lt; ho) &#123; mid = lo + (ho - lo) / 2; if(nums2[mid] &lt; x) &#123; lo = mid + 1; &#125; else &#123; ho = mid; &#125; &#125; if(nums2[lo] == x) &#123; res.push_back(x); nums2.erase(nums2.begin() + lo); if(!nums2.size()) return res; &#125; &#125; return res; &#125;&#125;; Accepted 61/61 cases passed (12 ms) Your runtime beats 55.05 % of cpp submissions Your memory usage beats 52.41 % of cpp submissions (9.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"387.字符串中的第一个唯一字符","slug":"leetcode387","date":"2020-01-23T11:41:29.000Z","updated":"2020-01-23T11:42:25.345Z","comments":true,"path":"2020/01/23/leetcode387/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode387/","excerpt":"","text":"😂代码实现1234567891011121314151617181920212223242526class Solution &#123;public: int firstUniqChar(string s) &#123; if(!s.size()) return -1; map&lt;char, int&gt; st; for(int i = 0; i &lt; s.size(); ++i)&#123; if(!st.count(s[i])) &#123; st[s[i]] = i; &#125; else &#123; st[s[i]] = INT_MAX; &#125; &#125; if(!st.size()) return -1; auto x = min_element(st.begin(), st.end(), [](auto&amp; a, auto&amp; b)&#123; if(a.second &lt; b.second) &#123; return true; &#125; return false; &#125;); if(x-&gt;second == INT_MAX) return -1; return x-&gt;second; &#125;&#125;; Accepted 104/104 cases passed (92 ms) Your runtime beats 20.33 % of cpp submissions Your memory usage beats 5.07 % of cpp submissions (13.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"599.两个列表的最小索引总和","slug":"leetcode599","date":"2020-01-23T11:10:24.000Z","updated":"2020-01-23T11:11:18.248Z","comments":true,"path":"2020/01/23/leetcode599/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode599/","excerpt":"","text":"😂代码实现1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123; vector&lt;string&gt; vec; if(!list1.size()) return vec; map&lt;string, int&gt; st1, st2; for(int i = 0; i &lt; list1.size(); ++i) st1.insert(&#123;list1[i], i&#125;); for(int i = 0; i &lt; list2.size(); ++i) &#123; if(st1.count(list2[i]) != 0) &#123; auto x = st1.at(list2[i]); st2.insert(&#123;list2[i], x + i&#125;); &#125; &#125; int mi = INT_MAX; for(auto x :st2) &#123; if(mi &gt; x.second) &#123; mi = x.second; // ms = x.first; &#125; &#125; for(auto x : st2) &#123; if(mi == x.second) vec.push_back(x.first); &#125; return vec; &#125; &#125;; Accepted 133/133 cases passed (152 ms) Your runtime beats 33.28 % of cpp submissions Your memory usage beats 21.41 % of cpp submissions (31.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"205.同构字符串","slug":"leetcode205","date":"2020-01-23T09:52:36.000Z","updated":"2020-01-23T09:53:33.989Z","comments":true,"path":"2020/01/23/leetcode205/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode205/","excerpt":"","text":"😂代码实现123456789101112131415class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char, int&gt; st, tt; for(int i = 0; i &lt; s.size(); ++i) &#123; if(st.count(s[i]) == 1 || tt.count(t[i]) == 1) &#123; if(tt.count(t[i]) != 1 || st.count(s[i]) != 1 || tt.at(t[i]) != st.at(s[i])) return false; &#125; st.insert(&#123;s[i], i&#125;); tt.insert(&#123;t[i], i&#125;); &#125; return true; &#125;&#125;; Accepted 30/30 cases passed (40 ms) Your runtime beats 5.2 % of cpp submissions Your memory usage beats 5.04 % of cpp submissions (15 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"202.快乐数","slug":"leetcode202","date":"2020-01-23T09:00:15.000Z","updated":"2020-01-23T09:01:24.368Z","comments":true,"path":"2020/01/23/leetcode202/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode202/","excerpt":"","text":"🐤1234567891011121314151617181920212223242526class Solution &#123;public: bool isHappy(int n) &#123; vector&lt;int&gt; res; int count = 0; while(n != 1 &amp;&amp; count != 10) &#123; ++count; helper(n, res); n = 0; for(auto x: res) &#123; n += pow(x, 2); &#125; &#125; if(count == 10) return false; return true; &#125; void helper(int n, vector&lt;int&gt;&amp; res) &#123; res.clear(); while(n) &#123; res.push_back(n % 10); n /= 10; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"349.两个数组的交集","slug":"leetcode349","date":"2020-01-23T08:28:49.000Z","updated":"2020-01-23T08:31:35.782Z","comments":true,"path":"2020/01/23/leetcode349/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode349/","excerpt":"","text":"🉐二分查找 and 哈希表&emsp;&emsp;一个哈希表的set来得到一个数组的唯一值，再通过二分查找来比较，得到一样的值，放入结果的vector中。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; st; if(!nums1.size() || !nums2.size()) return vector&lt;int&gt;(); vector&lt;int&gt; res; int lo, ho, mid; sort(nums2.begin(), nums2.end()); for(auto x: nums1) st.insert(x); for(auto x: st) &#123; lo = 0; ho = nums2.size() - 1; while(lo &lt; ho) &#123; mid = lo + (ho - lo) / 2; if(nums2[mid] &lt; x) &#123; lo = mid + 1; &#125; else &#123; ho = mid; &#125; &#125; if(nums2[lo] == x) &#123; res.push_back(x); &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"136.只出现一次的数字","slug":"leetcode136","date":"2020-01-23T08:21:00.000Z","updated":"2020-01-23T08:21:53.417Z","comments":true,"path":"2020/01/23/leetcode136/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode136/","excerpt":"","text":"12345678910111213class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; st; for(auto x : nums) &#123; if(st.count(x) == 0) st.insert(x); else st.erase(x); &#125; return *st.begin(); &#125;&#125;; Accepted 16/16 cases passed (36 ms) Your runtime beats 8.92 % of cpp submissions Your memory usage beats 5.02 % of cpp submissions (12.1 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"217.存在重复元素","slug":"leetcode217","date":"2020-01-23T08:04:46.000Z","updated":"2020-01-23T08:05:41.874Z","comments":true,"path":"2020/01/23/leetcode217/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode217/","excerpt":"","text":"因为不需要有序，所以可以用unordered_set而不是set 123456789101112class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; st; for(auto x : nums) &#123; if(st.count(x) &gt; 0) return true; st.insert(x); &#125; return false; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"706.设计哈希映射","slug":"leetcode706","date":"2020-01-23T07:52:39.000Z","updated":"2020-01-23T07:53:17.385Z","comments":true,"path":"2020/01/23/leetcode706/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode706/","excerpt":"","text":"😂代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class MyHashMap &#123;public: /** Initialize your data structure here. */ MyHashMap() : N(0), M(10000) &#123; keys = new int [10000](); vals = new int [10000](); for(int i = 0; i &lt; 10000; ++i) &#123; keys[i] = -1; vals[i] = -1; &#125; &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; vals[i] = value; return ; &#125; &#125; vals[i] = value; keys[i] = key; N++; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return vals[i]; &#125; return -1; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) break; &#125; if(keys[i] == -1) return ; int k2, v2; keys[i] = -1; vals[i] = -1; i = (i + 1) % M; while(keys[i] != -1)&#123; k2 = keys[i]; v2 = vals[i]; keys[i] = -1; vals[i] = -1; --N; put(k2, v2); i = (i + 1) % M; &#125; --N; &#125;private: int *keys; int *vals; int N; int M;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"705.设计哈希集合","slug":"leetcode705","date":"2020-01-23T07:36:48.000Z","updated":"2020-01-23T07:37:40.282Z","comments":true,"path":"2020/01/23/leetcode705/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode705/","excerpt":"","text":"😂代码实现&emsp;&emsp; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MyHashSet &#123;public: /** Initialize your data structure here. */ MyHashSet() : N(0), M(10000) &#123; keys = new int [10000](); for(int i = 0; i &lt; 10000; ++i) keys[i] = -1; &#125; void add(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return ; &#125; keys[i] = key; N++; &#125; void remove(int key) &#123; if(!contains(key)) return ; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) break; &#125; int k2; keys[i] = -1; i = (i + 1) % M; while(keys[i] != -1)&#123; k2 = keys[i]; keys[i] = -1; --N; add(k2); i = (i + 1) % M; &#125; --N; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return true; &#125; return false; &#125;private: int *keys; int N; int M;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"第五章 Internet协议","slug":"TIV5","date":"2020-01-23T05:47:50.000Z","updated":"2020-01-23T06:30:00.700Z","comments":true,"path":"2020/01/23/TIV5/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV5/","excerpt":"","text":"IPv4头部长度包含20个字节（没有选项），IPv6头部长度固定（40字节）。网络字节序：高位优先字节序。Internet头部被限制为60个字节，因为IHL字段长度为4位，保存IPv4头部中32位字的数量。主机不需要接收大于576字节的IPv4数据报。头部校验和字段仅计算IPv4头部。","categories":[],"tags":[{"name":"《TCP/IP详解》读书笔记","slug":"《TCP-IP详解》读书笔记","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"第三章 链路层","slug":"TIV3","date":"2020-01-23T04:48:35.000Z","updated":"2020-01-23T05:47:43.940Z","comments":true,"path":"2020/01/23/TIV3/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV3/","excerpt":"","text":"🐘关键词汇最大传输单元： MTU以太网：通常指一套标准。10Mbit/s以太网，又称802.3标准。 🐳关键概念&emsp;交换机以双工方式运行，并且不需要使用CSMA/CD算法.&emsp;传统以太网最小的帧是64字节，要求数据区长度最小为48字节，最大帧长度为1518字节，MTU大小限制为1500字节。","categories":[],"tags":[{"name":"《TCP/IP详解》读书笔记","slug":"《TCP-IP详解》读书笔记","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"第二章 Internet地址结构","slug":"TIV2","date":"2020-01-23T01:42:40.000Z","updated":"2020-01-23T04:48:25.660Z","comments":true,"path":"2020/01/23/TIV2/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV2/","excerpt":"","text":"🐘关键词汇子网寻址：一个站点被分配一个A类、B类和C类的网络号，保留一些剩余主机号进一步用站点分配。该站点可能将基础地址中的主机部分进一步划分为一个子网号和一个主机号。A类网络地址：网络号8位，0 + 7位自由;主机号24位 B类网络地址：网络号16位，10 + 14位自由；主机16位 C类网络地址：网络号24位，110 + 21位自由 ；主机8位D类网络地址：网络号32位，1110 + 28位自由 E类网络地址：网络号32位，1111 + 28位自由 子网掩码：由主机或路由器使用的分配位，以确定如何从一台主机对应IP地址中获得网络和子网信息。子网掩码纯粹是站点内部的局部问题。定向广播： 使用子网广播地址作为目的地的数据报。有限广播：255.255.255.255被保留为本地网络广播，它根本不会被路由器转发。任意源组播：ASM,任何发送方可以发送给任何组。特点组播：SSM，在每个组中只使用一个发送方。 🐳关键概念&emsp;IPv6地址长度128位（16* 8），IPv4地址长度32位（8* 4） &emsp;IPv6块的前导的零不必书写。全零的块可以省略，并用符号::代替，为了避免歧义，一个IPv6地址中的符号::只能使用一次。在IPv6格式中嵌入IPv4地址可以使用混合符号形式，紧接着IPv4部分的地址块的值为ffff，地址的其他部分使用点分四组格式（::ffff:10.0.0.1） &emsp;只有划分子网的网络中的主机和路由器知道子网结构，Internet其他部分仍然将它作为站点相关的地址来看待.&emsp;128.32.1.255/24这个地址称为子网广播地址。&emsp;CIDR缓解IPv4地址的压力，处理大于255小于65536的主机数。","categories":[],"tags":[{"name":"《TCP/IP详解》读书笔记","slug":"《TCP-IP详解》读书笔记","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"第一章 概述","slug":"TIV1","date":"2020-01-22T13:10:37.000Z","updated":"2020-01-22T15:58:16.318Z","comments":true,"path":"2020/01/22/TIV1/","link":"","permalink":"http://yoursite.com/2020/01/22/TIV1/","excerpt":"","text":"🐘关键词汇协议族： 一系列相关协议的集合。 网关：又称路由器。 虚电路：表现出很多电路行为，但是不依赖于物理的交换机，而通过顶层的面向连接的分组来实现 数据报：一个特定类型的分组，包含所有来源地和目的地的所有识别信息。 消息边界：假设发送3个数据报，接收时必须是3个数据报，那么这就是有消息边界的；如果可以自己选择接收次数，一次接收3个数据报，或者2次，这就是没有消息边界。会话层：表示运行中的应用之间的交互，会话层协议可提供例如连接初始化和重新启动、增加检查点等功能。表示层：负责信息格式转换和标准化编码。PDU：协议数据单元 转发：每个数据报的目的地址用于决定将该数据报发送到哪里，而做出此决定和发送数据报到下一跳的过程。单播：目的地是一台主机。广播：目的地是一个指定网络中的所有主机。 组播：目的地是属于一个组播组的一组主机。 ICMP: Internet控制消息协议是IP的一个辅助协议。IP层使用它与其他主机或路由器的IP层之间交换差错消息和其他重要消息。 应用：ping、traceroute。IGMP：Internet组管理协议是IPv4的另一个辅助协议。它采用组播寻址和交付来管理作为组播成员的主机。SCTP: 流控制传输协议. 端口号：16位非负整数（0~65535），熟知端口号（0 ~ 1023），注册端口号（1024 ~ 49151），动态/私有端口号（49152 ~ 65535）internet：常见协议族互联的多个网络。Internet: TCP/IP通信的世界范围的主机集合。 🐳关键概念&emsp;TCP/IP是一个实现Internet体系结构的协议族。 &emsp;在尽力而为的交付中，网络不会花费很大努力来确保数据在没有差错或缺陷的情况下交付。&emsp;在尽力而为的IP网络中，降低发送方的发送速度可通过流量控制机制实现。&emsp;通常认为TCP/IP体系结构包含5层。&emsp;端主机实现所有层，交换机实现到第二层，路由器实现到第三层。 &emsp;通常不认为交换机或桥接是一个中间系统，这时由于它们没有使用互联网络协议的地址格式来编址，并在很大程度上以透明于网络层协议的方式运行。&emsp;有多个接口的系统称为多宿主. &emsp;IP发送给链路层协议的PDU称为IP数据报，它的大小是64KB（IPv6是4GB）,我们简化称为分组&emsp;大的分组放入链路层PDU（称为帧）时需要进行缩小处理，这个过程称为分片。 &emsp;TCP发送到IP的PDU称为TCP段。 &emsp;用户可以通过虚拟专用网VPN连接到内联网。&emsp;","categories":[],"tags":[{"name":"《TCP/IP详解》读书笔记","slug":"《TCP-IP详解》读书笔记","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"散列表","slug":"alg6","date":"2020-01-22T12:22:09.000Z","updated":"2020-01-22T12:29:28.412Z","comments":true,"path":"2020/01/22/alg6/","link":"","permalink":"http://yoursite.com/2020/01/22/alg6/","excerpt":"","text":"🥣拉链法的散列表&emsp;&emsp;基于链表实现的字典实现而来 散列表的重点在于解决冲突，拉链法解决冲突的方法是通过数组＋链表的形式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &quot;BinarySearchST.hpp&quot;using namespace std;/** * 拉链法散列表 * 因为没有Java的hasCode方法， * 所以这里的代码直接使用int类型 **/ template&lt;typename Value&gt;class SeparateChainingHashST&#123; public: SeparateChainingHashST(int M); ~SeparateChainingHashST(); Value get(int key); void put(int key, Value val); int size() const &#123;return this-&gt;N;&#125; private: int N; //键值对总数 int M; //散列表的大小 BinarySearchST&lt;int, Value&gt; *st; int hash(int key) const;&#125;;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::SeparateChainingHashST(int M) : N(0), M(M)&#123; st = new BinarySearchST&lt;int, Value&gt;[M]();&#125;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::~SeparateChainingHashST()&#123; delete [] st;&#125;template&lt;typename Value&gt;int SeparateChainingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;Value SeparateChainingHashST&lt;Value&gt;::get(int key)&#123; return st[hash(key)].get(key);&#125;template&lt;typename Value&gt;void SeparateChainingHashST&lt;Value&gt;::put(int key, Value val)&#123; st[hash(key)].put(key, val); N++;&#125; 😤线性探测法的散列表&emsp;&emsp;线性探测法的重点在于hash值相同时，将键值往后移，这样就共用一个数组，对于拉链法的散列表，这种方法是用时间复杂度来换取空间复杂度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * 线性探测法的散列表 **/ template&lt;typename Value&gt;class LinearProbingHashST&#123; public: LinearProbingHashST(int M); int size() const &#123;return N;&#125; void put(int key, Value val); Value get(int key); void delet(int key); bool contain(int key) const; private: int M; //长度 int N; //键值对数量 int* keys; Value* vals; void resize(int sz); int hash(int key) const;&#125;;template&lt;typename Value&gt;int LinearProbingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;LinearProbingHashST&lt;Value&gt;::LinearProbingHashST(int M) :M(M), N(0)&#123; keys = new int [M](); vals = new Value [M](); for(int i = 0; i &lt; M; ++i) keys[i] = -1;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::put(int key, Value val)&#123; if(N &gt; M / 2) &#123; resize(2 * M); &#125; int i; for(i = hash(key); keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; vals[i] = val; return ; &#125; &#125; keys[i] = key; vals[i] = val; N++;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::resize(int sz)&#123; int * keys1 = keys; Value* vals1 = vals; int M1 = M; keys = new int [sz](); vals = new Value [sz] (); for(int i = 0; i &lt; sz; ++i) &#123; keys[i] = -1; &#125; N = 0; M = sz; for(int i = 0; i &lt; M1; ++i) &#123; if(keys1[i] != -1) &#123; put(keys1[i], vals1[i]); &#125; &#125; delete [] keys1; delete [] vals1;&#125;template&lt;typename Value&gt;Value LinearProbingHashST&lt;Value&gt;::get(int key)&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; return vals[i]; &#125; &#125; return Value();&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::delet(int key)&#123; if(!contain(key)) return ; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) if(keys[i] == key) break; keys[i] = -1; vals[i] = Value(); i = (i + 1) % M; int k; Value v; while(keys[i] != -1) &#123; k = keys[i]; v = vals[i]; N--; keys[i] = -1; vals[i] = Value(); put(k, v); i = (i + 1) % M; &#125; N--; if(N &gt; 0 &amp;&amp; N == M/8) resize(M / 2);&#125;template&lt;typename Value&gt;bool LinearProbingHashST&lt;Value&gt;::contain(int key) const&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return true; &#125; return false;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"98.验证二叉搜索树","slug":"leetcode98","date":"2020-01-22T07:09:27.000Z","updated":"2020-01-22T07:17:21.119Z","comments":true,"path":"2020/01/22/leetcode98/","link":"","permalink":"http://yoursite.com/2020/01/22/leetcode98/","excerpt":"","text":"🥧中序遍历&emsp;&emsp;二叉搜索树的中序遍历得到的是一个递增的序列。 12345678910111213141516171819202122232425class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; vector&lt;int&gt; vec; helper(root, vec); if(vec.size() &lt; 2) return true; for(int i = 0; i &lt;= vec.size() - 2; ++i) &#123; if(vec[i] &gt;= vec[i+1]) return false; &#125; return true; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123; if(!root) return ; if(root-&gt;left) helper(root-&gt;left, vec); vec.push_back(root-&gt;val); if(root-&gt;right) helper(root-&gt;right, vec); &#125;&#125;; Accepted 75/75 cases passed (20 ms)Your runtime beats 49.34 % of cpp submissionsYour memory usage beats 5.03 % of cpp submissions (21.3 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"110.平衡二叉树","slug":"leetcode110","date":"2020-01-22T06:32:09.000Z","updated":"2020-01-22T06:35:21.232Z","comments":true,"path":"2020/01/22/leetcode110/","link":"","permalink":"http://yoursite.com/2020/01/22/leetcode110/","excerpt":"","text":"🥧递归&emsp;&emsp;和一般递归不同的地方在于，不能返回平衡因子，必须返回高度，并且设置一个-1的特殊值来作为失败的结果（用来代替bool）。这里不能返回bool类型，因为bool无法传递高度值。 12345678910111213141516class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return helper(root) != -1; &#125; int helper(TreeNode* h) &#123; if(!h) return 0; int lf = helper(h-&gt;left), rf = helper(h-&gt;right); if(lf == -1 || rf == -1) return -1; return abs(rf - lf) &lt;= 1 ? max(lf, rf) + 1: -1; &#125;&#125;; Accepted 227/227 cases passed (20 ms) Your runtime beats 44.47 % of cpp submissions Your memory usage beats 9.13 % of cpp submissions (17.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"96.不同的二叉搜索树","slug":"leetcode96","date":"2020-01-21T11:33:23.000Z","updated":"2020-01-21T11:34:42.154Z","comments":true,"path":"2020/01/21/leetcode96/","link":"","permalink":"http://yoursite.com/2020/01/21/leetcode96/","excerpt":"","text":"🥧动态规划&emsp;&emsp; 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; int tr[n + 1] = &#123;0&#125;; tr[0] = 1; tr[1] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i; ++j) &#123; tr[i] += tr[j - 1] * tr[i - j]; &#125; return tr[n]; &#125;&#125;; Accepted 19/19 cases passed (0 ms) Your runtime beats 100 % of cpp submissions Your memory usage beats 32.61 % of cpp submissions (8.3 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"95.不同的二叉搜索树 II","slug":"leetcode95","date":"2020-01-21T10:50:33.000Z","updated":"2020-01-21T10:52:31.615Z","comments":true,"path":"2020/01/21/leetcode95/","link":"","permalink":"http://yoursite.com/2020/01/21/leetcode95/","excerpt":"","text":"🥧递归&emsp;&emsp;写递归最重要的点在于： 不要在乎递归是如何运行的，你要在乎的是，通过设计什么样的递归公式，递归出口，就一定可以通过递归获得最终的值。而不是去考虑递归在计算机中以什么样的形式和流程去执行的。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(!n) return vector&lt;TreeNode*&gt;(); return helper(1, n); &#125; vector&lt;TreeNode*&gt; helper(int start, int end) &#123; vector&lt;TreeNode*&gt; ret; if(start &gt; end) &#123; ret.push_back(nullptr); return ret; &#125; for(int i = start; i &lt;= end; ++i) &#123; auto leftList = helper(start, i - 1); auto rightList = helper(i + 1, end); for(auto l : leftList) for(auto r: rightList) &#123; auto newOne = new TreeNode(i); newOne-&gt;left = l; newOne-&gt;right = r; ret.push_back(newOne); &#125; &#125; return ret; &#125;&#125;; Accepted 9/9 cases passed (12 ms) Your runtime beats 99.22 % of cpp submissions Your memory usage beats 8.96 % of cpp submissions (17.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"315.计算右侧小于当前元素的个数","slug":"leetcode315","date":"2020-01-17T12:17:50.000Z","updated":"2020-01-17T12:46:10.825Z","comments":true,"path":"2020/01/17/leetcode315/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode315/","excerpt":"","text":"😝二叉查找树实现&emsp;&emsp;有几个难点 递归插入的时候要通过一个辅助变量来更新每个节点的值（low_count） 处理值相同时的情况因为插入是沿着一条路径下去的，所以是没有办法在插入的时候更新全部节点的。 😳方案一是：选择单独在插入之后再来更新节点。 😳方案二是：更新一边的节点，在这个题目中，我们的选择就是只更新左边的节点，这时Node-&gt;low_count代表的就不是全体中比它小的节点数量，而是当前根节点下比它小的数量，而向右移动就是切换根节点。因为我们是以根节点标准开始进行比较，所以我们用辅助变量更新节点是更新不到起点以外的地方的。 🥦方案二： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: struct Node &#123; int low_count; //统计比它小的节点 int val; shared_ptr&lt;Node&gt; left, right; Node(int val, int count) : low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125; int compareTo(int k) &#123; if(val &lt; k) return -1; else if (val &gt; k) return 1; return 0; &#125; &#125;; int low_c = 0; shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123; if(!h) return make_shared&lt;Node&gt;(val ,0); int cmp = h-&gt;compareTo(val); if(cmp &gt;= 0) &#123; h-&gt;low_count += 1; h-&gt;left = insert(h-&gt;left, val); &#125; else if(cmp &lt; 0) &#123; low_c += h-&gt;low_count + 1; h-&gt;right = insert(h-&gt;right, val); &#125; return h; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; counts(nums.size()); if(!nums.size()) return counts; counts[0] = 0; if(nums.size() == 1) &#123; return counts; &#125; shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0); for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123; low_c = 0; head = insert(head, nums[i]); counts[i] = low_c; &#125; return counts; &#125;&#125;; Accepted16/16 cases passed (64 ms) Your runtime beats 55.66 % of cpp submissions Your memory usage beats 10.86 % of cpp submissions (29.7 MB) 🍅方案一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: struct Node &#123; int low_count; int val; shared_ptr&lt;Node&gt; left, right; Node(int val, int count) : low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125; int compareTo(int k) &#123; if(val &lt; k) return -1; else if (val &gt; k) return 1; return 0; &#125; &#125;; int Nsize( shared_ptr&lt;Node&gt; h) &#123; if(h) return h-&gt;low_count; return 0; &#125; shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123; if(!h) return make_shared&lt;Node&gt;(val ,0); int cmp = h-&gt;compareTo(val); if(cmp &gt;= 0) &#123; h-&gt;left = insert(h-&gt;left, val); &#125; else if(cmp &lt; 0) &#123; h-&gt;right = insert(h-&gt;right, val); &#125; return h; &#125; int g = 0; void rank(shared_ptr&lt;Node&gt; h) &#123; if(!h) return ; if(h-&gt;left) rank(h-&gt;left); h-&gt;low_count = g; g += 1; if(h-&gt;right) rank(h-&gt;right); &#125; int xx(shared_ptr&lt;Node&gt; h,int val) &#123; if(!h) return 0; while(h) &#123; int cmp = h-&gt;compareTo(val); if(cmp &lt; 0 ) h = h-&gt;right; else if(cmp &gt; 0) h = h-&gt;left; else if(cmp == 0 &amp;&amp; !h-&gt;left) break; else h = h-&gt;left; &#125; return h-&gt;low_count; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; counts(nums.size()); if(!nums.size()) return counts; counts[0] = 0; if(nums.size() == 1) &#123; return counts; &#125; shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0); for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123; head = insert(head, nums[i]); g = 0; rank(head); counts[i] = xx(head, nums[i]); &#125; return counts; &#125;&#125;; Time Limit Exceeded 15/16 cases passed (N/A) Testcase[5183,2271,3067,539,8939,2999,9264,737,3974,5846,-210,9278,5800,2675,6608,1133,-1,6018,9672,5179,9842,7424,-209,2988,2757,5984,1107,2644,-499,7234,7539,6525,347,5718,-742,1797,5292,976,8752,8297,1312,3385,5924,2882,6091,-282,2595,96,1906,8014,7667,5895,7283,7974,-167,7068,3946,6223,189,1589,2058,9277,-302,8157,8256,5261,8067,1071,9470,2682,8197,5632,753,3179,8187,9042,8167,4657,7080,7801,5627,7917,8085,928,-892,-427,3685,4676,2431,8064,8537,343,505,4352,2108,4399,66,2086,1922,9126,9460,393,443,5689,7595,850,8493,2866,732,3738,7933,3666,2370,5804,4045,7903,8009,5387,5542,7593,6862,1547,6934,-160,9693,4560,7429,9989,7232,-594,587,6476,9277,4471,5979,6268,2419,6706,-727,1927,7361,9684,5519,2703,1723…..","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"449.序列化和反序列化二叉搜索树","slug":"leetcode449","date":"2020-01-17T07:16:05.000Z","updated":"2020-01-17T12:46:06.969Z","comments":true,"path":"2020/01/17/leetcode449/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode449/","excerpt":"","text":"递归实现&emsp;&emsp;先序遍历，类似于数组表示二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Codec &#123;public: void se_helper(TreeNode* root, string&amp; str) &#123; if(!root) &#123; str += &quot;x#&quot;; return ; &#125; str += to_string(root-&gt;val) + &apos;#&apos;; se_helper(root-&gt;left, str); se_helper(root-&gt;right, str); &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string s; se_helper(root, s); // cout &lt;&lt;s &lt;&lt; endl; return s; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if(data == &quot;x#&quot;) return nullptr; auto iter = data.begin(); return deserialize1(iter, data.end()); &#125; TreeNode* deserialize1(string::iterator&amp; iter, string::iterator end) &#123; if(iter == end) return nullptr; string s; while(*iter != &apos;#&apos;) &#123; s += *iter++; &#125; ++iter; if(s == &quot;x&quot;) return nullptr; int val = atoi(s.c_str()); TreeNode* newOne = new TreeNode(val); newOne-&gt;left = deserialize1(iter, end); newOne-&gt;right = deserialize1(iter, end); return newOne; &#125;&#125;; Accepted 62/62 cases passed (32 ms) Your runtime beats 87.21 % of cpp submissions Your memory usage beats 43.82 % of cpp submissions (24.2 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"538.把二叉搜索树转换为累加树","slug":"leetcode538","date":"2020-01-17T06:40:09.000Z","updated":"2020-01-17T12:46:01.057Z","comments":true,"path":"2020/01/17/leetcode538/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode538/","excerpt":"","text":"递归实现&emsp;&emsp; 1234567891011121314class Solution &#123;public: int k = 0; TreeNode* convertBST(TreeNode* root) &#123; if(!root) &#123; return nullptr; &#125; convertBST(root-&gt;right); k += root-&gt;val; root-&gt;val = k; convertBST(root-&gt;left); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"450.删除二叉搜索树中的节点","slug":"leetcode450","date":"2020-01-16T08:18:18.000Z","updated":"2020-01-16T08:19:12.318Z","comments":true,"path":"2020/01/16/leetcode450/","link":"","permalink":"http://yoursite.com/2020/01/16/leetcode450/","excerpt":"","text":"递归实现&emsp;&emsp; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int compar(int a, int b) &#123; if(a &gt; b) return 1; else if(b &gt; a) return -1; return 0; &#125; TreeNode* deleteNode(TreeNode* root, int key) &#123; if(!root) return nullptr; int cmp = compar(root-&gt;val, key); if(cmp &lt; 0) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else if(cmp &gt; 0) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else &#123; if(!root-&gt;left) return root-&gt;right; if(!root-&gt;right) return root-&gt;left; auto rm = min(root-&gt;right); root-&gt;right = deleteMin(root-&gt;right); rm-&gt;left = root-&gt;left; rm-&gt;right = root-&gt;right; root = rm; &#125; return root; &#125; TreeNode* min(TreeNode* root) &#123; if(!root-&gt;left) return root; return min(root-&gt;left); &#125; TreeNode* deleteMin(TreeNode* root) &#123; if(!root-&gt;left) return root-&gt;right; root-&gt;left = deleteMin(root-&gt;left); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"108.将有序数组转换为二叉搜索树","slug":"leetcode108","date":"2020-01-15T18:48:36.000Z","updated":"2020-01-15T18:50:54.812Z","comments":true,"path":"2020/01/16/leetcode108/","link":"","permalink":"http://yoursite.com/2020/01/16/leetcode108/","excerpt":"","text":"🥛中序构造&emsp;&emsp;不用担心mid+1超出范围，因为nums[mid]是存在的，所以在构造r时，nums.begin() + mid + 1极限时就是与nums.end()相等。 123456789101112131415class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums)&#123; if(!nums.size()) return nullptr; int mid = nums.size() / 2; TreeNode* root = new TreeNode(nums[mid]); vector&lt;int&gt; l(nums.begin(), nums.begin() + mid); vector&lt;int&gt; r(nums.begin() + mid + 1, nums.end()); root-&gt;left = sortedArrayToBST(l); root-&gt;right = sortedArrayToBST(r); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"在C++中是否有替代INT_MIN这些宏定义的功能？","slug":"problems4","date":"2020-01-12T17:04:54.000Z","updated":"2020-01-12T17:13:48.000Z","comments":true,"path":"2020/01/13/problems4/","link":"","permalink":"http://yoursite.com/2020/01/13/problems4/","excerpt":"","text":"📣在C++中我们依然可以包含 头文件，然后去使用INT_MIN这些宏定义,但是其实在C++中是存在更加优雅的方式的 123#include &lt;limits&gt;std::numeric_limits&lt;int&gt;::min() //INT_MINstd::numeric_limits&lt;int&gt;::max() //INT_MAX","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"如何创建数组的共享指针","slug":"problems3","date":"2020-01-12T02:56:38.000Z","updated":"2020-01-12T02:58:59.555Z","comments":true,"path":"2020/01/12/problems3/","link":"","permalink":"http://yoursite.com/2020/01/12/problems3/","excerpt":"","text":"C++11在shared_ptr是没有shared_ptr&lt;int []&gt;这样的东西的，但是std::unique_ptr&lt;int[]&gt;是有的 12345std::shared_ptr&lt;int[]&gt; a(new int[10]()); // 错误，c++17前不能传递数组类型作为shared_ptr的模板参数std::unique_ptr&lt;int[]&gt; b(new int[10]()); // ok, unique_ptr对此做了特化std::shared_ptr&lt;int&gt; c(new int[10]()); // 错误，可以编译，但会产生未定义行为，请不要这么做std::shared_ptr&lt;int&gt; sp3(new int[10](), std::default_delete&lt;int[]&gt;()); //正确做法","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"字典","slug":"alg5","date":"2020-01-12T02:39:59.000Z","updated":"2020-01-21T08:14:22.906Z","comments":true,"path":"2020/01/12/alg5/","link":"","permalink":"http://yoursite.com/2020/01/12/alg5/","excerpt":"","text":"🥣链表实现链表实现插入、查询的时间复杂度都是N，并非一个高效的实现方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * 链表实现 **/template&lt;typename S, typename T&gt;class SequentialSearchST &#123; public: struct Node &#123; Node(const S&amp; key, const T&amp; val, shared_ptr&lt;Node&gt; next = nullptr) :key(key), val(val), next(next) &#123;&#125; const S key; T val; shared_ptr&lt;Node&gt; next; &#125;; void show() const; void put(S key, T val); const T get(const S&amp; key) const; bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; private: shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;const T SequentialSearchST&lt;S,T&gt;::get(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return T(); return sk-&gt;val;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::put(S key, T val) &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(sk) sk-&gt;val = val; else &#123; shared_ptr&lt;Node&gt; newOne(make_shared&lt;Node&gt;(key, val, head)); head = newOne; &#125;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::show() const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; cout &lt;&lt; sk-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; sk-&gt;val &lt;&lt; endl; sk = sk-&gt;next; &#125;&#125;template&lt;typename S, typename T&gt;bool SequentialSearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return false; return true;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; SequentialSearchST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; res.push_back(sk-&gt;key); sk = sk-&gt;next; &#125; return res;&#125; 🚆改进1：改用数组实现，二分查找查找的时间复杂度降低为lgN，但是因为数组移位的原因，插入的时间复杂度还是N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * 数组实现 **/template&lt;typename S, typename T&gt;class BinarySearchST &#123; public: BinarySearchST(int size = 10000); ~BinarySearchST(); void put(const S&amp;, const T&amp;); const T get(const S&amp;); bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; void show() const; private: const int rank(const S&amp;) const; S* _keys; T* vals; int _capacity; int n;&#125;;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::BinarySearchST(int size) : _keys(new S[size]), vals(new T[size]), _capacity(size), n(0)&#123;&#125;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::~BinarySearchST()&#123; delete []_keys; delete []vals;&#125;template&lt;typename S, typename T&gt;const int BinarySearchST&lt;S,T&gt;::rank(const S&amp; key) const&#123; if(n == 0) return 0; int lo = 0, hi = n - 1, mid; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if(_keys[mid] &lt; key) lo = mid + 1; else hi = mid; &#125; if(_keys[lo] &lt; key) return lo + 1; else return lo;&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val)&#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; vals[pos] = val; return ; &#125; //暂时不考虑超出容量的情况 for(int i = n; i &gt; pos; --i) &#123; _keys[i] = _keys[i - 1]; vals[i] = vals[i - 1]; &#125; _keys[pos] = key; vals[pos] = val; ++n;&#125;template&lt;typename S, typename T&gt;const T BinarySearchST&lt;S,T&gt;::get(const S&amp; key) &#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; return vals[pos]; &#125; return T();&#125;template&lt;typename S, typename T&gt;bool BinarySearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; if(!n) return false; int pos = rank(key); return _keys[pos] == key;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BinarySearchST&lt;S,T&gt;::keys() const &#123; return vector&lt;S&gt;(_keys, _keys + n);&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::show() const &#123; for(int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; _keys[i] &lt;&lt; &quot; &quot; &lt;&lt; vals[i] &lt;&lt; endl; &#125;&#125; 🚆改进2：改用二叉查找树查找、修改的平均时间复杂度都是lgN，但是最坏情况两者都退回到N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * 二叉查找树的实现 **/#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * 二叉查找树的实现 **/template&lt;typename S, typename T&gt;class BST&#123; public: struct Node &#123; const S key; T val; shared_ptr&lt;Node&gt; left, right; int N; Node(const S&amp;key, const T&amp; val, int N) : key(key), val(val), left(), right(), N(N) &#123;&#125; int compareTo(shared_ptr&lt;Node&gt; node) const; int compareTo(const S&amp;) const; static int Nsize(shared_ptr&lt;Node&gt; x); &#125;; const S min() const; const S max() const; bool contain(const S&amp;) const; const T get(const S&amp;) const; void put(const S&amp; key, const T&amp; val); void show() const; //调试 const vector&lt;S&gt; keys() const; const S floor(const S&amp; key) const; const S ceiling(const S&amp;key) const; const S select(int x) const; const int rank(const T&amp;) const; void deleteMin(); void delet(const T&amp; key); private: shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt; nd, const T&amp; key); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); const int _rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const; shared_ptr&lt;Node&gt; _select(shared_ptr&lt;Node&gt; nd, int x) const; shared_ptr&lt;Node&gt; _floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const; shared_ptr&lt;Node&gt; _ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const; shared_ptr&lt;Node&gt; _min(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _max(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val); const T _get(shared_ptr&lt;Node&gt; x,const S&amp;) const; void _show(shared_ptr&lt;Node&gt; x) const; void _keys(vector&lt;S&gt;&amp;, shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val) &#123; head = _put(head, key, val);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val) &#123; if(!x) return make_shared&lt;Node&gt;(key, val, 1); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) x-&gt;left = _put(x-&gt;left, key, val); else if(cmp &lt; 0) x-&gt;right = _put(x-&gt;right, key, val); else x-&gt;val = val; x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;/** * &gt; 1 * = 0 * &lt; -1 **/ template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(shared_ptr&lt;Node&gt; node) const &#123; return compareTo(node-&gt;key);&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(const S&amp; key2) const &#123; return key &gt; key2 ? 1 : key &lt; key2 ? -1 : 0;&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x) &#123; if(!x) return 0; else return x-&gt;N;&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::get(const S&amp; key) const &#123; return _get(head, key);&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::_get(shared_ptr&lt;Node&gt; x,const S&amp; key) const &#123; if(!x) return T(); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) return _get(x-&gt;right, key); else if(cmp &lt; 0) return _get(x-&gt;left, key); else return x-&gt;val;&#125;template&lt;typename S, typename T&gt;bool BST&lt;S,T&gt;::contain(const S&amp; key) const &#123; return get(key) != T();&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::show() const &#123; _show(head);&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_show(shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; if(x-&gt;left) _show(x-&gt;left); cout &lt;&lt; x-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; x-&gt;val &lt;&lt; endl; if(x-&gt;right) _show(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; _keys(res, head); return res;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_keys(vector&lt;S&gt;&amp; res, shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; res.push_back(x-&gt;key); _keys(res,x-&gt;left); _keys(res, x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::min() const &#123; if(!head) return S(); return _min(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_min(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;left) return x; else return _min(x-&gt;left);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::max() const &#123; if(!head) return S(); return _max(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_max(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;right) return x; else return _max(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::floor(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; nd = _floor(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::ceiling(const S&amp;key) const &#123; shared_ptr&lt;Node&gt; nd = _ceiling(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(cmp == 0) return x; else if (cmp &gt; 0) return _floor(x-&gt;left, key); shared_ptr&lt;Node&gt; y = _floor(x-&gt;right, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(!cmp) return x; else if(cmp &lt; 0) return _ceiling(x-&gt;right, key); shared_ptr&lt;Node&gt; y = _ceiling(x-&gt;left, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::select(int x) const &#123; if(x &lt; 0 || x &gt;= head-&gt;N) return S(); auto nd = _select(head, x); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_select(shared_ptr&lt;Node&gt; nd, int x) const &#123; if(!nd) return nd; int nd_rank = Node::Nsize(nd-&gt;left); if(nd_rank &gt; x) return _select(nd-&gt;left, x); else if (nd_rank &lt; x) return _select(nd-&gt;right, x - nd_rank - 1); return nd;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::rank(const T&amp; key) const &#123; int rk = _rank(head, key); // if(select(rk) != key) // return -1; return rk;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::_rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const &#123; if(!nd) return 0; int nd_rank = Node::Nsize(nd-&gt;left); if(nd-&gt;key &lt; key) return nd_rank + 1 + _rank(nd-&gt;right, key); else if(nd-&gt;key &gt; key) return _rank(nd-&gt;left, key); return nd_rank;&#125;/** * 这个函数只能删除根节点左边的 **/ template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::deleteMin() &#123; deleteMin(head);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::deleteMin(shared_ptr&lt;Node&gt; x) &#123; if(!x-&gt;left) return x-&gt;right; x-&gt;left = deleteMin(x-&gt;left); x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::delet(const T&amp; key) &#123; head = delet(head, key);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::delet(shared_ptr&lt;Node&gt; nd, const T&amp; key)&#123; if(!nd) &#123; return nd; &#125; int cmp = nd-&gt;compareTo(key); if(cmp &lt; 0) &#123; nd-&gt;right = delet(nd-&gt;right, key); &#125; else if(cmp &gt; 0) &#123; nd -&gt;left = delet(nd-&gt;left, key); &#125; else &#123; if(!nd-&gt;left) return nd-&gt;right; if(!nd-&gt;right) return nd-&gt;left; auto minO = _min(nd-&gt;right); minO-&gt;right = deleteMin(nd-&gt;right); minO-&gt;left = nd-&gt;left; nd = minO; &#125; nd-&gt;N = Node::Nsize(nd-&gt;left) + Node::Nsize(nd-&gt;right) + 1; return nd;&#125; 🚆改进3：红黑树查找、插入的时间复杂度恒定为logN 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394/* * @Author: XiaoGongBai * @Date: 2020-01-19 10:21:20 * @Last Modified by: XiaoGongBai * @Last Modified time: 2020-01-19 11:31:04 */#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * 红黑树 **/enum class Color&#123; Red , Black &#125;;template&lt;typename Key, typename Val&gt;class RedBlackBST&#123; public: struct Node&#123; Key key; Val val; shared_ptr&lt;Node&gt; left,right; int N; Color color; Node(const Key&amp; key, const Val&amp; val, int N, Color color) :key(key), val(val), left(), right(), N(N), color(color) &#123;&#125; static int Nsize(shared_ptr&lt;Node&gt; x); int compareTo(const Key&amp; key) const; &#125;; void put(const Key&amp; key, const Val&amp; val); shared_ptr&lt;Node&gt; get(const Key&amp; key) const; void deleteMin(); void deleteMax(); void delet(const Key&amp;); Key min() const; Key max() const; vector&lt;Key&gt; keys(const Key&amp; m, const Key&amp; e) const; vector&lt;Key&gt; keys() const; const int size() const &#123;return root ? root-&gt;N : 0;&#125; private: shared_ptr&lt;Node&gt; root; void keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const; shared_ptr&lt;Node&gt; max(shared_ptr&lt;Node&gt; h) const; shared_ptr&lt;Node&gt; min(shared_ptr&lt;Node&gt;) const; shared_ptr&lt;Node&gt; get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const; shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt;, const Key&amp;); shared_ptr&lt;Node&gt; balance(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedLeft(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedRight(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMax(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val); void flipColor(shared_ptr&lt;Node&gt; h); shared_ptr&lt;Node&gt; rotateLeft(shared_ptr&lt;Node&gt; node); shared_ptr&lt;Node&gt; rotateRight(shared_ptr&lt;Node&gt; h); bool isRed(shared_ptr&lt;Node&gt; node) const; &#125;;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x)&#123; return x ? x-&gt;N : 0; &#125;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::compareTo(const Key&amp; key) const&#123; if(key &gt; this-&gt;key) &#123; return -1; &#125; else if(key &lt; this-&gt;key) &#123; return 1; &#125; return 0;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateLeft(shared_ptr&lt;Node&gt; h)&#123; if(!h) return nullptr; auto rh = h-&gt;right; if(!rh) return h; h-&gt;right = rh-&gt;left; rh-&gt;left = h; rh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, rh-&gt;color); return rh;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateRight(shared_ptr&lt;Node&gt; h)&#123; if(!h) &#123; return nullptr; &#125; auto lh = h-&gt;left; if(!lh) return h; h-&gt;left = lh-&gt;right;; lh-&gt;right = h; lh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, lh-&gt;color); return lh;&#125;template&lt;typename Key, typename Val&gt;bool RedBlackBST&lt;Key,Val&gt;::isRed(shared_ptr&lt;Node&gt; h) const&#123; if(!h || h-&gt;color == Color::Black) return false; return true;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::put(const Key&amp; key, const Val&amp; val)&#123; root = put(root, key, val); root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val)&#123; if(!h) return make_shared&lt;Node&gt;(key, val, 1, Color::Red); int cmp = h-&gt;compareTo(key); if(cmp &lt; 0) &#123; h-&gt;right = put(h-&gt;right, key, val); &#125; else if (cmp &gt; 0) &#123; h-&gt;left = put(h-&gt;left, key, val); &#125; else &#123; h-&gt;val =val; &#125; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::flipColor(shared_ptr&lt;Node&gt; h)&#123; h-&gt;color = h-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;right-&gt;color = h-&gt;right-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;left-&gt;color = h-&gt;left-&gt;color == Color::Black ? Color::Red : Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(const Key&amp; key) const&#123; return get(root, key);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const&#123; if(!h) return nullptr; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; return get(h-&gt;left, key); &#125; else if (cmp &lt; 0) &#123; return get(h-&gt;right, key); &#125; else return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMin()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMin(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMin(shared_ptr&lt;Node&gt; h) &#123; if(!h-&gt;left) return h-&gt;right; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) &#123; h = removeRedLeft(h); &#125; h-&gt;left = deleteMin(h-&gt;left); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedLeft(shared_ptr&lt;Node&gt; h) &#123; flipColor(h); if(isRed(h-&gt;right) &amp;&amp; isRed(h-&gt;right-&gt;left)) &#123; h-&gt;right = rotateRight(h-&gt;right); h = rotateLeft(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::balance(shared_ptr&lt;Node&gt; h)&#123; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;KeyRedBlackBST&lt;Key,Val&gt;::min() const&#123; if(!root) return Val(); return min(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::min(shared_ptr&lt;Node&gt; h) const &#123; if(!h-&gt;left) return h; return min(h-&gt;left);&#125;template&lt;typename Key, typename Val&gt;Key RedBlackBST&lt;Key,Val&gt;::max() const&#123; if(!root) return Val(); return max(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::max(shared_ptr&lt;Node&gt; h) const&#123; if(!h-&gt;right) return h; return max(h-&gt;right);&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMax()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMax(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMax(shared_ptr&lt;Node&gt; h)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!h-&gt;right) return h-&gt;left; if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) h = removeRedRight(h); h-&gt;right = deleteMax(h-&gt;right); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedRight(shared_ptr&lt;Node&gt; h)&#123; flipColor(h); if(isRed(h-&gt;left-&gt;left)) &#123; h = rotateRight(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::delet(const Key&amp; key)&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = delet(root, key); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::delet(shared_ptr&lt;Node&gt; h, const Key&amp; key) &#123; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) h = removeRedLeft(h); h-&gt;left = delet(h-&gt;left, key); &#125; else if(cmp &lt; 0)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) &#123; h = removeRedRight(h); &#125; h-&gt;right = delet(h-&gt;right, key); &#125; else &#123; if(!h-&gt;right) return h-&gt;left; h-&gt;val = get(h-&gt;right, min(h-&gt;right)-&gt;key)-&gt;val; h-&gt;key = min(h-&gt;right)-&gt;key; h-&gt;right = deleteMin(h-&gt;right); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys(const Key&amp; m, const Key&amp; e) const&#123; vector&lt;Key&gt; res; keys(root, res, m, e); return res;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const&#123; if(!h) return ; int cmp1 = h-&gt;compareTo(m), cmp2 = h-&gt;compareTo(e); if(cmp1 &gt;= 0 &amp;&amp; cmp2 &lt;= 0) &#123; res.push_back(h-&gt;key); &#125; if(cmp1 &gt; 0) &#123; keys(h-&gt;left, res, m, e); &#125; if(cmp2 &lt; 0) &#123; keys(h-&gt;right, res, m, e); &#125;&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys() const&#123; return keys(min(), max());&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"179.最大数","slug":"leetcode179","date":"2020-01-11T12:18:40.000Z","updated":"2020-01-11T13:53:52.979Z","comments":true,"path":"2020/01/11/leetcode179/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode179/","excerpt":"","text":"🥩堆排序&emsp;&emsp;堆排序，然后将数字拼接成字符串，但是两个数字之间的比较并不能直接用&gt;&lt;来进行。我的方法是定义compare函数，进行比较。compare比较两个数的方法是：比如121，12，那么就比较121|12和12|121的大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; a) &#123; if(!a.size()) return &quot;&quot;; string s; //堆排序 a.insert(a.begin(), -1); int n = a.size() - 1; for(int i = 2; i &lt;= n; ++i) &#123; swim(a, i, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; while(n &gt; 1) &#123; swap(a[1], a[n--]); sink(a, 1, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; for(int i = 1; i &lt; a.size(); ++i) s += to_string(a[i]); int ct = 0; for(int i = 0; i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;; ++i) &#123; ++ct; &#125; if(ct == s.size()) return &quot;0&quot;; return s.substr(ct); &#125; void swim(vector&lt;int&gt;&amp; a, int k, int n) &#123; cout &lt;&lt; &quot;swim&quot; &lt;&lt; endl; int j; while(k &gt; 1) &#123; j = k /2; if(j &gt;= 1 &amp;&amp; compare(a[j],a[k]) != 1) break; swap(a[j], a[k]); k = j; &#125; &#125; void sink(vector&lt;int&gt;&amp; a, int k, int n) &#123; int j ; while(k &lt;= n / 2) &#123; j = 2 * k; if(j + 1 &lt;= n &amp;&amp; compare(a[j + 1], a[j]) == -1) ++j; if(compare(a[j], a[k]) != -1) break; swap(a[j], a[k]); k = j; &#125; &#125; int compare(int i, int j) &#123; if(i == j) return 0; int com = 0, ix = 0, jx = 0, ii = i, jj = j; while(ii / 10 &gt; 0) &#123; ix++; ii /= 10; &#125; while(jj / 10 &gt; 0) &#123; jx++; jj /= 10; &#125; long long ir ,jr; jr = j * pow(10, ix + 1) + i; ir = i * pow(10, jx + 1) + j; // cout &lt;&lt; &quot;i, j: &quot; &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; jr &lt;&lt; endl; if(ir &gt; jr) return 1; else if(jr &gt; ir) return -1; else return 0; &#125;&#125;; Accepted222/222 cases passed (8 ms) Your runtime beats 91.43 % of cpp submissions Your memory usage beats 79.45 % of cpp submissions (9.1 MB) 🈶改进&emsp;&emsp;相比与我将两个数拼在一起比较，更加好的方法是转化为字符串比较 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if (all_of(nums.begin(), nums.end(), [](int x) &#123; return x == 0; &#125;)) &#123; return string(&quot;0&quot;); &#125; vector&lt;string&gt; strNums(nums.size()); std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123; return std::to_string(x); &#125;); std::sort(strNums.begin(), strNums.end(), [](const string&amp; x, const string&amp; y) &#123; /* x为后面元素，y为前面元素，return true则将x移动到前面 */ return x + y &gt; y + x; &#125;); return std::accumulate(strNums.begin(), strNums.end(), string()); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"147.对链表进行插入排序","slug":"leetcode147","date":"2020-01-11T07:55:04.000Z","updated":"2020-01-11T11:51:35.600Z","comments":true,"path":"2020/01/11/leetcode147/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode147/","excerpt":"","text":"🥧模仿数组的实现&emsp;&emsp;注意pre指针的调整，在内循环改变一个节点ptr的位置后，外层循环的ptr的下一个循环就不是ptr-&gt;next了，而是pre-&gt;next 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head-&gt;next, *nex, *pre = head,*ptr2, *pre2, npre = ListNode(INT_MIN); npre.next = head; for( ; ptr != nullptr; ) &#123; for(ptr2 = npre.next, pre2 = &amp;npre; ptr2 != ptr; ptr2 = ptr2-&gt;next, pre2 = pre2-&gt;next)&#123; if(ptr2-&gt;val &gt;= ptr-&gt;val) &#123; pre-&gt;next = ptr-&gt;next; ptr-&gt;next = ptr2; pre2-&gt;next = ptr; break; &#125; &#125; if(ptr2 == ptr) &#123; ptr = ptr-&gt;next; pre = pre-&gt;next; &#125; else &#123; ptr = pre-&gt;next; &#125; // for(auto x = &amp;npre; x != nullptr; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; &#125; return npre.next; &#125;&#125;; Accepted 22/22 cases passed (100 ms) Your runtime beats 6.64 % of cpp submissions Your memory usage beats 13.73 % of cpp submissions (9.7 MB) 🏆改进版&emsp;&emsp;对于插入排序来说，我们没有必要记录那么多前置节点的位置，我们只要保证ptr左边的序列有序即可 1234567891011121314151617181920212223class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head, *nex,*ptr2, npre = ListNode(INT_MIN); while(ptr) &#123; nex = ptr-&gt;next; ptr2 = &amp;npre; while(ptr2-&gt;next &amp;&amp; ptr2-&gt;next-&gt;val &lt; ptr-&gt;val) ptr2 = ptr2-&gt;next; ptr-&gt;next = ptr2-&gt;next; ptr2-&gt;next = ptr; // for(auto x = &amp;npre; x != NULL; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; &quot; cur: &quot; &lt;&lt; ptr-&gt;val &lt;&lt; endl; ptr = nex; &#125; return npre.next; &#125;&#125;; Accepted22/22 cases passed (48 ms)Your runtime beats 73.88 % of cpp submissions Your memory usage beats 15.9 % of cpp submissions (9.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"56.合并区间","slug":"leetcode56","date":"2020-01-11T06:50:05.000Z","updated":"2020-01-11T07:20:33.360Z","comments":true,"path":"2020/01/11/leetcode56/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode56/","excerpt":"","text":"🥛使用数组&emsp;&emsp;使用数组来进行操作，特别[0,1][2,4]这样连在一起。却没有相交的情况 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; char arr[3000] = &quot;&quot;; vector&lt;vector&lt;int&gt;&gt; res; for(auto x : intervals) &#123; memset(arr + x[0], &apos;1&apos; ,x[1] - x[0]); if(arr[x[1]] != &apos;1&apos;) arr[x[1]] = &apos;2&apos;; else arr[x[1]] = &apos;1&apos;; &#125; int count = 0, k; for(int i = 0; i &lt; 3000; ++i) &#123; if(arr[i] != &apos;\\0&apos;) &#123; count = 0; for(k = i; k &lt; 3000 &amp;&amp; arr[k] == &apos;1&apos;; ++k) &#123; arr[k] = &apos;\\0&apos;; ++count; &#125; arr[k] = &apos;\\0&apos;; res.push_back(vector&lt;int&gt;&#123;i, i + count&#125;); &#125; &#125; return res; &#125;&#125;; Accepted169/169 cases passed (20 ms)Your runtime beats 90.61 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (13.3 MB) 🚆排序后比较&emsp;&emsp; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a ,const vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0]; &#125;); // for(auto x : intervals) &#123; // cout &lt;&lt; x[0] &lt;&lt; x[1] &lt;&lt; endl; // &#125; int i = 0, beg, endx, n = intervals.size(); while(i &lt; n) &#123; beg = intervals[i][0]; endx = intervals[i][1]; while(i &lt; n - 1&amp;&amp; intervals[i + 1][0] &lt;= endx) &#123; ++i; if(intervals[i][1] &gt; endx) endx = intervals[i][1]; &#125; // cout &lt;&lt; beg &lt;&lt; &quot; &quot; &lt;&lt; endx &lt;&lt; endl; res.push_back(vector&lt;int&gt;&#123;beg, endx&#125;); ++i; &#125; return res; &#125;&#125;; Accepted 169/169 cases passed (12 ms)Your runtime beats 99.88 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (12.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"75.颜色分类","slug":"leetcode75","date":"2020-01-11T03:33:29.000Z","updated":"2020-01-11T08:13:03.417Z","comments":true,"path":"2020/01/11/leetcode75/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode75/","excerpt":"","text":"🥧典型的堆排序题目&emsp;&emsp; 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; nums.insert(nums.begin(), 0); int n = nums.size() - 1; for(int i = n / 2; i &gt;= 1; --i) &#123; sink(nums, i, n); &#125; while(n &gt; 1) &#123; swap(nums[1], nums[n--]); sink(nums, 1, n); &#125; nums.erase(nums.begin()); &#125; void sink(vector&lt;int&gt;&amp; nums, int k,int n) &#123; int j; while(k &lt;= n / 2) &#123; j = k * 2; if(nums[j] &lt; nums[j + 1] &amp;&amp; j + 1 &lt;= n) ++j; if(nums[k] &gt;= nums[j]) break; swap(nums[k], nums[j]); k = j; &#125; &#125;&#125;; Accepted87/87 cases passed (0 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 5.17 % of cpp submissions (8.9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"21.合并两个有序链表","slug":"leetcode21","date":"2020-01-11T03:18:02.000Z","updated":"2020-01-23T12:53:20.141Z","comments":true,"path":"2020/01/11/leetcode21/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode21/","excerpt":"","text":"🥛迭代&emsp;&emsp;类似与归并排序的合并函数，实际还要更简单一些，没有长度的限制 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode nd(0), *pre = &amp;nd; while(l1 || l2) &#123; if(!l1) &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; else if(!l2) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else if(l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; return nd.next; &#125;&#125;; Accepted208/208 cases passed (8 ms)Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 76.07 % of cpp submissions (9 MB) 🥛递归12345678910111213141516class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; else if(l2-&gt;val &lt; l1-&gt;val) &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; else &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; &#125;&#125;; Accepted208/208 cases passed (8 ms) Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 75.58 % of cpp submissions (9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"148. 排序链表","slug":"leetcode148","date":"2020-01-10T16:51:18.000Z","updated":"2020-01-11T06:27:48.055Z","comments":true,"path":"2020/01/11/leetcode148/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode148/","excerpt":"","text":"🥩自顶向下归并排序&emsp;&emsp;基础版，根据算法4中的数组的归并算法改得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head) return head; n = 1; ListNode* h = head; while(h-&gt;next != NULL) &#123; h = h-&gt;next; ++n; &#125; //cout &lt;&lt; &quot;count : &quot; &lt;&lt; n &lt;&lt; endl; aux = new int[n](); sortList(head, 0, n - 1); return head; &#125; void sortList(ListNode* head, int i, int j) &#123; if(i &gt;= j) return ; int mid = i + (j - i) / 2; sortList(head, i, mid); sortList(head, mid + 1, j); merge(head, i, mid, j); &#125; void merge(ListNode* head, int i,int mid, int j) &#123; //cout &lt;&lt; &quot;i,m.j : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ListNode* inode = at(head, i),* inode2 = inode; //cout &lt;&lt; &quot;inode-&gt;val: &quot; &lt;&lt; inode2-&gt;val &lt;&lt; endl; int lo = i - i, hi = mid + 1 - i; for(int k = 0; k &lt;= j - i; ++k , inode = inode-&gt;next) aux[k + i] = inode-&gt;val; // for(int k = i; k &lt;= j; ++k) &#123; //cout &lt;&lt; aux[k] &lt;&lt; &quot; &quot;; // &#125; //cout &lt;&lt; endl; for(int k = 0; k &lt;= j - i; ++k) &#123; if(lo &gt; mid - i)&#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else if (hi &gt; j - i) &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; else if (aux[lo + i] &gt; aux[hi + i]) &#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; //cout &lt;&lt; &quot;lo, hi : &quot; &lt;&lt; lo &lt;&lt; &quot; &quot; &lt;&lt; hi &lt;&lt; endl; inode2 = inode2-&gt;next; &#125; &#125; ListNode* at(ListNode* head, int n) &#123; while(n--) head = head-&gt;next; return head; &#125; int* aux; int n;&#125;; Accepted16/16 cases passed (1108 ms) Your runtime beats 5.09 % of cpp submissionsYour memory usage beats 62.56 % of cpp submissions (12.3 MB) 🥧自顶向下归并排序2&emsp;&emsp;学习自链接,以一种链表得方式来做，而不是以数组得方式来思考 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, * fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = nullptr; ListNode* left = sortList(head); ListNode* right = sortList(tmp); ListNode thead = ListNode(-1), *thd = &amp;thead; while(left || right) &#123; if(!left) &#123; thd-&gt;next = right; right = right-&gt;next; &#125; else if(!right) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else if (right-&gt;val &gt; left-&gt;val) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else &#123; thd-&gt;next = right; right = right-&gt;next; &#125; thd = thd-&gt;next; &#125; return thead.next; &#125; &#125;; Accepted 16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 72.66 % of cpp submissions (11.9 MB) 🥣自底向上归并排序&emsp;&emsp;学习自链接，自底向上得链表，有几个难点: 如何每次merge后与后面得链表接上 如何串联成一个长得链表最后返回1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* preNode = new ListNode(0), *pre = preNode; pre-&gt;next = head; int count = 0; while((pre = pre-&gt;next) &amp;&amp; ++count) ; // cout &lt;&lt; &quot;count : &quot; &lt;&lt; count &lt;&lt; endl; pre = preNode; for(int sz = 1; sz &lt; count; sz *=2) &#123; while(pre = sortList(pre, sz)) ; pre = preNode; &#125; return preNode-&gt;next; &#125; ListNode* sortList(ListNode* pre, int sz) &#123; ListNode* fl = pre-&gt;next, *ll = pre-&gt;next; for(int i = 0; i &lt; sz ; ++i) &#123; if(!ll) return nullptr; ll =ll-&gt;next; &#125; int lc = 0, fc = 0; while(fc &lt; sz) &#123; if(lc == sz || ll == nullptr || ll-&gt;val &gt; fl-&gt;val) &#123; ++fc; pre-&gt;next = fl; fl = fl-&gt;next; &#125; else &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; &#125; pre = pre-&gt;next; &#125; while(lc &lt; sz &amp;&amp; ll) &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next = ll; return pre; &#125;&#125;; Accepted16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 93.48 % of cpp submissions (11.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"堆排序","slug":"alg4","date":"2020-01-10T14:59:59.000Z","updated":"2020-01-10T15:32:32.295Z","comments":true,"path":"2020/01/10/alg4/","link":"","permalink":"http://yoursite.com/2020/01/10/alg4/","excerpt":"","text":"😘代码实现123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 堆排序 **/template&lt;typename T&gt;class HeapSort &#123; public: static void sort(vector&lt;T&gt;&amp;); private: static void sink(vector&lt;T&gt;&amp; a, int k, int N);&#125;;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123; int N = a.size() - 1; for(int i = N / 2; i &gt;= 1; --i) sink(a, i, N); while(N &gt; 1) &#123; swap(a[1], a[N--]); sink(a, 1, N); &#125;&#125;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123; int j; while(k &lt;= N / 2) &#123; j = 2 * k; if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j; if(a[k] &gt;= a[j]) break; swap(a[k], a[j]); k = j; &#125;&#125; 👿注意 要注意父节点只有一个子节点时的情况，在sink函数中（if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;）一定要注意j&lt;N，不能超出范围 构造最大堆时，for循环从i = N / 2开始的原因是：sink中有限制条件while(k &lt;= N / 2)，所以N/2&lt;i&lt;N部分无法进入sink的while循环，是没有意义的，徒增N/2次比较 递增排序使用最大堆，递减排序使用最小堆 vector的第一个值（下标为0）不使用","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"索引优先队列","slug":"alg3","date":"2020-01-10T08:36:33.000Z","updated":"2020-01-10T14:28:54.460Z","comments":true,"path":"2020/01/10/alg3/","link":"","permalink":"http://yoursite.com/2020/01/10/alg3/","excerpt":"","text":"🥛分析12345678910111213141516public class IndexMaxPQ...&#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i//中间省略...public void insert(int i, Key key) &#123; ... n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n);&#125; &emsp;&emsp;根据《算法4》给出的代码，分析这两段代码我们可以看出来： 在定义处可知pq是二叉堆的数组 由qp[i] = n;pq[n] = i;可以看出来，qp这个数组的用处就是为了记录**pq中值为i的下标是多少**，这样当我们要改下标为i的元素的值时，我们就不用遍历pq来获得位置了，**用空间来换取时间** 并且这个索引i仅仅为了找到元素对象key，并没实际的意义。n才是对应二叉堆的位置。 😍代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * 索引最小优先队列 **/ template&lt;typename T&gt;class IndexMinPQ &#123; public: IndexMinPQ(int max); void show() const; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125; void insert(int k, T item); void change(int k, T item); bool contain(int k) const &#123;return qp[k] != -1;&#125;; int delMin(); private: void sink(int i); void swim(int i); T* element; //元素 int* pq; //二叉堆 int *qp; //index int N; int _capacity;&#125;;template&lt;typename T&gt;IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) : element(new T[max + 1]), pq(new int[max + 1]) , qp(new int[max + 1]), N(0), _capacity(max) &#123; for(int i = 0; i &lt; max + 1; ++i) qp[i] = -1;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::sink(int n)&#123; while(n &lt; N) &#123; int m = n * 2; if(element[pq[m]] &gt; element[pq[m + 1]]) ++m; if(element[pq[m]] &lt; element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::swim(int n) &#123; while(n &gt; 1) &#123; int m = n / 2; if(element[pq[m]] &lt;= element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123; // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; if(capacity() == size())&#123; cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl; return ; &#125; pq[++N] = k; element[k] = item; qp[k] = N; swim(N); // show();&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::show() const&#123; cout &lt;&lt; &quot;pq: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;qp: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;element: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123; if(!contain(k)) &#123; cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl; return ; &#125; T old_one = element[k]; element[k] = item; if(item &gt; old_one) sink(qp[k]); else if(item &lt; old_one) swim(qp[k]);&#125;template&lt;typename T&gt;int IndexMinPQ&lt;T&gt;::delMin() &#123; int max = pq[1]; swap(pq[1], pq[N]); swap(qp[pq[1]], qp[pq[N]]); --N; show(); sink(1); show(); qp[max] = -1; element[max] = -1; pq[N + 1] = -1; return max;&#125;int main(int argc, char** argv) &#123; IndexMinPQ&lt;int&gt; pq(6); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6); for(size_t i = 0; i &lt; v.size(); ++i) &#123; pq.insert(i + 1, v[i]); &#125; pq.show(); pq.delMin(); pq.show(); return 0;&#125; 🍠参考资料：链接","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"优先队列","slug":"alg2","date":"2020-01-10T07:57:40.000Z","updated":"2020-01-10T08:36:50.374Z","comments":true,"path":"2020/01/10/alg2/","link":"","permalink":"http://yoursite.com/2020/01/10/alg2/","excerpt":"","text":"🍠优先队列的实现有三种： 有序数组 无序数组 堆 🍅有序数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * 优先队列 * 2.4.3 有序数组实现 **/ template&lt;typename T&gt;class OrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit OrderArrayMaxPQ(int max); ~OrderArrayMaxPQ() &#123;delete [] arr;&#125; // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;// template&lt;typename T&gt;// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) // : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())// &#123;// copy(l.begin(), l.end(), arr);// &#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x; for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i) swap(arr[i], arr[i - 1]); &#125;template&lt;typename T&gt;pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; res = arr[N - 1]; arr[--N] = pair&lt;int , T&gt;(); return res;&#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; OrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥦无序数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * 优先队列 * 2.4.3 无序数组实现 **/ template&lt;typename T&gt;class UnOrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit UnOrderArrayMaxPQ(int max); ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125; explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())&#123; copy(l.begin(), l.end(), arr);&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x;&#125;template&lt;typename T&gt;pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123; if(isEmpty()) return pair&lt;int, T&gt;(); int max_one = 0; for(int i = 0; i &lt; N; ++i) if(arr[max_one].first &lt; arr[i].first) &#123; max_one = i; &#125; swap(arr[max_one], arr[--N]); pair&lt;int,T&gt; res = arr[N]; arr[N] = pair&lt;int,T&gt;(); return res;&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; UnOrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥧堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * 优先队列 * 二叉堆实现 **/ template&lt;typename T&gt;class MaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; void swim(int i); void sink(int i); public: void show() const ; explicit MaxPQ(int max); ~MaxPQ() &#123;delete [] arr;&#125; void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;MaxPQ&lt;T&gt;::MaxPQ(int max) : arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)&#123; arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[++N] = x; swim(N);&#125;template&lt;typename T&gt;pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; swap(arr[N--], arr[1]); res = arr[N + 1]; arr[N + 1] = pair&lt;int ,T&gt;(); sink(1); return res;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 1; i &lt;= N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::swim(int i) &#123; while(i &gt; 1) &#123; if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]); i /= 2; &#125;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::sink(int i) &#123; int k; while(i &lt; N) &#123; k = 2 * i; if(arr[k].first &lt; arr[k + 1].first) ++k; if(arr[k].first &lt;= arr[i].first) break; swap(arr[k], arr[i]); i = k; &#125;&#125;int main(int argc, char** argv) &#123; MaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); // pq.show(); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥨时间复杂度对比 有序数组： 插入：N，删除：1 无序数组： 插入：1，删除：N 堆：插入、删除：lgN 理想情况：都是1","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"为甚么异或能够确定两个数的符号是否相同？","slug":"problems2","date":"2020-01-08T14:28:49.000Z","updated":"2020-01-08T15:06:10.423Z","comments":true,"path":"2020/01/08/problems2/","link":"","permalink":"http://yoursite.com/2020/01/08/problems2/","excerpt":"","text":"12unsigned int a = -1;printf(&quot;%d,%u,%x&quot;,a,a,a); -1,4294967295,ffffffff从结果上来说,验证了C++中使用的是补码。 🍠现在说一说为什么异或能够确定两个数的符号是否相同？&emsp;&emsp;这里还有一个前提，两个数都是int类型，因为补码的原因，如果两个数的正负不同，那么它们的第一位就不同，因为int的第一位是正负的标志位。通过异或，那么正数的第一位为0，负数的第一位为1，异或后第一位就为1，所以可以得到计算出的值为负值。相反如果两者符号相同，那么通过异或后，第一位就为0，所以为正数。","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"二分查找","slug":"alg1","date":"2020-01-07T14:24:36.000Z","updated":"2020-01-08T13:56:04.220Z","comments":true,"path":"2020/01/07/alg1/","link":"","permalink":"http://yoursite.com/2020/01/07/alg1/","excerpt":"","text":"时间复杂度logN 二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的😜递归式 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123; // if(lo &gt; ho) return -1; // int mid = (lo + ho) / 2; // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key); // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); // else return mid; if(lo &gt;= ho) return -1; int mid = (lo + ho) / 2; if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key); else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); else return mid;&#125; &emsp;&emsp;区间的开闭自由选取，主要是要统一，如果要求传入左闭右开区间，那么在函数内部的处理也要保持左闭右开。一般的选择应该时左右都是闭区间，而在特殊情况时（数组中有多个相同的目标时），这时选择左闭右开。🥛参考：wiki链接&emsp;&emsp;为了避免ho + lo 大于INT_MAX最好改用lo + (ho - lo) / 2 🈶非递归式 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123; int lo = 0, ho = a.size(), mid; while(lo &lt; ho) &#123; mid = (lo + ho) / 2; if(a[mid] &gt; key) ho = mid; else if(a[mid] &lt; key) lo = mid + 1; else return mid; &#125; return -1;&#125; 递归要满足三个原则： 递归总有一个最简单的情况—方法的第一句总是一个包含return的条件语句。 递归调用总要尝试取解决一个规模更小的子问题。 递归调用的父问题和子问题之间不应该有交集。 🥘推荐相关资料：讲解 👍练习题目1：4. 寻找两个有序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //首先要判定拿个序列更加长 if(nums1.size() &gt; nums2.size()) swap(nums1, nums2); //左闭右开 int imin = 0, imax = nums1.size(), j, i, m = nums1.size(), n = nums2.size(), halflen = (m + n + 1) / 2; while(imin &lt;= imax) &#123; i = (imax + imin ) / 2; j = halflen - i; // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; imin = i + 1; &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; imax = i; &#125; else &#123; // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; int leftMax, rightMin; if(i == 0 ) leftMax = nums2[j - 1]; else if(j == 0) leftMax = nums1[i - 1]; else leftMax = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2) return leftMax; if(i == m) rightMin = nums2[j ]; else if (j == n) rightMin = nums1[ i ]; else rightMin = min(nums1[i], nums2[j]) ; // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl; return static_cast&lt;double&gt;(leftMax + rightMin) / 2; &#125; &#125; return -1; &#125;&#125;; 👍练习题目2：35. 搜索插入位置12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, ho = nums.size() - 1, mid; while(lo &lt; ho) &#123; mid = (lo + ho + 1) / 2; if(nums[mid] &gt; target) &#123; ho = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; if(nums[lo] &lt; target) return lo + 1; else return lo; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"libuv源码分析（6）uv_queue_work","slug":"libuv6","date":"2019-11-26T12:06:58.000Z","updated":"2019-11-26T12:56:52.025Z","comments":true,"path":"2019/11/26/libuv6/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv6/","excerpt":"","text":"🏤问题来由&emsp;&emsp;在使用libuv的过程中，我们难免遇见的一个问题是，有一些库没有异步、只能同步运行，这种情况该怎么办呢？比如mysql-connector-cpp。 &emsp;&emsp;首先要说的是，直接在回调函数中执行mysql-connector-cpp这种会阻塞的操作是不符合Libuv的reactor模式的。 123456void handle_json_lab(std::shared_ptr&lt;smpHttp::HttpRequest&gt; req,std::shared_ptr&lt;smpHttp::HttpResponse&gt; res) &#123; try&#123; Session mq = cli.getSession(); auto sqlres = mq.sql(\"Select content FROM labimformation where type = 'labIntroduction'\").execute(); ... &emsp;&emsp;上面这样便是错误的案例。我在写这个项目时，之前就采用了这样的错误做法。&emsp;&emsp;我的这个项目是个http后台，我在接受到POST请求，直接在回调函数中执行mysql操作，这时整个主线程就阻塞住了1，而这就意味着我的http后台不再能接受任何请求，只能等待mysql操作完成后，回调函数返回。而这个mysql的操作耗时一般在3s以上，这对我这个Http后台来说是毁灭性的打击。。。。 1：用户的回调函数是在work->done函数的最后执行的，而work->done是在主线程uv_run中的is_poll中唤醒loop->wq_async后执行的,在work->done函数中阻塞意味着在主线程阻塞住了，uv_run中的事件循环卡住，不再能接受request（这部分不清楚可以去看我的libuv源码分析文章） 🌆解决办法&emsp;&emsp;在手册Thread pool work scheduling中为我们这样的需求提供了这样一个函数：uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)。 &emsp;&emsp;这个函数就是上面我们问题的解决办法。但是要注意的是uv_async_t不可以替代这个。虽然都是执行用户的函数。async是让用户函数直接被主线程在uv_run中运行，而uv_queue_work是将work_cb提交给子线程执行，完成后通知主线程，主线程在uv_run中执行after_work_cb。 &emsp;&emsp;总结下来就是：uv_async_t用来执行不阻塞的任务，uv_queue_work执行要阻塞的任务（考虑到线程切换的消耗一般不用来执行不阻塞的任务） 🉐看看源码&emsp;&emsp;这一部分可以结合这我的这篇文章-libuv源码分析（5）uv_fs_*来看。可以作为佐证，libuv中对着这类没有自带异步版本的阻塞操作的处理是一样的：让子线程去执行这个任务，避免阻塞主线程的事件循环，完成后子线程通知主线程。uv_queue_work源码： 123456789101112131415161718int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) &#123; if (work_cb == NULL) return UV_EINVAL; uv__req_init(loop, req, UV_WORK); req-&gt;loop = loop; req-&gt;work_cb = work_cb; req-&gt;after_work_cb = after_work_cb; uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, uv__queue_work, uv__queue_done); return 0;&#125; 再结合我的这篇文章-libuv源码分析（5）uv_fs_*中uv_fs_*函数的源码，这些操作可以总结成以下代码： 12345678UV_REQ_INIT(req, typ); //初始化基类uv_req_t uv__req_register(loop, req); //添加loop中request的计数，避免uv_run中uv__loop_alive返回0，使得主线程uv_run退出...//这里是针对不同类型的操作特有的初始化部分uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, //操作类型 uv__queue_work, //要阻塞的操作，在fs中是uv__fs_work uv__queue_done); //完成后的回调，在fs中是uv__fs_done","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（5）uv_fs_*","slug":"libuv5","date":"2019-11-25T18:57:15.000Z","updated":"2019-11-25T19:41:02.563Z","comments":true,"path":"2019/11/26/libuv5/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv5/","excerpt":"","text":"uv_fs_*&emsp;&emsp;uv_fs_*这一系列的函数基本是一致的，它们的逻辑大概是如下： 123456//x代表一种操作open、write等int uv_fs_x(...uv_fs_t* req...) &#123; INIT(x); //uv_fs_t和其基类uv_req_t的基本初始化 ... //这里是每个操作各自不同对于req的初始化 POST; //提交这个任务&#125; INIT&emsp;&emsp;INIT这个宏定义函数没有特别的地方，就是把req初始化，该置0的置0。 POST&emsp;&emsp;其实现如下： 1234567891011121314151617#define POST do &#123; //dowhile包裹作用域 if (cb != NULL) &#123; uv__req_register(loop, req); uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_FAST_IO, uv__fs_work, uv__fs_done); return 0; &#125; else &#123; uv__fs_work(&amp;req-&gt;work_req); return req-&gt;result; &#125; &#125; while (0) &emsp;&emsp;这里通过有无回调函数来决定调用同步版本还是异步版本。 http://docs.libuv.org/en/v1.x/fs.htmllibuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously. &emsp;&emsp;uv__fs_work这个函数就是文件操作的封装，所有的文件操作都通过这个函数来完成，即使是异步，最终也要在别的线程中同步执行这个函数。 &emsp;&emsp;uv__fs_done这个函数会调用用户给的回调函数，这个函数会在uv_run中的is_poll函数中得到执行。 &emsp;&emsp;uv__work_submit函数的实现是这样的： 12345678910void uv__work_submit(uv_loop_t* loop,struct uv__work* w,enum uv__work_kind kind, void (*work)(struct uv__work* w),void (*done)(struct uv__work* w, int status)) &#123; uv_once(&amp;once, init_once); w-&gt;loop = loop; w-&gt;work = work; w-&gt;done = done; post(&amp;w-&gt;wq, kind);&#125; &emsp;&emsp;uv_once(&amp;once, init_once);是初始化多个线程，我在我的第三篇文章中有介绍。不过当时对于子线程运行的worker函数没有提及，work函数大概是这样的： 123456789101112131415161718192021222324252627282930static void worker(void* arg) &#123; ... uv_mutex_lock(&amp;mutex); for (;;) &#123; while (QUEUE_EMPTY(&amp;wq)...) &#123; idle_threads += 1; uv_cond_wait(&amp;cond, &amp;mutex); idle_threads -= 1; &#125; q = QUEUE_HEAD(&amp;wq); ... QUEUE_REMOVE(q); QUEUE_INIT(q); ... w = QUEUE_DATA(q, struct uv__work, wq); w-&gt;work(w); uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex); w-&gt;work = NULL; QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); uv_async_send(&amp;w-&gt;loop-&gt;wq_async); uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); uv_mutex_lock(&amp;mutex); ... &#125;&#125; &emsp;&emsp;我去掉了对于slow_io的处理，大致是这样一个过程。 &emsp;&emsp;一开始线程会卡在uv_cond_wait这里，直到被uv_cond_signal唤醒，如果唤醒时wq队列中有任务，它就会执行任务，w-&gt;work(w)也就是调用uv__fs_work。然后把w放入loop-&gt;wq（为了uv__fs_done的执行）。 &emsp;&emsp;uv_async_send调用让loop-&gt;wq_async可读，主线程就从uv_run中的uv__io_poll的epoll_pwait中醒来，wq_async的回调函数会遍历loop-&gt;wq执行w-&gt;done。（我的第四篇文章有讲这一部分的详细内容） 谁来触发uv_cond_signal唤醒子线程呢？🥣uv__work_submit中的post函数： 123456uv_mutex_lock(&amp;mutex);...QUEUE_INSERT_TAIL(&amp;wq, q);if (idle_threads &gt; 0) uv_cond_signal(&amp;cond);uv_mutex_unlock(&amp;mutex); &emsp;&emsp;我再次省略了slow_io的部分，因为它们只是特殊处理。 &emsp;&emsp;该函数有空闲的线程就唤醒，不然就阻塞该线程。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（4）async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-25T19:24:48.508Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuv中async的开端在uv_loop_init函数中： 12345678//前面省略err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//后面省略 &emsp;&emsp;loop-&gt;wq_async是个uv_async_t类型，它用于线程work函数调用最后处理loop-&gt;wq中的回调，暂时不用管,我在我的第五篇文章会讲到它的用途。&emsp;&emsp;我们来看uv_async_init内部： 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;第五行以后的操作就是初始化基类uv_handle_t以及子类uv_async_t，然后将这个handle放入loop-&gt;queue(放uv_handle_t的队列)以及放入loop-&gt;async_handles（放uv_async_t的队列）中，然后uv__handle_start中将loop-&gt;active_handles加一。&emsp;&emsp;总而言之，第五行以后的内容就是初始化uv_async_t，可以理解成uv_async_t的构造函数。&emsp;&emsp;uv__async_start则不一样，它是初始化函数，它只会调用一次（一般情况是在uv_loop_init中调用），我们先看下它的实现： 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //中间省略 uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;看第三行loop-&gt;async_io_watcher.fd，当你调用过一次这个函数后，loop-&gt;async_io_watcher.fd不会等于-1，以后你初始化uv_async_t类型变量，调用uv_async_init函数时，uv__async_start都是直接返回的。&emsp;&emsp;我省略掉了中间如果eventfd没有在当前系统下实现时的兼容性处理。总的来说，就是初始化loop-&gt;async_io_watcher。uv__io_t是为epoll设计的结构体。这里你肯定感觉很懵逼，请坚持一下，最后我会梳理一下总体的整个过程。&emsp;&emsp;uv__io_t的实现是这样的： 12345678uv__io_t&#123; uv__io_cb cb; //回调函数 void* watcher_queue[2]; //放入loop-&gt;watcher_queue void* pending_queue[2]; //同理 unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //文件描述符，用于epoll注册&#125; &emsp;&emsp;这里uv__io_init函数是初始化loop-&gt;async_io_watcher这个结构体： 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //前面我们的eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_start将loop-&gt;async_io_watcher放入loop-&gt;watcher_queue。还有对于loop-&gt;nfds大小的处理。 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;第四行以后的操作是为了在epoll后，我们得到struct event结构体，我们从event-&gt;data.fd可以得到fd，那我们如何获取到对应的uv__io_t呢？ 就是通过loop-&gt;watchers这个数组。 uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCE： 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;这里调用一次ACCESS_ONCE，是为了告诉编译器，handle-&gt;pending可能被其他线程修改，所以别给我乱优化。&emsp;&emsp;cmpxchgi是原子操作compare_and_change。pending的有三个取值0，1，2。0代表闲置、1代表忙（比如uv_async_send调用途中）、2代表完成。loop-&gt;async_io_watcher调用uv__async_io时，会遍历loop-&gt;async_handles，通过pending来判断哪些回调该被执行。&emsp;&emsp;uv__async_send就是向loop-&gt;async_io_watcher.fd（eventfd）写（这里关系到eventfd的机制，不懂可以man eventfd）。 整体调用过程&emsp;&emsp;这里总体归纳一下async的过程。&emsp;&emsp;1.在loop_uv_init中初始化async_io_watcher，它的fd为eventfd，值为0，不可读。&emsp;&emsp;2.用户uv_async_init注册uv_async_t变量，被添加到loop-&gt;async_handles，设置回调函数。&emsp;&emsp;3.如果对uv_async_t变量调用uv_async_send，那么uv_async_t变量的pending变为2（done），并且向eventfd写，loop-&gt;async_io_watcher可读了。&emsp;&emsp;4.在uv_run的uv__io_poll中，每次都会把loop-&gt;watchers注册到epoll中，第四步这个过程在每次事件循环中都在执行。如果async_io_watcher的fd不可读，就没它事儿。如果可读，async_io_watcher的回调函数uv__async_io执行，它遍历loop-&gt;async_handles，将其中pending为2的uv_async_t变量移除队列，并执行其回调函数。 看源码后写的小DEMO： https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config 你会发现这是一个新文件，在其中添加以下文字： 123456Host github.comUser 你的用户名（例如97860xx@qq.com）Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后保存退出（代码如下）。 1:wq 接下来测试一下： 1ssh -T git@github.com 出现下面的画面：在图片倒数第五行的地方会询问是否建立连接，输入yes即可。","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuv源码分析（3）init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"由来&emsp;&emsp;在我们第一次提交io操作时，会有uv_once被调用，来检测是否初始化过线程池，如果没有则立刻初始化线程池。所以说线程池并非一开始在uv_run的时候或者在loop中初始化的，而是在io操作开始前。我以uv_open为例子画一下UML图如下：在uv_open中先初始化req，然后准备提交work，提交前会调用uv_once检测是否初始化线程池，没有则初始化。 init_onceuv_once实现如下： 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; 在uv__work_submit中uv_once是这样被调用的： 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;这一部分可以参看TLPI 31.2部分，libuv多做了pthread_atfork的处理。&emsp;&emsp;pthread_atfork注册reset_once函数，在fork之后重置once，保证在libuv循环中如果你fork了一个进程，如果在那个新的进程中你也启动一个libuv，init_threads()能被调用。 init_threads🐤条件变量&emsp;&emsp;libuv初始化条件变量时，调用自己的uv_cond_init，这个函数只做了一件事情，就是将条件变量的时钟设置为相对时间，这一点是值得我们自己写代码时参考的，相对时间不受系统时间的影响。 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; 🥛互斥锁&emsp;&emsp;初始化互斥锁时，调用uv_mutex_init，在DEBUG时，libuv会将互斥锁设置为PTHREAD_MUTEX_ERRORCHECK，这样能自我检测是否为死锁，不过这会消耗性能，所以在运行时设置为默认值。 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. 🥡信号量&emsp;&emsp;初始化每个线程时，libuv用信号量来保证init_threads函数在初始化完所有线程后退出。 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); 在linux下并且glibc版本大于2.21时，uv_sem_init(&amp;sem, 0)和sem_init(&amp;sem, 0)是一样的，没有额外的处理。线程创建好后，在worker函数中会调用uv_sem_post释放信号量。 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; 🥚uv_thread_create&emsp;&emsp;uv_thread_create做的事情就是设置线程的stack大小，然后创建它。thread_stack_size函数获取栈大小，有一些是跨平台兼容性的处理。 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); 和if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; 上面两行的限制是来源于pthread_attr_setstacksize函数，一下是pthread_attr_setstacksize函数man手册的一部分。 ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif 😂无趣的是在linux Ubuntus我的环境下测试时，attr的默认stacksize和thread_stack_size函数设置到的是一样的值。下面是我的测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（2）uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"前言&emsp;&emsp;上一篇说了一下整体的事件循环，对于UV_RUN_DEFAULT模式来调用uv_run来说，uv__loop_alive就决定了是否退出，这一篇看一下uv__loop_alive的源码。 详情12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;可见loop的状态取决于三个方面：handles、reqs、closing_handles handles&emsp;&emsp;uv__has_active_handles就是检查loop-&gt;active_handles值是否大于0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handles列表如上。handle在调用时，会包含一个函数的调用，就是uv__handle_start。下图所示，是哪些函数调用了uv__handle_start。有一些handle不在其中，可能与其调用方式有关，我暂时无法解释 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_start函数在调用时，会调用uv__active_handle_add，uv__active_handle_add就是将loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;相应的在handle结束时有uv__active_handle_rm的调用，(h)-&gt;loop-&gt;active_handles减一。 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqs和handle的道理一样，是检测(loop)-&gt;active_reqs.count &gt; 0。active_reqs是个共用体，它的另一个用途暂时我还不知道。 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)等同于handle的uv__active_handle_add。uv__req_register在uv__req_init中调用，几乎（漏网的暂时没法解释 ）每个req在初始化时都调用了uv__req_init。 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;下图所示是那些函数调用了uv__req_init，由名称我们可以看出来它们是属于哪些req的。&emsp;&emsp;同理，还有uv__req_unregister。 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;要关闭的handle会以链表的形式挂在loop-&gt;closing_handles上。这个操作通过调用uv__make_close_pending来实现。 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; 如果closing_handles不为空，那么还需要进入事件循环，去调用关闭的handle的回调函数。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（1）事件循环分析","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"前言 &emsp;&emsp;libuv总是报出一些让人难以理解的错误😂，作为一个C的项目，不具有Java、JavaScript、php那样的人气，很难百度到一些问题的答案，甚至google也不行。为了用好libuv，也为了学习吧。我开始看libuv的源码，不知道自己能走多远。。。 事件循环 这是官方事件循环的示意图。链接-&gt;官方图片位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;整个事件循环就是在主线程的uv_run（）调用中执行的。我就跟着官方的介绍一步一步来看（官方介绍）。 第一步 The loop concept of ‘now’ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;第一步是更新时间。对应代码如下： 1uv__update_time(loop); &emsp;&emsp;总结来说就是调用这个函数，更新时间。uv__update_time实现我下一篇来介绍 第二步 If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and ref’d handles, active requests or closing handles it’s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;用uv__loop_alive函数获取loop状态。&emsp;&emsp;如果uv__loop_alive返回零或者loop-&gt;stop_flag == 1说明loop终止，直接跳过循环，到代码最下面（这里有一些性能的处理暂时不管 ），退出： 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0的一个来源是调用了uv_stop，这个函数在手册中看见。它的源代码也很清晰。 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;如果loop状态OK，那么就进入循环中。 第三步 Due timers are run. All active timers scheduled for a time before the loop’s concept of now get their callbacks called. &emsp;&emsp;对应代码这一部分： 1234567891011121314151617181920uv__run_timers(loop);其实现：void uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;将堆里面已经超时的拿出来运行。 第四步 Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. 对应： 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);其实现：static int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;将loop-&gt;pending_queue中的任务拿出来运行。 第五、六、九步 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;这三部为什么要一起说呢？因为它们的实质是一样的。在每次循环固定的位置调用。&emsp;&emsp;这三个函数定义在loop-watcher.c这个文件里面，它们是用宏定义定义的。只改了idle、prepare、check这三个名字的部分，其余部分函数都是一样的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) 第七步 Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;这部分是取决于uv_run的模式的特殊处理，暂时不细看。 第八步 The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;这一部分对于不同操作系统有所不同，linux是poll，mac是kqueue。 第十步 Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;调用各类的close回调函数。 第十一、十二步 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if it’s still alive, otherwise it will also end. &emsp;&emsp;对于uv_run不同模式的一点特殊处理。 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; 小结&emsp;&emsp;宏观上梳理一下整个事件循环的过程。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"redis基数树rax源码分析(2.5)","slug":"rax3","date":"2019-08-14T10:40:51.000Z","updated":"2019-11-25T19:51:03.317Z","comments":true,"path":"2019/08/14/rax3/","link":"","permalink":"http://yoursite.com/2019/08/14/rax3/","excerpt":"","text":"点点废话&emsp;&emsp;最近没有再将rax的源码往下看，rax对于一个新手来说还是体量过大，在尝试自己写写，在写的时候遇到了一些坑，也体会到了rax的一些写法的精妙之处，记录一下。 宏定义函数的注意点：&emsp;&emsp;我定义了这样一个宏定义函数： 12#define radixNthChild(h, n) \\ (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*)) 我这样调用这个函数： 1radixNthChild(new_cur, new_cur-&gt;size - 1) 这样一个调用大家觉得有问题吗？嗯，肯定是有问题的，不然我说啥?。 这里，按照我们一般的调用函数的思路，这样一个调用的运行过程是这样的： 计算出new_cur-&gt;size - 1 带入radixNthChild函数 实际上恰恰相反，宏定义的处理在预编译时（g++ -E），宏定义是将对于的定义替换掉，所以在预编译后的结果如下： 12# 363 &quot;radix_tree.c&quot; memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*)); 可以看到是 ： + new_cur-&gt;size - 1 * sizeof(void)而不是我所想的： + （new_cur-&gt;size - 1） * sizeof(void) 可以得出其过程其实是： 函数宏定义替换 运行时计算 结论： 在宏定义函数调用时注意括号的问题，不加括号可能会由于运算符优先级而 导致表达式意义与我们想的有出入? 地址运算注意点先给出这样一个结构体： 123struct test &#123; void* a, *b, *c;&#125;; int main(void) { cout &lt;&lt; sizeof(test) &lt;&lt; endl; test* p = new test; fprintf(stdout, &quot;%p:%p:%p:%p\\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1); return 0; }&emsp;&emsp;在这样一个测试代码中，大家觉得p + 1, (char)p + 1, (int)p+1这三个结果，相对于p的数值相差多少呢？&emsp;&emsp;运行结果是这样的。类型与地址的运算是有着密切关系的。 p + 1是一个默认情况， 这时1的意义是一个p的地址宽度 (char*)p + 1，p被解释为char类型指针，指向的地址被解释为char，于是1就是一个char的地址宽度。 总结： 在计算地址时，要注意运算符左边值的类型。你加上的1可能并不是一个字节的大小。 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redis基数树rax源码分析(2)","slug":"rax2","date":"2019-08-12T10:51:18.000Z","updated":"2019-11-25T19:49:43.833Z","comments":true,"path":"2019/08/12/rax2/","link":"","permalink":"http://yoursite.com/2019/08/12/rax2/","excerpt":"","text":"今天我想要说的是rax中的padding这个函数，我查了很多的资料，大家的博客都告诉我们内存对齐提高性能，却没有去分析为什么，是有根据让作者选择这样做？如果只是这样简单的放过，总感觉让人有一丝的遗憾。 &emsp;&emsp;先把主角拉出来： 12#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1)) &emsp;&emsp;首先要说的是raxPadding的作用是：让raxNewNode申请的内存nodesize是8的倍数。 123456789101112raxNode *raxNewNode(size_t children, int datafield) &#123; size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+ sizeof(raxNode*)*children; if (datafield) nodesize += sizeof(void*); raxNode *node = rax_malloc(nodesize); if (node == NULL) return NULL; node-&gt;iskey = 0; node-&gt;isnull = 0; node-&gt;iscompr = 0; node-&gt;size = children; return node;&#125; 第一个问题：对齐的优势&emsp;&emsp;这个并不是我想说的重点，这里是大家都谈到的，也就是经过内存对齐之后，CPU的内存访问速度大大提升。对于我来说，这个结论感觉还是太模糊，这是一个定性的结论，具体的底层细节对于我们初学者来说倒是没必要去深究。 第二个问题：为什么要这么去做？&emsp;&emsp;rax的作者这样的做法其实是参考结构体的做法。举个例子： 123456struct X&#123; char a; int c; double b;&#125;S2; 这样一个结构体，它的大小是多少？答案是16。在c语言的内部，做了这样的内存对齐处理： 这里转载了这篇文章中的很多资源，大家也可以去看看这篇文章，写的很不错。也有更多例子。 回到rax上来&emsp;&emsp; 在rax的raxNode这个结构体中，因为使用了柔性数组，所以在c语言本身是无法帮助我们实现像上面一样的内存对齐的（sizeof(raxNode) == 4,我们申请的内存大小决定了柔性数组的长度，详情请百度柔性数组） ，c语言对于结构体的优化没有包含柔性数组这个部分，所以我们必须自己来接管这一部分的内存对齐，保证程序的运行效率。 typedef struct raxNode { uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; /* Number of children, or compressed string len. */ unsigned char data[]; } raxNode; 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redis基数树rax源码分析(1)","slug":"rax1","date":"2019-08-11T16:11:44.000Z","updated":"2019-11-25T19:48:25.184Z","comments":true,"path":"2019/08/12/rax1/","link":"","permalink":"http://yoursite.com/2019/08/12/rax1/","excerpt":"","text":"&emsp;&emsp;最近想用libuv写个http服务器，看到了这个开源项目haywire，在看到第39次提交的时候，作者用基数树来存储不同路由的controller，不过在后续版本中改为了使用hash，不过想来不如正好学学基数树，作者使用的基数树是这个版本radix_tree，这个版本缺少注释，且和一般思路不一样的使用的是二叉树而非N叉树，为了理解方便，我选择了注释较多的rax 数据结构&emsp;&emsp;首先要提到的是rax的数据结构设计： 1234567typedef struct raxNode &#123; uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; / unsigned char data[];&#125; raxNode; 这里第一个要说到的点是：你觉得这样一个数据结构的大小是多少？24？ 16？ 还是8？&emsp;&emsp;第一个原因是位域，也就是结构体中的冒号： ，冒号在这里声明实际需要使用的位数，iskey，isnull，iscompr，size四个一共加起来32位，占4个字节。&emsp;&emsp;第二个原因是data[]占0个字节。unsigned char data[];这样一个结构在这里并不是理解成一个指针8个字节。而是一个柔性数组的概念，实现一个可变长度。data[1]占结构体1个字节，data[2]占结构体2个字节…….data[13]占13个字节。数组类型的内存是结构体中直接分配的，而不是像指针一样需要我们后来分配。如下图可见： 12345678910typedef struct raxNode &#123; unsigned char data[13];&#125; raxNode;int main(int argc, char *argv[])&#123; printf(&quot;%d\\n&quot;, sizeof(raxNode)); return 0;&#125; data[]&emsp;&emsp;接下来我们还是要谈data，在这里data的意义并不是一个简单的unsigned char数组，它存储的是键值key和radixNode指针两种变量。图来自：https://my.oschina.net/yunqi/blog/3039132data的实际使用方式在大多数时候是以内存地址的方式进行的。 123456#define raxNodeLastChildPtr(n) ((raxNode**) ( \\ ((char*)(n)) + \\ raxNodeCurrentLength(n) - \\ sizeof(raxNode*) - \\ (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \\)) &emsp;&emsp;这是访问最后一个节点的函数（也就是访问图中的A-ptr）。n是一个raxNode*指针，对这个指针指向的地址进行＋操作来得到最后一个节点的地址。 节点的表示图来自：https://my.oschina.net/yunqi/blog/3039132&emsp;&emsp;假设基数树中有“abcd”这个键值的节点。那么它的表示形式是像上图这样的。“abcd”这个节点的value-data存储在图片下半部分的节点处，并且下面一个节点iskey设为1.&emsp;&emsp;为什么不是直接只有图片的上半部分，由图片上半部分那个节点将iskey设置为1并且将值存储在其value·data中呢？像这样： [iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr] 先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。原因很简单：在这个例子里面，这是一个没有压缩的节点，这一层由a和A两个子节点，如果在当前层次表示，如何分辨你指定的是a还是A？所以用引出子节点来表示。 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}]}