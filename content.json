{"meta":{"title":"lurenaaã®blog","subtitle":"","description":"","author":"ä¸¤å¤©å®‡å®™äºº","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨** å¯èƒ½æ˜¯è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«åˆ é™¤"},{"title":"å…³äº","date":"2020-01-22T12:56:46.590Z","updated":"2020-01-22T12:56:46.590Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"é‡åº†é‚®ç”µå¤§å­¦çš„å’¸é±¼å¤§å­¦ç”Ÿçš„åšå®¢è®°å½•ï¼Œèœåˆ°å¯æ€œï¼ŒçœŸçš„å¯æƒœğŸ”"},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:51:06.685Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"&emsp;ğŸ…æ—§CSDNåšå®¢"},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:49:21.826Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":"&emsp;ğŸºsmpHttp ä¸€ä¸ªåŸºäºlibuvçš„C++ httpåº“ &emsp;ğŸ»Algorithms ã€Šç®—æ³•ç¬¬4ç‰ˆã€‹çš„C++ä»£ç å®ç°"},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"å½’æ¡£","date":"2020-01-22T13:44:19.251Z","updated":"2020-01-22T13:44:19.251Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":"æ ‡ç­¾åˆ†ç±»ç›®å½•&emsp;ğŸºç®—æ³•&emsp;ğŸ¶LeetCode&emsp;ğŸ±é‡è§çš„é—®é¢˜&emsp;ğŸ­Libuv&emsp;ğŸ¹raxæºç é˜…è¯»&emsp;ğŸ ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°"}],"posts":[{"title":"344.åè½¬å­—ç¬¦ä¸²","slug":"leetcode344","date":"2020-01-28T15:03:25.000Z","updated":"2020-01-28T15:29:27.404Z","comments":true,"path":"2020/01/28/leetcode344/","link":"","permalink":"http://yoursite.com/2020/01/28/leetcode344/","excerpt":"","text":"ğŸ¥©é€’å½’&emsp;&emsp; 12345678910111213141516class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int i = 0, e = s.size() - 1; rs(s, i, e); &#125; void rs(vector&lt;char&gt;&amp; s, int&amp; i, int&amp; e) &#123; if(i &gt;= e) return ; swap(s[i], s[e]); ++i; --e; rs(s, i, e); &#125;&#125;; Accepted 478/478 cases passed (52 ms) Your runtime beats 88.72 % of cpp submissions Your memory usage beats 5.04 % of cpp submissions (20.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"347.å‰ K ä¸ªé«˜é¢‘å…ƒç´ ","slug":"leetcode347","date":"2020-01-25T13:12:46.000Z","updated":"2020-01-25T13:13:53.358Z","comments":true,"path":"2020/01/25/leetcode347/","link":"","permalink":"http://yoursite.com/2020/01/25/leetcode347/","excerpt":"","text":"ğŸ‰æŸ¥æ‰¾ and å“ˆå¸Œè¡¨12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; count; for(auto x :nums) &#123; count[x] += 1; &#125; using value_t = pair&lt;int, int&gt;; vector&lt;value_t&gt; container(count.begin(), count.end()); auto comp = [](const value_t &amp;v1, const value_t &amp;v2) &#123;return v1.second &lt; v2.second;&#125;; make_heap(container.begin(), container.end(), comp); vector&lt;int&gt; result; for (int i = 0; i &lt; k; ++i) &#123; result.push_back(container.begin()-&gt;first); pop_heap(container.begin(), container.end() - i, comp); &#125; return result; &#125;&#125;; Accepted 21/21 cases passed (24 ms) Your runtime beats 62.88 % of cpp submissions Your memory usage beats 9.89 % of cpp submissions (11.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"454.å››æ•°ç›¸åŠ  II","slug":"leetcode454","date":"2020-01-25T12:38:36.000Z","updated":"2020-01-25T12:50:29.814Z","comments":true,"path":"2020/01/25/leetcode454/","link":"","permalink":"http://yoursite.com/2020/01/25/leetcode454/","excerpt":"","text":"ğŸ˜‚å¤±è´¥1.è¶…å‡ºæ—¶é—´12345678910111213141516class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; set&lt;vector&lt;int&gt;&gt; st; for(int a = 0; a &lt; A.size(); ++a) for(int b = 0; b &lt;B.size(); ++b) for(int c = 0; c &lt; C.size(); ++c) for(int d = 0; d &lt; D.size(); ++d) &#123; if(A[a] + B[b] + C[c] + D[d] == 0) &#123; st.insert(&#123;a,b,c,d&#125;); &#125; &#125; return st.size(); &#125;&#125;; ğŸ˜œåˆ†ä¸ºä¸¤ç»„123456789101112131415161718192021222324252627class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; map&lt;int,int&gt; st; int count = 0; int x; for(int a = 0; a &lt; A.size(); ++a) for(int b = 0; b &lt;B.size(); ++b) &#123; x = A[a] + B[b]; if(!st.count(x)) st.insert(&#123;x, 1&#125;); else st[x] += 1; &#125; for(int c = 0; c &lt; C.size(); ++c) for(int d = 0; d &lt; D.size(); ++d) &#123; x = C[c] + D[d]; if(st.count(-x)) &#123; count += st[-x]; &#125; &#125; return count; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²","slug":"leetcode3","date":"2020-01-24T11:59:06.000Z","updated":"2020-01-24T12:00:37.224Z","comments":true,"path":"2020/01/24/leetcode3/","link":"","permalink":"http://yoursite.com/2020/01/24/leetcode3/","excerpt":"","text":"ğŸ¥›set &emsp;12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; set&lt;char&gt; st; int mx = 0; for(int i = 0; i &lt; s.size();) &#123; if(st.count(s[i]) &gt; 0) &#123; if(st.size()) &#123; st.erase(s[i - st.size()]); &#125; &#125; else &#123; st.insert(s[i]); ++i; &#125; mx = max(mx, (int)st.size()); &#125; return mx; &#125;&#125;; Accepted 987/987 cases passed (48 ms) Your runtime beats 25.3 % of cpp submissions Your memory usage beats 14.41 % of cpp submissions (16 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"771.å®çŸ³ä¸çŸ³å¤´","slug":"leetcode771","date":"2020-01-24T11:49:56.000Z","updated":"2020-01-25T03:35:48.772Z","comments":true,"path":"2020/01/24/leetcode771/","link":"","permalink":"http://yoursite.com/2020/01/24/leetcode771/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°12345678910111213141516class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; set&lt;char&gt; mp; for(auto x : J) &#123; mp.insert(x); &#125; int tl = 0; for(auto a: S) &#123; if(mp.count(a) &gt; 0) &#123; tl += 1; &#125; &#125; return tl; &#125;&#125;; Accepted 254/254 cases passed (8 ms) Your runtime beats 25.05 % of cpp submissions Your memory usage beats 5.26 % of cpp submissions (8.8 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"652.å¯»æ‰¾é‡å¤çš„å­æ ‘","slug":"leetcode652","date":"2020-01-23T15:39:28.000Z","updated":"2020-01-23T15:50:03.381Z","comments":true,"path":"2020/01/23/leetcode652/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode652/","excerpt":"","text":"ğŸ˜”å¤±è´¥1&emsp;&emsp;ä¸å¯ä»¥é‡è½½mapçš„æ¯”è¾ƒå‡½æ•°ï¼Œå› ä¸ºmapçš„å®ç°æ˜¯çº¢é»‘æ ‘ï¼Œç”¨äºçº¢é»‘æ ‘æ’åºæ¯”è¾ƒã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;memory&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std; struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: struct Cmp &#123; bool compr(const TreeNode* lhs, const TreeNode* rhs) const &#123; if (!lhs &amp;&amp; !rhs) return true; if ((!lhs &amp;&amp; rhs) || (lhs &amp;&amp; !rhs)) return false; bool v = lhs-&gt;val == rhs-&gt;val; if (!v) return false; bool v1 = compr(lhs-&gt;left, rhs-&gt;left); if (!v1) return false; bool v2 = compr(lhs-&gt;right, rhs-&gt;right); if (!v2) return false; &#125; bool operator()(const TreeNode* lhs, const TreeNode* rhs) const &#123; return compr(lhs, rhs); &#125; &#125;; vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; map&lt;TreeNode*, int, Cmp&gt; st; vector&lt;TreeNode*&gt; vec; dg(root, st, vec); return vec; &#125; void dg(TreeNode* h, map&lt;TreeNode*, int, Cmp&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec) &#123; if (!h) return; dg(h-&gt;left, st, vec); dg(h-&gt;right, st, vec); size_t ct = st.count(h); if (ct &gt; 0) &#123; if (st.at(h) == 1) &#123; cout &lt;&lt; &quot;i&quot; &lt;&lt; endl; vec.push_back(h); &#125; st.at(h) += 1; cout &lt;&lt; &quot;t&quot; &lt;&lt; endl; &#125; else &#123; st.insert(&#123; h, 1 &#125;); cout &lt;&lt; &quot;f&quot; &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;right = new TreeNode(3); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;right-&gt;left = new TreeNode(2); root-&gt;right-&gt;right = new TreeNode(4); root-&gt;right-&gt;left-&gt;left = new TreeNode(4); Solution().findDuplicateSubtrees(root);&#125; ğŸ˜åºåˆ—åŒ–&emsp;&emsp;åºåˆ—åŒ–æˆå­—ç¬¦ä¸²ä¹‹åå†æ¥æ¯”è¾ƒã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; map&lt;string, int&gt; st; vector&lt;TreeNode*&gt; vec; string s; dg(root, st, vec, s); return vec; &#125; void dg(TreeNode* h, map&lt;string, int&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; vec, string&amp; s) &#123; if(!h) return ; dg(h-&gt;left, st, vec, s); dg(h-&gt;right, st, vec, s); s.clear(); seril(h, s); if(st.count(s)) &#123; if(st.at(s) == 1) &#123; // cout &lt;&lt; &quot;i&quot; &lt;&lt; endl; vec.push_back(h); &#125; st.at(s) += 1; // cout &lt;&lt; &quot;t&quot; &lt;&lt; endl; &#125; else &#123; st.insert(&#123;s, 1&#125;); // cout &lt;&lt; &quot;f&quot; &lt;&lt; endl; &#125; &#125; void seril(TreeNode* h,string&amp; s) &#123; if(!h) &#123; s += &quot;@#&quot;; return ; &#125; s += to_string(h-&gt;val) + &apos;#&apos;; seril(h-&gt;left, s); seril(h-&gt;right, s); &#125;&#125;; Accepted 168/168 cases passed (684 ms) Your runtime beats 5.25 % of cpp submissions Your memory usage beats 15.17 % of cpp submissions (54.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"36.æœ‰æ•ˆçš„æ•°ç‹¬","slug":"leetcode36","date":"2020-01-23T14:00:56.000Z","updated":"2020-01-23T14:02:10.506Z","comments":true,"path":"2020/01/23/leetcode36/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode36/","excerpt":"","text":"ğŸšŒ1234567891011121314151617181920212223242526class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int columns[9][9] = &#123;0&#125;, rows[9][9] = &#123;0&#125;, boxes[9][9] = &#123;0&#125;; for(int r = 0; r &lt; 9; ++r) for(int c = 0; c &lt; 9; ++c) &#123; if(board[r][c] == &apos;.&apos;) continue; int val = board[r][c] - 48 - 1; // cout &lt;&lt; val &lt;&lt; endl; int box_num = r / 3 * 3 + c / 3; boxes[box_num][val] += 1; columns[c][val] += 1; rows[r][val] += 1; if(boxes[box_num][val] &gt; 1 || columns[c][val] &gt; 1 || rows[r][val] &gt; 1) &#123; return false; &#125; &#125; return true; &#125;&#125;; Accepted 504/504 cases passed (16 ms) Your runtime beats 71.31 % of cpp submissions Your memory usage beats 63.82 % of cpp submissions (9.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"49.å­—æ¯å¼‚ä½è¯åˆ†ç»„","slug":"leetcode49","date":"2020-01-23T12:52:51.000Z","updated":"2020-01-23T12:53:55.230Z","comments":true,"path":"2020/01/23/leetcode49/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode49/","excerpt":"","text":"12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; map&lt;string, vector&lt;string&gt;&gt; mp; for(auto str: strs) &#123; string s = respell(str); mp[s].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; vs; for(auto v : mp) vs.push_back(v.second); return vs; &#125; string respell(string s) &#123; vector&lt;char&gt; vec; for(auto i : s) &#123; vec.push_back(i); &#125; sort(vec.begin(), vec.end()); string ns = &quot;&quot;; for(auto x : vec) &#123; ns += x; &#125; return ns; &#125;&#125;; Accepted 101/101 cases passed (64 ms) Your runtime beats 47.5 % of cpp submissions Your memory usage beats 11.54 % of cpp submissions (22.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"219.å­˜åœ¨é‡å¤å…ƒç´  II","slug":"leetcode219","date":"2020-01-23T12:15:26.000Z","updated":"2020-01-23T12:17:36.825Z","comments":true,"path":"2020/01/23/leetcode219/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode219/","excerpt":"","text":"ğŸ˜å®ç°setçš„å¤§å°ç”¨æ¥è®°å½•è·ç¦»å€¼Kã€‚ 12345678910111213141516class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; set&lt;int&gt; st; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(st.count(nums[i]) == 1) return true; st.insert(nums[i]); if(st.size() &gt; k) &#123; st.erase(nums[i - k]); &#125; &#125; return false; &#125;&#125;; Accepted 23/23 cases passed (48 ms)Your runtime beats 41.06 % of cpp submissionsYour memory usage beats 6.78 % of cpp submissions (15.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"350.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† II","slug":"leetcode350","date":"2020-01-23T11:52:59.000Z","updated":"2020-01-23T11:54:17.893Z","comments":true,"path":"2020/01/23/leetcode350/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode350/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if(!nums1.size() || !nums2.size()) return vector&lt;int&gt;(); vector&lt;int&gt; res; int lo, ho, mid; sort(nums2.begin(), nums2.end()); for(auto x: nums1) &#123; lo = 0; ho = nums2.size() - 1; while(lo &lt; ho) &#123; mid = lo + (ho - lo) / 2; if(nums2[mid] &lt; x) &#123; lo = mid + 1; &#125; else &#123; ho = mid; &#125; &#125; if(nums2[lo] == x) &#123; res.push_back(x); nums2.erase(nums2.begin() + lo); if(!nums2.size()) return res; &#125; &#125; return res; &#125;&#125;; Accepted 61/61 cases passed (12 ms) Your runtime beats 55.05 % of cpp submissions Your memory usage beats 52.41 % of cpp submissions (9.4 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"387.å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦","slug":"leetcode387","date":"2020-01-23T11:41:29.000Z","updated":"2020-01-23T11:42:25.345Z","comments":true,"path":"2020/01/23/leetcode387/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode387/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°1234567891011121314151617181920212223242526class Solution &#123;public: int firstUniqChar(string s) &#123; if(!s.size()) return -1; map&lt;char, int&gt; st; for(int i = 0; i &lt; s.size(); ++i)&#123; if(!st.count(s[i])) &#123; st[s[i]] = i; &#125; else &#123; st[s[i]] = INT_MAX; &#125; &#125; if(!st.size()) return -1; auto x = min_element(st.begin(), st.end(), [](auto&amp; a, auto&amp; b)&#123; if(a.second &lt; b.second) &#123; return true; &#125; return false; &#125;); if(x-&gt;second == INT_MAX) return -1; return x-&gt;second; &#125;&#125;; Accepted 104/104 cases passed (92 ms) Your runtime beats 20.33 % of cpp submissions Your memory usage beats 5.07 % of cpp submissions (13.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"599.ä¸¤ä¸ªåˆ—è¡¨çš„æœ€å°ç´¢å¼•æ€»å’Œ","slug":"leetcode599","date":"2020-01-23T11:10:24.000Z","updated":"2020-01-23T11:11:18.248Z","comments":true,"path":"2020/01/23/leetcode599/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode599/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) &#123; vector&lt;string&gt; vec; if(!list1.size()) return vec; map&lt;string, int&gt; st1, st2; for(int i = 0; i &lt; list1.size(); ++i) st1.insert(&#123;list1[i], i&#125;); for(int i = 0; i &lt; list2.size(); ++i) &#123; if(st1.count(list2[i]) != 0) &#123; auto x = st1.at(list2[i]); st2.insert(&#123;list2[i], x + i&#125;); &#125; &#125; int mi = INT_MAX; for(auto x :st2) &#123; if(mi &gt; x.second) &#123; mi = x.second; // ms = x.first; &#125; &#125; for(auto x : st2) &#123; if(mi == x.second) vec.push_back(x.first); &#125; return vec; &#125; &#125;; Accepted 133/133 cases passed (152 ms) Your runtime beats 33.28 % of cpp submissions Your memory usage beats 21.41 % of cpp submissions (31.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"205.åŒæ„å­—ç¬¦ä¸²","slug":"leetcode205","date":"2020-01-23T09:52:36.000Z","updated":"2020-01-23T09:53:33.989Z","comments":true,"path":"2020/01/23/leetcode205/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode205/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°123456789101112131415class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char, int&gt; st, tt; for(int i = 0; i &lt; s.size(); ++i) &#123; if(st.count(s[i]) == 1 || tt.count(t[i]) == 1) &#123; if(tt.count(t[i]) != 1 || st.count(s[i]) != 1 || tt.at(t[i]) != st.at(s[i])) return false; &#125; st.insert(&#123;s[i], i&#125;); tt.insert(&#123;t[i], i&#125;); &#125; return true; &#125;&#125;; Accepted 30/30 cases passed (40 ms) Your runtime beats 5.2 % of cpp submissions Your memory usage beats 5.04 % of cpp submissions (15 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"202.å¿«ä¹æ•°","slug":"leetcode202","date":"2020-01-23T09:00:15.000Z","updated":"2020-01-23T09:01:24.368Z","comments":true,"path":"2020/01/23/leetcode202/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode202/","excerpt":"","text":"ğŸ¤1234567891011121314151617181920212223242526class Solution &#123;public: bool isHappy(int n) &#123; vector&lt;int&gt; res; int count = 0; while(n != 1 &amp;&amp; count != 10) &#123; ++count; helper(n, res); n = 0; for(auto x: res) &#123; n += pow(x, 2); &#125; &#125; if(count == 10) return false; return true; &#125; void helper(int n, vector&lt;int&gt;&amp; res) &#123; res.clear(); while(n) &#123; res.push_back(n % 10); n /= 10; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"349.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†","slug":"leetcode349","date":"2020-01-23T08:28:49.000Z","updated":"2020-01-23T08:31:35.782Z","comments":true,"path":"2020/01/23/leetcode349/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode349/","excerpt":"","text":"ğŸ‰äºŒåˆ†æŸ¥æ‰¾ and å“ˆå¸Œè¡¨&emsp;&emsp;ä¸€ä¸ªå“ˆå¸Œè¡¨çš„setæ¥å¾—åˆ°ä¸€ä¸ªæ•°ç»„çš„å”¯ä¸€å€¼ï¼Œå†é€šè¿‡äºŒåˆ†æŸ¥æ‰¾æ¥æ¯”è¾ƒï¼Œå¾—åˆ°ä¸€æ ·çš„å€¼ï¼Œæ”¾å…¥ç»“æœçš„vectorä¸­ã€‚ 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; st; if(!nums1.size() || !nums2.size()) return vector&lt;int&gt;(); vector&lt;int&gt; res; int lo, ho, mid; sort(nums2.begin(), nums2.end()); for(auto x: nums1) st.insert(x); for(auto x: st) &#123; lo = 0; ho = nums2.size() - 1; while(lo &lt; ho) &#123; mid = lo + (ho - lo) / 2; if(nums2[mid] &lt; x) &#123; lo = mid + 1; &#125; else &#123; ho = mid; &#125; &#125; if(nums2[lo] == x) &#123; res.push_back(x); &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"136.åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—","slug":"leetcode136","date":"2020-01-23T08:21:00.000Z","updated":"2020-01-23T08:21:53.417Z","comments":true,"path":"2020/01/23/leetcode136/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode136/","excerpt":"","text":"12345678910111213class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; st; for(auto x : nums) &#123; if(st.count(x) == 0) st.insert(x); else st.erase(x); &#125; return *st.begin(); &#125;&#125;; Accepted 16/16 cases passed (36 ms) Your runtime beats 8.92 % of cpp submissions Your memory usage beats 5.02 % of cpp submissions (12.1 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"217.å­˜åœ¨é‡å¤å…ƒç´ ","slug":"leetcode217","date":"2020-01-23T08:04:46.000Z","updated":"2020-01-23T08:05:41.874Z","comments":true,"path":"2020/01/23/leetcode217/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode217/","excerpt":"","text":"å› ä¸ºä¸éœ€è¦æœ‰åºï¼Œæ‰€ä»¥å¯ä»¥ç”¨unordered_setè€Œä¸æ˜¯set 123456789101112class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; st; for(auto x : nums) &#123; if(st.count(x) &gt; 0) return true; st.insert(x); &#125; return false; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"706.è®¾è®¡å“ˆå¸Œæ˜ å°„","slug":"leetcode706","date":"2020-01-23T07:52:39.000Z","updated":"2020-01-23T07:53:17.385Z","comments":true,"path":"2020/01/23/leetcode706/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode706/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class MyHashMap &#123;public: /** Initialize your data structure here. */ MyHashMap() : N(0), M(10000) &#123; keys = new int [10000](); vals = new int [10000](); for(int i = 0; i &lt; 10000; ++i) &#123; keys[i] = -1; vals[i] = -1; &#125; &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; vals[i] = value; return ; &#125; &#125; vals[i] = value; keys[i] = key; N++; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return vals[i]; &#125; return -1; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) break; &#125; if(keys[i] == -1) return ; int k2, v2; keys[i] = -1; vals[i] = -1; i = (i + 1) % M; while(keys[i] != -1)&#123; k2 = keys[i]; v2 = vals[i]; keys[i] = -1; vals[i] = -1; --N; put(k2, v2); i = (i + 1) % M; &#125; --N; &#125;private: int *keys; int *vals; int N; int M;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"705.è®¾è®¡å“ˆå¸Œé›†åˆ","slug":"leetcode705","date":"2020-01-23T07:36:48.000Z","updated":"2020-01-23T07:37:40.282Z","comments":true,"path":"2020/01/23/leetcode705/","link":"","permalink":"http://yoursite.com/2020/01/23/leetcode705/","excerpt":"","text":"ğŸ˜‚ä»£ç å®ç°&emsp;&emsp; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MyHashSet &#123;public: /** Initialize your data structure here. */ MyHashSet() : N(0), M(10000) &#123; keys = new int [10000](); for(int i = 0; i &lt; 10000; ++i) keys[i] = -1; &#125; void add(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return ; &#125; keys[i] = key; N++; &#125; void remove(int key) &#123; if(!contains(key)) return ; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) break; &#125; int k2; keys[i] = -1; i = (i + 1) % M; while(keys[i] != -1)&#123; k2 = keys[i]; keys[i] = -1; --N; add(k2); i = (i + 1) % M; &#125; --N; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int i = (key &amp; 0x7fffffff) % M; for( ; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return true; &#125; return false; &#125;private: int *keys; int N; int M;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"ç¬¬äº”ç«  Internetåè®®","slug":"TIV5","date":"2020-01-23T05:47:50.000Z","updated":"2020-01-23T06:30:00.700Z","comments":true,"path":"2020/01/23/TIV5/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV5/","excerpt":"","text":"IPv4å¤´éƒ¨é•¿åº¦åŒ…å«20ä¸ªå­—èŠ‚ï¼ˆæ²¡æœ‰é€‰é¡¹ï¼‰ï¼ŒIPv6å¤´éƒ¨é•¿åº¦å›ºå®šï¼ˆ40å­—èŠ‚ï¼‰ã€‚ç½‘ç»œå­—èŠ‚åºï¼šé«˜ä½ä¼˜å…ˆå­—èŠ‚åºã€‚Internetå¤´éƒ¨è¢«é™åˆ¶ä¸º60ä¸ªå­—èŠ‚ï¼Œå› ä¸ºIHLå­—æ®µé•¿åº¦ä¸º4ä½ï¼Œä¿å­˜IPv4å¤´éƒ¨ä¸­32ä½å­—çš„æ•°é‡ã€‚ä¸»æœºä¸éœ€è¦æ¥æ”¶å¤§äº576å­—èŠ‚çš„IPv4æ•°æ®æŠ¥ã€‚å¤´éƒ¨æ ¡éªŒå’Œå­—æ®µä»…è®¡ç®—IPv4å¤´éƒ¨ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬ä¸‰ç«  é“¾è·¯å±‚","slug":"TIV3","date":"2020-01-23T04:48:35.000Z","updated":"2020-01-23T05:47:43.940Z","comments":true,"path":"2020/01/23/TIV3/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV3/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡æœ€å¤§ä¼ è¾“å•å…ƒï¼š MTUä»¥å¤ªç½‘ï¼šé€šå¸¸æŒ‡ä¸€å¥—æ ‡å‡†ã€‚10Mbit/sä»¥å¤ªç½‘ï¼Œåˆç§°802.3æ ‡å‡†ã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;äº¤æ¢æœºä»¥åŒå·¥æ–¹å¼è¿è¡Œï¼Œå¹¶ä¸”ä¸éœ€è¦ä½¿ç”¨CSMA/CDç®—æ³•.&emsp;ä¼ ç»Ÿä»¥å¤ªç½‘æœ€å°çš„å¸§æ˜¯64å­—èŠ‚ï¼Œè¦æ±‚æ•°æ®åŒºé•¿åº¦æœ€å°ä¸º48å­—èŠ‚ï¼Œæœ€å¤§å¸§é•¿åº¦ä¸º1518å­—èŠ‚ï¼ŒMTUå¤§å°é™åˆ¶ä¸º1500å­—èŠ‚ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬äºŒç«  Internetåœ°å€ç»“æ„","slug":"TIV2","date":"2020-01-23T01:42:40.000Z","updated":"2020-01-23T04:48:25.660Z","comments":true,"path":"2020/01/23/TIV2/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV2/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡å­ç½‘å¯»å€ï¼šä¸€ä¸ªç«™ç‚¹è¢«åˆ†é…ä¸€ä¸ªAç±»ã€Bç±»å’ŒCç±»çš„ç½‘ç»œå·ï¼Œä¿ç•™ä¸€äº›å‰©ä½™ä¸»æœºå·è¿›ä¸€æ­¥ç”¨ç«™ç‚¹åˆ†é…ã€‚è¯¥ç«™ç‚¹å¯èƒ½å°†åŸºç¡€åœ°å€ä¸­çš„ä¸»æœºéƒ¨åˆ†è¿›ä¸€æ­¥åˆ’åˆ†ä¸ºä¸€ä¸ªå­ç½‘å·å’Œä¸€ä¸ªä¸»æœºå·ã€‚Aç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·8ä½ï¼Œ0 + 7ä½è‡ªç”±;ä¸»æœºå·24ä½ Bç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·16ä½ï¼Œ10 + 14ä½è‡ªç”±ï¼›ä¸»æœº16ä½ Cç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·24ä½ï¼Œ110 + 21ä½è‡ªç”± ï¼›ä¸»æœº8ä½Dç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·32ä½ï¼Œ1110 + 28ä½è‡ªç”± Eç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·32ä½ï¼Œ1111 + 28ä½è‡ªç”± å­ç½‘æ©ç ï¼šç”±ä¸»æœºæˆ–è·¯ç”±å™¨ä½¿ç”¨çš„åˆ†é…ä½ï¼Œä»¥ç¡®å®šå¦‚ä½•ä»ä¸€å°ä¸»æœºå¯¹åº”IPåœ°å€ä¸­è·å¾—ç½‘ç»œå’Œå­ç½‘ä¿¡æ¯ã€‚å­ç½‘æ©ç çº¯ç²¹æ˜¯ç«™ç‚¹å†…éƒ¨çš„å±€éƒ¨é—®é¢˜ã€‚å®šå‘å¹¿æ’­ï¼š ä½¿ç”¨å­ç½‘å¹¿æ’­åœ°å€ä½œä¸ºç›®çš„åœ°çš„æ•°æ®æŠ¥ã€‚æœ‰é™å¹¿æ’­ï¼š255.255.255.255è¢«ä¿ç•™ä¸ºæœ¬åœ°ç½‘ç»œå¹¿æ’­ï¼Œå®ƒæ ¹æœ¬ä¸ä¼šè¢«è·¯ç”±å™¨è½¬å‘ã€‚ä»»æ„æºç»„æ’­ï¼šASM,ä»»ä½•å‘é€æ–¹å¯ä»¥å‘é€ç»™ä»»ä½•ç»„ã€‚ç‰¹ç‚¹ç»„æ’­ï¼šSSMï¼Œåœ¨æ¯ä¸ªç»„ä¸­åªä½¿ç”¨ä¸€ä¸ªå‘é€æ–¹ã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;IPv6åœ°å€é•¿åº¦128ä½ï¼ˆ16* 8ï¼‰ï¼ŒIPv4åœ°å€é•¿åº¦32ä½ï¼ˆ8* 4ï¼‰ &emsp;IPv6å—çš„å‰å¯¼çš„é›¶ä¸å¿…ä¹¦å†™ã€‚å…¨é›¶çš„å—å¯ä»¥çœç•¥ï¼Œå¹¶ç”¨ç¬¦å·::ä»£æ›¿ï¼Œä¸ºäº†é¿å…æ­§ä¹‰ï¼Œä¸€ä¸ªIPv6åœ°å€ä¸­çš„ç¬¦å·::åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚åœ¨IPv6æ ¼å¼ä¸­åµŒå…¥IPv4åœ°å€å¯ä»¥ä½¿ç”¨æ··åˆç¬¦å·å½¢å¼ï¼Œç´§æ¥ç€IPv4éƒ¨åˆ†çš„åœ°å€å—çš„å€¼ä¸ºffffï¼Œåœ°å€çš„å…¶ä»–éƒ¨åˆ†ä½¿ç”¨ç‚¹åˆ†å››ç»„æ ¼å¼ï¼ˆ::ffff:10.0.0.1ï¼‰ &emsp;åªæœ‰åˆ’åˆ†å­ç½‘çš„ç½‘ç»œä¸­çš„ä¸»æœºå’Œè·¯ç”±å™¨çŸ¥é“å­ç½‘ç»“æ„ï¼ŒInternetå…¶ä»–éƒ¨åˆ†ä»ç„¶å°†å®ƒä½œä¸ºç«™ç‚¹ç›¸å…³çš„åœ°å€æ¥çœ‹å¾….&emsp;128.32.1.255/24è¿™ä¸ªåœ°å€ç§°ä¸ºå­ç½‘å¹¿æ’­åœ°å€ã€‚&emsp;CIDRç¼“è§£IPv4åœ°å€çš„å‹åŠ›ï¼Œå¤„ç†å¤§äº255å°äº65536çš„ä¸»æœºæ•°ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬ä¸€ç«  æ¦‚è¿°","slug":"TIV1","date":"2020-01-22T13:10:37.000Z","updated":"2020-01-22T15:58:16.318Z","comments":true,"path":"2020/01/22/TIV1/","link":"","permalink":"http://yoursite.com/2020/01/22/TIV1/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡åè®®æ—ï¼š ä¸€ç³»åˆ—ç›¸å…³åè®®çš„é›†åˆã€‚ ç½‘å…³ï¼šåˆç§°è·¯ç”±å™¨ã€‚ è™šç”µè·¯ï¼šè¡¨ç°å‡ºå¾ˆå¤šç”µè·¯è¡Œä¸ºï¼Œä½†æ˜¯ä¸ä¾èµ–äºç‰©ç†çš„äº¤æ¢æœºï¼Œè€Œé€šè¿‡é¡¶å±‚çš„é¢å‘è¿æ¥çš„åˆ†ç»„æ¥å®ç° æ•°æ®æŠ¥ï¼šä¸€ä¸ªç‰¹å®šç±»å‹çš„åˆ†ç»„ï¼ŒåŒ…å«æ‰€æœ‰æ¥æºåœ°å’Œç›®çš„åœ°çš„æ‰€æœ‰è¯†åˆ«ä¿¡æ¯ã€‚ æ¶ˆæ¯è¾¹ç•Œï¼šå‡è®¾å‘é€3ä¸ªæ•°æ®æŠ¥ï¼Œæ¥æ”¶æ—¶å¿…é¡»æ˜¯3ä¸ªæ•°æ®æŠ¥ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯æœ‰æ¶ˆæ¯è¾¹ç•Œçš„ï¼›å¦‚æœå¯ä»¥è‡ªå·±é€‰æ‹©æ¥æ”¶æ¬¡æ•°ï¼Œä¸€æ¬¡æ¥æ”¶3ä¸ªæ•°æ®æŠ¥ï¼Œæˆ–è€…2æ¬¡ï¼Œè¿™å°±æ˜¯æ²¡æœ‰æ¶ˆæ¯è¾¹ç•Œã€‚ä¼šè¯å±‚ï¼šè¡¨ç¤ºè¿è¡Œä¸­çš„åº”ç”¨ä¹‹é—´çš„äº¤äº’ï¼Œä¼šè¯å±‚åè®®å¯æä¾›ä¾‹å¦‚è¿æ¥åˆå§‹åŒ–å’Œé‡æ–°å¯åŠ¨ã€å¢åŠ æ£€æŸ¥ç‚¹ç­‰åŠŸèƒ½ã€‚è¡¨ç¤ºå±‚ï¼šè´Ÿè´£ä¿¡æ¯æ ¼å¼è½¬æ¢å’Œæ ‡å‡†åŒ–ç¼–ç ã€‚PDUï¼šåè®®æ•°æ®å•å…ƒ è½¬å‘ï¼šæ¯ä¸ªæ•°æ®æŠ¥çš„ç›®çš„åœ°å€ç”¨äºå†³å®šå°†è¯¥æ•°æ®æŠ¥å‘é€åˆ°å“ªé‡Œï¼Œè€Œåšå‡ºæ­¤å†³å®šå’Œå‘é€æ•°æ®æŠ¥åˆ°ä¸‹ä¸€è·³çš„è¿‡ç¨‹ã€‚å•æ’­ï¼šç›®çš„åœ°æ˜¯ä¸€å°ä¸»æœºã€‚å¹¿æ’­ï¼šç›®çš„åœ°æ˜¯ä¸€ä¸ªæŒ‡å®šç½‘ç»œä¸­çš„æ‰€æœ‰ä¸»æœºã€‚ ç»„æ’­ï¼šç›®çš„åœ°æ˜¯å±äºä¸€ä¸ªç»„æ’­ç»„çš„ä¸€ç»„ä¸»æœºã€‚ ICMP: Internetæ§åˆ¶æ¶ˆæ¯åè®®æ˜¯IPçš„ä¸€ä¸ªè¾…åŠ©åè®®ã€‚IPå±‚ä½¿ç”¨å®ƒä¸å…¶ä»–ä¸»æœºæˆ–è·¯ç”±å™¨çš„IPå±‚ä¹‹é—´äº¤æ¢å·®é”™æ¶ˆæ¯å’Œå…¶ä»–é‡è¦æ¶ˆæ¯ã€‚ åº”ç”¨ï¼špingã€tracerouteã€‚IGMPï¼šInternetç»„ç®¡ç†åè®®æ˜¯IPv4çš„å¦ä¸€ä¸ªè¾…åŠ©åè®®ã€‚å®ƒé‡‡ç”¨ç»„æ’­å¯»å€å’Œäº¤ä»˜æ¥ç®¡ç†ä½œä¸ºç»„æ’­æˆå‘˜çš„ä¸»æœºã€‚SCTP: æµæ§åˆ¶ä¼ è¾“åè®®. ç«¯å£å·ï¼š16ä½éè´Ÿæ•´æ•°ï¼ˆ0~65535ï¼‰ï¼Œç†ŸçŸ¥ç«¯å£å·ï¼ˆ0 ~ 1023ï¼‰ï¼Œæ³¨å†Œç«¯å£å·ï¼ˆ1024 ~ 49151ï¼‰ï¼ŒåŠ¨æ€/ç§æœ‰ç«¯å£å·ï¼ˆ49152 ~ 65535ï¼‰internetï¼šå¸¸è§åè®®æ—äº’è”çš„å¤šä¸ªç½‘ç»œã€‚Internet: TCP/IPé€šä¿¡çš„ä¸–ç•ŒèŒƒå›´çš„ä¸»æœºé›†åˆã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;TCP/IPæ˜¯ä¸€ä¸ªå®ç°Internetä½“ç³»ç»“æ„çš„åè®®æ—ã€‚ &emsp;åœ¨å°½åŠ›è€Œä¸ºçš„äº¤ä»˜ä¸­ï¼Œç½‘ç»œä¸ä¼šèŠ±è´¹å¾ˆå¤§åŠªåŠ›æ¥ç¡®ä¿æ•°æ®åœ¨æ²¡æœ‰å·®é”™æˆ–ç¼ºé™·çš„æƒ…å†µä¸‹äº¤ä»˜ã€‚&emsp;åœ¨å°½åŠ›è€Œä¸ºçš„IPç½‘ç»œä¸­ï¼Œé™ä½å‘é€æ–¹çš„å‘é€é€Ÿåº¦å¯é€šè¿‡æµé‡æ§åˆ¶æœºåˆ¶å®ç°ã€‚&emsp;é€šå¸¸è®¤ä¸ºTCP/IPä½“ç³»ç»“æ„åŒ…å«5å±‚ã€‚&emsp;ç«¯ä¸»æœºå®ç°æ‰€æœ‰å±‚ï¼Œäº¤æ¢æœºå®ç°åˆ°ç¬¬äºŒå±‚ï¼Œè·¯ç”±å™¨å®ç°åˆ°ç¬¬ä¸‰å±‚ã€‚ &emsp;é€šå¸¸ä¸è®¤ä¸ºäº¤æ¢æœºæˆ–æ¡¥æ¥æ˜¯ä¸€ä¸ªä¸­é—´ç³»ç»Ÿï¼Œè¿™æ—¶ç”±äºå®ƒä»¬æ²¡æœ‰ä½¿ç”¨äº’è”ç½‘ç»œåè®®çš„åœ°å€æ ¼å¼æ¥ç¼–å€ï¼Œå¹¶åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šä»¥é€æ˜äºç½‘ç»œå±‚åè®®çš„æ–¹å¼è¿è¡Œã€‚&emsp;æœ‰å¤šä¸ªæ¥å£çš„ç³»ç»Ÿç§°ä¸ºå¤šå®¿ä¸». &emsp;IPå‘é€ç»™é“¾è·¯å±‚åè®®çš„PDUç§°ä¸ºIPæ•°æ®æŠ¥ï¼Œå®ƒçš„å¤§å°æ˜¯64KBï¼ˆIPv6æ˜¯4GBï¼‰,æˆ‘ä»¬ç®€åŒ–ç§°ä¸ºåˆ†ç»„&emsp;å¤§çš„åˆ†ç»„æ”¾å…¥é“¾è·¯å±‚PDUï¼ˆç§°ä¸ºå¸§ï¼‰æ—¶éœ€è¦è¿›è¡Œç¼©å°å¤„ç†ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºåˆ†ç‰‡ã€‚ &emsp;TCPå‘é€åˆ°IPçš„PDUç§°ä¸ºTCPæ®µã€‚ &emsp;ç”¨æˆ·å¯ä»¥é€šè¿‡è™šæ‹Ÿä¸“ç”¨ç½‘VPNè¿æ¥åˆ°å†…è”ç½‘ã€‚&emsp;","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"æ•£åˆ—è¡¨","slug":"alg6","date":"2020-01-22T12:22:09.000Z","updated":"2020-01-22T12:29:28.412Z","comments":true,"path":"2020/01/22/alg6/","link":"","permalink":"http://yoursite.com/2020/01/22/alg6/","excerpt":"","text":"ğŸ¥£æ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨&emsp;&emsp;åŸºäºé“¾è¡¨å®ç°çš„å­—å…¸å®ç°è€Œæ¥ æ•£åˆ—è¡¨çš„é‡ç‚¹åœ¨äºè§£å†³å†²çªï¼Œæ‹‰é“¾æ³•è§£å†³å†²çªçš„æ–¹æ³•æ˜¯é€šè¿‡æ•°ç»„ï¼‹é“¾è¡¨çš„å½¢å¼æ¥å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &quot;BinarySearchST.hpp&quot;using namespace std;/** * æ‹‰é“¾æ³•æ•£åˆ—è¡¨ * å› ä¸ºæ²¡æœ‰Javaçš„hasCodeæ–¹æ³•ï¼Œ * æ‰€ä»¥è¿™é‡Œçš„ä»£ç ç›´æ¥ä½¿ç”¨intç±»å‹ **/ template&lt;typename Value&gt;class SeparateChainingHashST&#123; public: SeparateChainingHashST(int M); ~SeparateChainingHashST(); Value get(int key); void put(int key, Value val); int size() const &#123;return this-&gt;N;&#125; private: int N; //é”®å€¼å¯¹æ€»æ•° int M; //æ•£åˆ—è¡¨çš„å¤§å° BinarySearchST&lt;int, Value&gt; *st; int hash(int key) const;&#125;;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::SeparateChainingHashST(int M) : N(0), M(M)&#123; st = new BinarySearchST&lt;int, Value&gt;[M]();&#125;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::~SeparateChainingHashST()&#123; delete [] st;&#125;template&lt;typename Value&gt;int SeparateChainingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;Value SeparateChainingHashST&lt;Value&gt;::get(int key)&#123; return st[hash(key)].get(key);&#125;template&lt;typename Value&gt;void SeparateChainingHashST&lt;Value&gt;::put(int key, Value val)&#123; st[hash(key)].put(key, val); N++;&#125; ğŸ˜¤çº¿æ€§æ¢æµ‹æ³•çš„æ•£åˆ—è¡¨&emsp;&emsp;çº¿æ€§æ¢æµ‹æ³•çš„é‡ç‚¹åœ¨äºhashå€¼ç›¸åŒæ—¶ï¼Œå°†é”®å€¼å¾€åç§»ï¼Œè¿™æ ·å°±å…±ç”¨ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹äºæ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨ï¼Œè¿™ç§æ–¹æ³•æ˜¯ç”¨æ—¶é—´å¤æ‚åº¦æ¥æ¢å–ç©ºé—´å¤æ‚åº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * çº¿æ€§æ¢æµ‹æ³•çš„æ•£åˆ—è¡¨ **/ template&lt;typename Value&gt;class LinearProbingHashST&#123; public: LinearProbingHashST(int M); int size() const &#123;return N;&#125; void put(int key, Value val); Value get(int key); void delet(int key); bool contain(int key) const; private: int M; //é•¿åº¦ int N; //é”®å€¼å¯¹æ•°é‡ int* keys; Value* vals; void resize(int sz); int hash(int key) const;&#125;;template&lt;typename Value&gt;int LinearProbingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;LinearProbingHashST&lt;Value&gt;::LinearProbingHashST(int M) :M(M), N(0)&#123; keys = new int [M](); vals = new Value [M](); for(int i = 0; i &lt; M; ++i) keys[i] = -1;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::put(int key, Value val)&#123; if(N &gt; M / 2) &#123; resize(2 * M); &#125; int i; for(i = hash(key); keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; vals[i] = val; return ; &#125; &#125; keys[i] = key; vals[i] = val; N++;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::resize(int sz)&#123; int * keys1 = keys; Value* vals1 = vals; int M1 = M; keys = new int [sz](); vals = new Value [sz] (); for(int i = 0; i &lt; sz; ++i) &#123; keys[i] = -1; &#125; N = 0; M = sz; for(int i = 0; i &lt; M1; ++i) &#123; if(keys1[i] != -1) &#123; put(keys1[i], vals1[i]); &#125; &#125; delete [] keys1; delete [] vals1;&#125;template&lt;typename Value&gt;Value LinearProbingHashST&lt;Value&gt;::get(int key)&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; return vals[i]; &#125; &#125; return Value();&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::delet(int key)&#123; if(!contain(key)) return ; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) if(keys[i] == key) break; keys[i] = -1; vals[i] = Value(); i = (i + 1) % M; int k; Value v; while(keys[i] != -1) &#123; k = keys[i]; v = vals[i]; N--; keys[i] = -1; vals[i] = Value(); put(k, v); i = (i + 1) % M; &#125; N--; if(N &gt; 0 &amp;&amp; N == M/8) resize(M / 2);&#125;template&lt;typename Value&gt;bool LinearProbingHashST&lt;Value&gt;::contain(int key) const&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return true; &#125; return false;&#125;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"98.éªŒè¯äºŒå‰æœç´¢æ ‘","slug":"leetcode98","date":"2020-01-22T07:09:27.000Z","updated":"2020-01-22T07:17:21.119Z","comments":true,"path":"2020/01/22/leetcode98/","link":"","permalink":"http://yoursite.com/2020/01/22/leetcode98/","excerpt":"","text":"ğŸ¥§ä¸­åºéå†&emsp;&emsp;äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†å¾—åˆ°çš„æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ—ã€‚ 12345678910111213141516171819202122232425class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; vector&lt;int&gt; vec; helper(root, vec); if(vec.size() &lt; 2) return true; for(int i = 0; i &lt;= vec.size() - 2; ++i) &#123; if(vec[i] &gt;= vec[i+1]) return false; &#125; return true; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123; if(!root) return ; if(root-&gt;left) helper(root-&gt;left, vec); vec.push_back(root-&gt;val); if(root-&gt;right) helper(root-&gt;right, vec); &#125;&#125;; Accepted 75/75 cases passed (20 ms)Your runtime beats 49.34 % of cpp submissionsYour memory usage beats 5.03 % of cpp submissions (21.3 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"110.å¹³è¡¡äºŒå‰æ ‘","slug":"leetcode110","date":"2020-01-22T06:32:09.000Z","updated":"2020-01-22T06:35:21.232Z","comments":true,"path":"2020/01/22/leetcode110/","link":"","permalink":"http://yoursite.com/2020/01/22/leetcode110/","excerpt":"","text":"ğŸ¥§é€’å½’&emsp;&emsp;å’Œä¸€èˆ¬é€’å½’ä¸åŒçš„åœ°æ–¹åœ¨äºï¼Œä¸èƒ½è¿”å›å¹³è¡¡å› å­ï¼Œå¿…é¡»è¿”å›é«˜åº¦ï¼Œå¹¶ä¸”è®¾ç½®ä¸€ä¸ª-1çš„ç‰¹æ®Šå€¼æ¥ä½œä¸ºå¤±è´¥çš„ç»“æœï¼ˆç”¨æ¥ä»£æ›¿boolï¼‰ã€‚è¿™é‡Œä¸èƒ½è¿”å›boolç±»å‹ï¼Œå› ä¸ºboolæ— æ³•ä¼ é€’é«˜åº¦å€¼ã€‚ 12345678910111213141516class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return helper(root) != -1; &#125; int helper(TreeNode* h) &#123; if(!h) return 0; int lf = helper(h-&gt;left), rf = helper(h-&gt;right); if(lf == -1 || rf == -1) return -1; return abs(rf - lf) &lt;= 1 ? max(lf, rf) + 1: -1; &#125;&#125;; Accepted 227/227 cases passed (20 ms) Your runtime beats 44.47 % of cpp submissions Your memory usage beats 9.13 % of cpp submissions (17.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"96.ä¸åŒçš„äºŒå‰æœç´¢æ ‘","slug":"leetcode96","date":"2020-01-21T11:33:23.000Z","updated":"2020-01-21T11:34:42.154Z","comments":true,"path":"2020/01/21/leetcode96/","link":"","permalink":"http://yoursite.com/2020/01/21/leetcode96/","excerpt":"","text":"ğŸ¥§åŠ¨æ€è§„åˆ’&emsp;&emsp; 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; int tr[n + 1] = &#123;0&#125;; tr[0] = 1; tr[1] = 1; for(int i = 2; i &lt;= n; ++i) for(int j = 1; j &lt;= i; ++j) &#123; tr[i] += tr[j - 1] * tr[i - j]; &#125; return tr[n]; &#125;&#125;; Accepted 19/19 cases passed (0 ms) Your runtime beats 100 % of cpp submissions Your memory usage beats 32.61 % of cpp submissions (8.3 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"95.ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II","slug":"leetcode95","date":"2020-01-21T10:50:33.000Z","updated":"2020-01-21T10:52:31.615Z","comments":true,"path":"2020/01/21/leetcode95/","link":"","permalink":"http://yoursite.com/2020/01/21/leetcode95/","excerpt":"","text":"ğŸ¥§é€’å½’&emsp;&emsp;å†™é€’å½’æœ€é‡è¦çš„ç‚¹åœ¨äºï¼š ä¸è¦åœ¨ä¹é€’å½’æ˜¯å¦‚ä½•è¿è¡Œçš„ï¼Œä½ è¦åœ¨ä¹çš„æ˜¯ï¼Œé€šè¿‡è®¾è®¡ä»€ä¹ˆæ ·çš„é€’å½’å…¬å¼ï¼Œé€’å½’å‡ºå£ï¼Œå°±ä¸€å®šå¯ä»¥é€šè¿‡é€’å½’è·å¾—æœ€ç»ˆçš„å€¼ã€‚è€Œä¸æ˜¯å»è€ƒè™‘é€’å½’åœ¨è®¡ç®—æœºä¸­ä»¥ä»€ä¹ˆæ ·çš„å½¢å¼å’Œæµç¨‹å»æ‰§è¡Œçš„ã€‚ 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(!n) return vector&lt;TreeNode*&gt;(); return helper(1, n); &#125; vector&lt;TreeNode*&gt; helper(int start, int end) &#123; vector&lt;TreeNode*&gt; ret; if(start &gt; end) &#123; ret.push_back(nullptr); return ret; &#125; for(int i = start; i &lt;= end; ++i) &#123; auto leftList = helper(start, i - 1); auto rightList = helper(i + 1, end); for(auto l : leftList) for(auto r: rightList) &#123; auto newOne = new TreeNode(i); newOne-&gt;left = l; newOne-&gt;right = r; ret.push_back(newOne); &#125; &#125; return ret; &#125;&#125;; Accepted 9/9 cases passed (12 ms) Your runtime beats 99.22 % of cpp submissions Your memory usage beats 8.96 % of cpp submissions (17.6 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"315.è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°","slug":"leetcode315","date":"2020-01-17T12:17:50.000Z","updated":"2020-01-17T12:46:10.825Z","comments":true,"path":"2020/01/17/leetcode315/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode315/","excerpt":"","text":"ğŸ˜äºŒå‰æŸ¥æ‰¾æ ‘å®ç°&emsp;&emsp;æœ‰å‡ ä¸ªéš¾ç‚¹ é€’å½’æ’å…¥çš„æ—¶å€™è¦é€šè¿‡ä¸€ä¸ªè¾…åŠ©å˜é‡æ¥æ›´æ–°æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆlow_countï¼‰ å¤„ç†å€¼ç›¸åŒæ—¶çš„æƒ…å†µå› ä¸ºæ’å…¥æ˜¯æ²¿ç€ä¸€æ¡è·¯å¾„ä¸‹å»çš„ï¼Œæ‰€ä»¥æ˜¯æ²¡æœ‰åŠæ³•åœ¨æ’å…¥çš„æ—¶å€™æ›´æ–°å…¨éƒ¨èŠ‚ç‚¹çš„ã€‚ ğŸ˜³æ–¹æ¡ˆä¸€æ˜¯ï¼šé€‰æ‹©å•ç‹¬åœ¨æ’å…¥ä¹‹åå†æ¥æ›´æ–°èŠ‚ç‚¹ã€‚ ğŸ˜³æ–¹æ¡ˆäºŒæ˜¯ï¼šæ›´æ–°ä¸€è¾¹çš„èŠ‚ç‚¹ï¼Œåœ¨è¿™ä¸ªé¢˜ç›®ä¸­ï¼Œæˆ‘ä»¬çš„é€‰æ‹©å°±æ˜¯åªæ›´æ–°å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œè¿™æ—¶Node-&gt;low_countä»£è¡¨çš„å°±ä¸æ˜¯å…¨ä½“ä¸­æ¯”å®ƒå°çš„èŠ‚ç‚¹æ•°é‡ï¼Œè€Œæ˜¯å½“å‰æ ¹èŠ‚ç‚¹ä¸‹æ¯”å®ƒå°çš„æ•°é‡ï¼Œè€Œå‘å³ç§»åŠ¨å°±æ˜¯åˆ‡æ¢æ ¹èŠ‚ç‚¹ã€‚å› ä¸ºæˆ‘ä»¬æ˜¯ä»¥æ ¹èŠ‚ç‚¹æ ‡å‡†å¼€å§‹è¿›è¡Œæ¯”è¾ƒï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨è¾…åŠ©å˜é‡æ›´æ–°èŠ‚ç‚¹æ˜¯æ›´æ–°ä¸åˆ°èµ·ç‚¹ä»¥å¤–çš„åœ°æ–¹çš„ã€‚ ğŸ¥¦æ–¹æ¡ˆäºŒï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: struct Node &#123; int low_count; //ç»Ÿè®¡æ¯”å®ƒå°çš„èŠ‚ç‚¹ int val; shared_ptr&lt;Node&gt; left, right; Node(int val, int count) : low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125; int compareTo(int k) &#123; if(val &lt; k) return -1; else if (val &gt; k) return 1; return 0; &#125; &#125;; int low_c = 0; shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123; if(!h) return make_shared&lt;Node&gt;(val ,0); int cmp = h-&gt;compareTo(val); if(cmp &gt;= 0) &#123; h-&gt;low_count += 1; h-&gt;left = insert(h-&gt;left, val); &#125; else if(cmp &lt; 0) &#123; low_c += h-&gt;low_count + 1; h-&gt;right = insert(h-&gt;right, val); &#125; return h; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; counts(nums.size()); if(!nums.size()) return counts; counts[0] = 0; if(nums.size() == 1) &#123; return counts; &#125; shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0); for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123; low_c = 0; head = insert(head, nums[i]); counts[i] = low_c; &#125; return counts; &#125;&#125;; Accepted16/16 cases passed (64 ms) Your runtime beats 55.66 % of cpp submissions Your memory usage beats 10.86 % of cpp submissions (29.7 MB) ğŸ…æ–¹æ¡ˆä¸€ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: struct Node &#123; int low_count; int val; shared_ptr&lt;Node&gt; left, right; Node(int val, int count) : low_count(count), val(val), left(nullptr), right(nullptr) &#123;&#125; int compareTo(int k) &#123; if(val &lt; k) return -1; else if (val &gt; k) return 1; return 0; &#125; &#125;; int Nsize( shared_ptr&lt;Node&gt; h) &#123; if(h) return h-&gt;low_count; return 0; &#125; shared_ptr&lt;Node&gt; insert(shared_ptr&lt;Node&gt; h, int val) &#123; if(!h) return make_shared&lt;Node&gt;(val ,0); int cmp = h-&gt;compareTo(val); if(cmp &gt;= 0) &#123; h-&gt;left = insert(h-&gt;left, val); &#125; else if(cmp &lt; 0) &#123; h-&gt;right = insert(h-&gt;right, val); &#125; return h; &#125; int g = 0; void rank(shared_ptr&lt;Node&gt; h) &#123; if(!h) return ; if(h-&gt;left) rank(h-&gt;left); h-&gt;low_count = g; g += 1; if(h-&gt;right) rank(h-&gt;right); &#125; int xx(shared_ptr&lt;Node&gt; h,int val) &#123; if(!h) return 0; while(h) &#123; int cmp = h-&gt;compareTo(val); if(cmp &lt; 0 ) h = h-&gt;right; else if(cmp &gt; 0) h = h-&gt;left; else if(cmp == 0 &amp;&amp; !h-&gt;left) break; else h = h-&gt;left; &#125; return h-&gt;low_count; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; counts(nums.size()); if(!nums.size()) return counts; counts[0] = 0; if(nums.size() == 1) &#123; return counts; &#125; shared_ptr&lt;Node&gt; head = make_shared&lt;Node&gt;(nums.back(), 0); for(int i = nums.size() - 2; i &gt;=0 ; -- i)&#123; head = insert(head, nums[i]); g = 0; rank(head); counts[i] = xx(head, nums[i]); &#125; return counts; &#125;&#125;; Time Limit Exceeded 15/16 cases passed (N/A) Testcase[5183,2271,3067,539,8939,2999,9264,737,3974,5846,-210,9278,5800,2675,6608,1133,-1,6018,9672,5179,9842,7424,-209,2988,2757,5984,1107,2644,-499,7234,7539,6525,347,5718,-742,1797,5292,976,8752,8297,1312,3385,5924,2882,6091,-282,2595,96,1906,8014,7667,5895,7283,7974,-167,7068,3946,6223,189,1589,2058,9277,-302,8157,8256,5261,8067,1071,9470,2682,8197,5632,753,3179,8187,9042,8167,4657,7080,7801,5627,7917,8085,928,-892,-427,3685,4676,2431,8064,8537,343,505,4352,2108,4399,66,2086,1922,9126,9460,393,443,5689,7595,850,8493,2866,732,3738,7933,3666,2370,5804,4045,7903,8009,5387,5542,7593,6862,1547,6934,-160,9693,4560,7429,9989,7232,-594,587,6476,9277,4471,5979,6268,2419,6706,-727,1927,7361,9684,5519,2703,1723â€¦..","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"449.åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘","slug":"leetcode449","date":"2020-01-17T07:16:05.000Z","updated":"2020-01-17T12:46:06.969Z","comments":true,"path":"2020/01/17/leetcode449/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode449/","excerpt":"","text":"é€’å½’å®ç°&emsp;&emsp;å…ˆåºéå†ï¼Œç±»ä¼¼äºæ•°ç»„è¡¨ç¤ºäºŒå‰æ ‘ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Codec &#123;public: void se_helper(TreeNode* root, string&amp; str) &#123; if(!root) &#123; str += &quot;x#&quot;; return ; &#125; str += to_string(root-&gt;val) + &apos;#&apos;; se_helper(root-&gt;left, str); se_helper(root-&gt;right, str); &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string s; se_helper(root, s); // cout &lt;&lt;s &lt;&lt; endl; return s; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if(data == &quot;x#&quot;) return nullptr; auto iter = data.begin(); return deserialize1(iter, data.end()); &#125; TreeNode* deserialize1(string::iterator&amp; iter, string::iterator end) &#123; if(iter == end) return nullptr; string s; while(*iter != &apos;#&apos;) &#123; s += *iter++; &#125; ++iter; if(s == &quot;x&quot;) return nullptr; int val = atoi(s.c_str()); TreeNode* newOne = new TreeNode(val); newOne-&gt;left = deserialize1(iter, end); newOne-&gt;right = deserialize1(iter, end); return newOne; &#125;&#125;; Accepted 62/62 cases passed (32 ms) Your runtime beats 87.21 % of cpp submissions Your memory usage beats 43.82 % of cpp submissions (24.2 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"538.æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘","slug":"leetcode538","date":"2020-01-17T06:40:09.000Z","updated":"2020-01-17T12:46:01.057Z","comments":true,"path":"2020/01/17/leetcode538/","link":"","permalink":"http://yoursite.com/2020/01/17/leetcode538/","excerpt":"","text":"é€’å½’å®ç°&emsp;&emsp; 1234567891011121314class Solution &#123;public: int k = 0; TreeNode* convertBST(TreeNode* root) &#123; if(!root) &#123; return nullptr; &#125; convertBST(root-&gt;right); k += root-&gt;val; root-&gt;val = k; convertBST(root-&gt;left); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"450.åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹","slug":"leetcode450","date":"2020-01-16T08:18:18.000Z","updated":"2020-01-16T08:19:12.318Z","comments":true,"path":"2020/01/16/leetcode450/","link":"","permalink":"http://yoursite.com/2020/01/16/leetcode450/","excerpt":"","text":"é€’å½’å®ç°&emsp;&emsp; 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int compar(int a, int b) &#123; if(a &gt; b) return 1; else if(b &gt; a) return -1; return 0; &#125; TreeNode* deleteNode(TreeNode* root, int key) &#123; if(!root) return nullptr; int cmp = compar(root-&gt;val, key); if(cmp &lt; 0) &#123; root-&gt;right = deleteNode(root-&gt;right, key); &#125; else if(cmp &gt; 0) &#123; root-&gt;left = deleteNode(root-&gt;left, key); &#125; else &#123; if(!root-&gt;left) return root-&gt;right; if(!root-&gt;right) return root-&gt;left; auto rm = min(root-&gt;right); root-&gt;right = deleteMin(root-&gt;right); rm-&gt;left = root-&gt;left; rm-&gt;right = root-&gt;right; root = rm; &#125; return root; &#125; TreeNode* min(TreeNode* root) &#123; if(!root-&gt;left) return root; return min(root-&gt;left); &#125; TreeNode* deleteMin(TreeNode* root) &#123; if(!root-&gt;left) return root-&gt;right; root-&gt;left = deleteMin(root-&gt;left); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"108.å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘","slug":"leetcode108","date":"2020-01-15T18:48:36.000Z","updated":"2020-01-15T18:50:54.812Z","comments":true,"path":"2020/01/16/leetcode108/","link":"","permalink":"http://yoursite.com/2020/01/16/leetcode108/","excerpt":"","text":"ğŸ¥›ä¸­åºæ„é€ &emsp;&emsp;ä¸ç”¨æ‹…å¿ƒmid+1è¶…å‡ºèŒƒå›´ï¼Œå› ä¸ºnums[mid]æ˜¯å­˜åœ¨çš„ï¼Œæ‰€ä»¥åœ¨æ„é€ ræ—¶ï¼Œnums.begin() + mid + 1æé™æ—¶å°±æ˜¯ä¸nums.end()ç›¸ç­‰ã€‚ 123456789101112131415class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums)&#123; if(!nums.size()) return nullptr; int mid = nums.size() / 2; TreeNode* root = new TreeNode(nums[mid]); vector&lt;int&gt; l(nums.begin(), nums.begin() + mid); vector&lt;int&gt; r(nums.begin() + mid + 1, nums.end()); root-&gt;left = sortedArrayToBST(l); root-&gt;right = sortedArrayToBST(r); return root; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"åœ¨C++ä¸­æ˜¯å¦æœ‰æ›¿ä»£INT_MINè¿™äº›å®å®šä¹‰çš„åŠŸèƒ½ï¼Ÿ","slug":"problems4","date":"2020-01-12T17:04:54.000Z","updated":"2020-01-12T17:13:48.000Z","comments":true,"path":"2020/01/13/problems4/","link":"","permalink":"http://yoursite.com/2020/01/13/problems4/","excerpt":"","text":"ğŸ“£åœ¨C++ä¸­æˆ‘ä»¬ä¾ç„¶å¯ä»¥åŒ…å« å¤´æ–‡ä»¶ï¼Œç„¶åå»ä½¿ç”¨INT_MINè¿™äº›å®å®šä¹‰,ä½†æ˜¯å…¶å®åœ¨C++ä¸­æ˜¯å­˜åœ¨æ›´åŠ ä¼˜é›…çš„æ–¹å¼çš„ 123#include &lt;limits&gt;std::numeric_limits&lt;int&gt;::min() //INT_MINstd::numeric_limits&lt;int&gt;::max() //INT_MAX","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å¦‚ä½•åˆ›å»ºæ•°ç»„çš„å…±äº«æŒ‡é’ˆ","slug":"problems3","date":"2020-01-12T02:56:38.000Z","updated":"2020-01-12T02:58:59.555Z","comments":true,"path":"2020/01/12/problems3/","link":"","permalink":"http://yoursite.com/2020/01/12/problems3/","excerpt":"","text":"C++11åœ¨shared_ptræ˜¯æ²¡æœ‰shared_ptr&lt;int []&gt;è¿™æ ·çš„ä¸œè¥¿çš„ï¼Œä½†æ˜¯std::unique_ptr&lt;int[]&gt;æ˜¯æœ‰çš„ 12345std::shared_ptr&lt;int[]&gt; a(new int[10]()); // é”™è¯¯ï¼Œc++17å‰ä¸èƒ½ä¼ é€’æ•°ç»„ç±»å‹ä½œä¸ºshared_ptrçš„æ¨¡æ¿å‚æ•°std::unique_ptr&lt;int[]&gt; b(new int[10]()); // ok, unique_ptrå¯¹æ­¤åšäº†ç‰¹åŒ–std::shared_ptr&lt;int&gt; c(new int[10]()); // é”™è¯¯ï¼Œå¯ä»¥ç¼–è¯‘ï¼Œä½†ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼Œè¯·ä¸è¦è¿™ä¹ˆåšstd::shared_ptr&lt;int&gt; sp3(new int[10](), std::default_delete&lt;int[]&gt;()); //æ­£ç¡®åšæ³•","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å­—å…¸","slug":"alg5","date":"2020-01-12T02:39:59.000Z","updated":"2020-01-21T08:14:22.906Z","comments":true,"path":"2020/01/12/alg5/","link":"","permalink":"http://yoursite.com/2020/01/12/alg5/","excerpt":"","text":"ğŸ¥£é“¾è¡¨å®ç°é“¾è¡¨å®ç°æ’å…¥ã€æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯Nï¼Œå¹¶éä¸€ä¸ªé«˜æ•ˆçš„å®ç°æ–¹å¼ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * é“¾è¡¨å®ç° **/template&lt;typename S, typename T&gt;class SequentialSearchST &#123; public: struct Node &#123; Node(const S&amp; key, const T&amp; val, shared_ptr&lt;Node&gt; next = nullptr) :key(key), val(val), next(next) &#123;&#125; const S key; T val; shared_ptr&lt;Node&gt; next; &#125;; void show() const; void put(S key, T val); const T get(const S&amp; key) const; bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; private: shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;const T SequentialSearchST&lt;S,T&gt;::get(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return T(); return sk-&gt;val;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::put(S key, T val) &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(sk) sk-&gt;val = val; else &#123; shared_ptr&lt;Node&gt; newOne(make_shared&lt;Node&gt;(key, val, head)); head = newOne; &#125;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::show() const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; cout &lt;&lt; sk-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; sk-&gt;val &lt;&lt; endl; sk = sk-&gt;next; &#125;&#125;template&lt;typename S, typename T&gt;bool SequentialSearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return false; return true;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; SequentialSearchST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; res.push_back(sk-&gt;key); sk = sk-&gt;next; &#125; return res;&#125; ğŸš†æ”¹è¿›1ï¼šæ”¹ç”¨æ•°ç»„å®ç°ï¼ŒäºŒåˆ†æŸ¥æ‰¾æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦é™ä½ä¸ºlgNï¼Œä½†æ˜¯å› ä¸ºæ•°ç»„ç§»ä½çš„åŸå› ï¼Œæ’å…¥çš„æ—¶é—´å¤æ‚åº¦è¿˜æ˜¯N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * æ•°ç»„å®ç° **/template&lt;typename S, typename T&gt;class BinarySearchST &#123; public: BinarySearchST(int size = 10000); ~BinarySearchST(); void put(const S&amp;, const T&amp;); const T get(const S&amp;); bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; void show() const; private: const int rank(const S&amp;) const; S* _keys; T* vals; int _capacity; int n;&#125;;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::BinarySearchST(int size) : _keys(new S[size]), vals(new T[size]), _capacity(size), n(0)&#123;&#125;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::~BinarySearchST()&#123; delete []_keys; delete []vals;&#125;template&lt;typename S, typename T&gt;const int BinarySearchST&lt;S,T&gt;::rank(const S&amp; key) const&#123; if(n == 0) return 0; int lo = 0, hi = n - 1, mid; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if(_keys[mid] &lt; key) lo = mid + 1; else hi = mid; &#125; if(_keys[lo] &lt; key) return lo + 1; else return lo;&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val)&#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; vals[pos] = val; return ; &#125; //æš‚æ—¶ä¸è€ƒè™‘è¶…å‡ºå®¹é‡çš„æƒ…å†µ for(int i = n; i &gt; pos; --i) &#123; _keys[i] = _keys[i - 1]; vals[i] = vals[i - 1]; &#125; _keys[pos] = key; vals[pos] = val; ++n;&#125;template&lt;typename S, typename T&gt;const T BinarySearchST&lt;S,T&gt;::get(const S&amp; key) &#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; return vals[pos]; &#125; return T();&#125;template&lt;typename S, typename T&gt;bool BinarySearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; if(!n) return false; int pos = rank(key); return _keys[pos] == key;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BinarySearchST&lt;S,T&gt;::keys() const &#123; return vector&lt;S&gt;(_keys, _keys + n);&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::show() const &#123; for(int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; _keys[i] &lt;&lt; &quot; &quot; &lt;&lt; vals[i] &lt;&lt; endl; &#125;&#125; ğŸš†æ”¹è¿›2ï¼šæ”¹ç”¨äºŒå‰æŸ¥æ‰¾æ ‘æŸ¥æ‰¾ã€ä¿®æ”¹çš„å¹³å‡æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯lgNï¼Œä½†æ˜¯æœ€åæƒ…å†µä¸¤è€…éƒ½é€€å›åˆ°N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * äºŒå‰æŸ¥æ‰¾æ ‘çš„å®ç° **/#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * äºŒå‰æŸ¥æ‰¾æ ‘çš„å®ç° **/template&lt;typename S, typename T&gt;class BST&#123; public: struct Node &#123; const S key; T val; shared_ptr&lt;Node&gt; left, right; int N; Node(const S&amp;key, const T&amp; val, int N) : key(key), val(val), left(), right(), N(N) &#123;&#125; int compareTo(shared_ptr&lt;Node&gt; node) const; int compareTo(const S&amp;) const; static int Nsize(shared_ptr&lt;Node&gt; x); &#125;; const S min() const; const S max() const; bool contain(const S&amp;) const; const T get(const S&amp;) const; void put(const S&amp; key, const T&amp; val); void show() const; //è°ƒè¯• const vector&lt;S&gt; keys() const; const S floor(const S&amp; key) const; const S ceiling(const S&amp;key) const; const S select(int x) const; const int rank(const T&amp;) const; void deleteMin(); void delet(const T&amp; key); private: shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt; nd, const T&amp; key); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); const int _rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const; shared_ptr&lt;Node&gt; _select(shared_ptr&lt;Node&gt; nd, int x) const; shared_ptr&lt;Node&gt; _floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const; shared_ptr&lt;Node&gt; _ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const; shared_ptr&lt;Node&gt; _min(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _max(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val); const T _get(shared_ptr&lt;Node&gt; x,const S&amp;) const; void _show(shared_ptr&lt;Node&gt; x) const; void _keys(vector&lt;S&gt;&amp;, shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val) &#123; head = _put(head, key, val);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val) &#123; if(!x) return make_shared&lt;Node&gt;(key, val, 1); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) x-&gt;left = _put(x-&gt;left, key, val); else if(cmp &lt; 0) x-&gt;right = _put(x-&gt;right, key, val); else x-&gt;val = val; x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;/** * &gt; 1 * = 0 * &lt; -1 **/ template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(shared_ptr&lt;Node&gt; node) const &#123; return compareTo(node-&gt;key);&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(const S&amp; key2) const &#123; return key &gt; key2 ? 1 : key &lt; key2 ? -1 : 0;&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x) &#123; if(!x) return 0; else return x-&gt;N;&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::get(const S&amp; key) const &#123; return _get(head, key);&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::_get(shared_ptr&lt;Node&gt; x,const S&amp; key) const &#123; if(!x) return T(); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) return _get(x-&gt;right, key); else if(cmp &lt; 0) return _get(x-&gt;left, key); else return x-&gt;val;&#125;template&lt;typename S, typename T&gt;bool BST&lt;S,T&gt;::contain(const S&amp; key) const &#123; return get(key) != T();&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::show() const &#123; _show(head);&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_show(shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; if(x-&gt;left) _show(x-&gt;left); cout &lt;&lt; x-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; x-&gt;val &lt;&lt; endl; if(x-&gt;right) _show(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; _keys(res, head); return res;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_keys(vector&lt;S&gt;&amp; res, shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; res.push_back(x-&gt;key); _keys(res,x-&gt;left); _keys(res, x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::min() const &#123; if(!head) return S(); return _min(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_min(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;left) return x; else return _min(x-&gt;left);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::max() const &#123; if(!head) return S(); return _max(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_max(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;right) return x; else return _max(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::floor(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; nd = _floor(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::ceiling(const S&amp;key) const &#123; shared_ptr&lt;Node&gt; nd = _ceiling(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(cmp == 0) return x; else if (cmp &gt; 0) return _floor(x-&gt;left, key); shared_ptr&lt;Node&gt; y = _floor(x-&gt;right, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(!cmp) return x; else if(cmp &lt; 0) return _ceiling(x-&gt;right, key); shared_ptr&lt;Node&gt; y = _ceiling(x-&gt;left, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::select(int x) const &#123; if(x &lt; 0 || x &gt;= head-&gt;N) return S(); auto nd = _select(head, x); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_select(shared_ptr&lt;Node&gt; nd, int x) const &#123; if(!nd) return nd; int nd_rank = Node::Nsize(nd-&gt;left); if(nd_rank &gt; x) return _select(nd-&gt;left, x); else if (nd_rank &lt; x) return _select(nd-&gt;right, x - nd_rank - 1); return nd;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::rank(const T&amp; key) const &#123; int rk = _rank(head, key); // if(select(rk) != key) // return -1; return rk;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::_rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const &#123; if(!nd) return 0; int nd_rank = Node::Nsize(nd-&gt;left); if(nd-&gt;key &lt; key) return nd_rank + 1 + _rank(nd-&gt;right, key); else if(nd-&gt;key &gt; key) return _rank(nd-&gt;left, key); return nd_rank;&#125;/** * è¿™ä¸ªå‡½æ•°åªèƒ½åˆ é™¤æ ¹èŠ‚ç‚¹å·¦è¾¹çš„ **/ template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::deleteMin() &#123; deleteMin(head);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::deleteMin(shared_ptr&lt;Node&gt; x) &#123; if(!x-&gt;left) return x-&gt;right; x-&gt;left = deleteMin(x-&gt;left); x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::delet(const T&amp; key) &#123; head = delet(head, key);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::delet(shared_ptr&lt;Node&gt; nd, const T&amp; key)&#123; if(!nd) &#123; return nd; &#125; int cmp = nd-&gt;compareTo(key); if(cmp &lt; 0) &#123; nd-&gt;right = delet(nd-&gt;right, key); &#125; else if(cmp &gt; 0) &#123; nd -&gt;left = delet(nd-&gt;left, key); &#125; else &#123; if(!nd-&gt;left) return nd-&gt;right; if(!nd-&gt;right) return nd-&gt;left; auto minO = _min(nd-&gt;right); minO-&gt;right = deleteMin(nd-&gt;right); minO-&gt;left = nd-&gt;left; nd = minO; &#125; nd-&gt;N = Node::Nsize(nd-&gt;left) + Node::Nsize(nd-&gt;right) + 1; return nd;&#125; ğŸš†æ”¹è¿›3ï¼šçº¢é»‘æ ‘æŸ¥æ‰¾ã€æ’å…¥çš„æ—¶é—´å¤æ‚åº¦æ’å®šä¸ºlogN 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394/* * @Author: XiaoGongBai * @Date: 2020-01-19 10:21:20 * @Last Modified by: XiaoGongBai * @Last Modified time: 2020-01-19 11:31:04 */#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * çº¢é»‘æ ‘ **/enum class Color&#123; Red , Black &#125;;template&lt;typename Key, typename Val&gt;class RedBlackBST&#123; public: struct Node&#123; Key key; Val val; shared_ptr&lt;Node&gt; left,right; int N; Color color; Node(const Key&amp; key, const Val&amp; val, int N, Color color) :key(key), val(val), left(), right(), N(N), color(color) &#123;&#125; static int Nsize(shared_ptr&lt;Node&gt; x); int compareTo(const Key&amp; key) const; &#125;; void put(const Key&amp; key, const Val&amp; val); shared_ptr&lt;Node&gt; get(const Key&amp; key) const; void deleteMin(); void deleteMax(); void delet(const Key&amp;); Key min() const; Key max() const; vector&lt;Key&gt; keys(const Key&amp; m, const Key&amp; e) const; vector&lt;Key&gt; keys() const; const int size() const &#123;return root ? root-&gt;N : 0;&#125; private: shared_ptr&lt;Node&gt; root; void keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const; shared_ptr&lt;Node&gt; max(shared_ptr&lt;Node&gt; h) const; shared_ptr&lt;Node&gt; min(shared_ptr&lt;Node&gt;) const; shared_ptr&lt;Node&gt; get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const; shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt;, const Key&amp;); shared_ptr&lt;Node&gt; balance(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedLeft(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedRight(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMax(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val); void flipColor(shared_ptr&lt;Node&gt; h); shared_ptr&lt;Node&gt; rotateLeft(shared_ptr&lt;Node&gt; node); shared_ptr&lt;Node&gt; rotateRight(shared_ptr&lt;Node&gt; h); bool isRed(shared_ptr&lt;Node&gt; node) const; &#125;;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x)&#123; return x ? x-&gt;N : 0; &#125;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::compareTo(const Key&amp; key) const&#123; if(key &gt; this-&gt;key) &#123; return -1; &#125; else if(key &lt; this-&gt;key) &#123; return 1; &#125; return 0;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateLeft(shared_ptr&lt;Node&gt; h)&#123; if(!h) return nullptr; auto rh = h-&gt;right; if(!rh) return h; h-&gt;right = rh-&gt;left; rh-&gt;left = h; rh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, rh-&gt;color); return rh;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateRight(shared_ptr&lt;Node&gt; h)&#123; if(!h) &#123; return nullptr; &#125; auto lh = h-&gt;left; if(!lh) return h; h-&gt;left = lh-&gt;right;; lh-&gt;right = h; lh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, lh-&gt;color); return lh;&#125;template&lt;typename Key, typename Val&gt;bool RedBlackBST&lt;Key,Val&gt;::isRed(shared_ptr&lt;Node&gt; h) const&#123; if(!h || h-&gt;color == Color::Black) return false; return true;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::put(const Key&amp; key, const Val&amp; val)&#123; root = put(root, key, val); root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val)&#123; if(!h) return make_shared&lt;Node&gt;(key, val, 1, Color::Red); int cmp = h-&gt;compareTo(key); if(cmp &lt; 0) &#123; h-&gt;right = put(h-&gt;right, key, val); &#125; else if (cmp &gt; 0) &#123; h-&gt;left = put(h-&gt;left, key, val); &#125; else &#123; h-&gt;val =val; &#125; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::flipColor(shared_ptr&lt;Node&gt; h)&#123; h-&gt;color = h-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;right-&gt;color = h-&gt;right-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;left-&gt;color = h-&gt;left-&gt;color == Color::Black ? Color::Red : Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(const Key&amp; key) const&#123; return get(root, key);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const&#123; if(!h) return nullptr; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; return get(h-&gt;left, key); &#125; else if (cmp &lt; 0) &#123; return get(h-&gt;right, key); &#125; else return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMin()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMin(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMin(shared_ptr&lt;Node&gt; h) &#123; if(!h-&gt;left) return h-&gt;right; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) &#123; h = removeRedLeft(h); &#125; h-&gt;left = deleteMin(h-&gt;left); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedLeft(shared_ptr&lt;Node&gt; h) &#123; flipColor(h); if(isRed(h-&gt;right) &amp;&amp; isRed(h-&gt;right-&gt;left)) &#123; h-&gt;right = rotateRight(h-&gt;right); h = rotateLeft(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::balance(shared_ptr&lt;Node&gt; h)&#123; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;KeyRedBlackBST&lt;Key,Val&gt;::min() const&#123; if(!root) return Val(); return min(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::min(shared_ptr&lt;Node&gt; h) const &#123; if(!h-&gt;left) return h; return min(h-&gt;left);&#125;template&lt;typename Key, typename Val&gt;Key RedBlackBST&lt;Key,Val&gt;::max() const&#123; if(!root) return Val(); return max(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::max(shared_ptr&lt;Node&gt; h) const&#123; if(!h-&gt;right) return h; return max(h-&gt;right);&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMax()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMax(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMax(shared_ptr&lt;Node&gt; h)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!h-&gt;right) return h-&gt;left; if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) h = removeRedRight(h); h-&gt;right = deleteMax(h-&gt;right); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedRight(shared_ptr&lt;Node&gt; h)&#123; flipColor(h); if(isRed(h-&gt;left-&gt;left)) &#123; h = rotateRight(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::delet(const Key&amp; key)&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = delet(root, key); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::delet(shared_ptr&lt;Node&gt; h, const Key&amp; key) &#123; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) h = removeRedLeft(h); h-&gt;left = delet(h-&gt;left, key); &#125; else if(cmp &lt; 0)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) &#123; h = removeRedRight(h); &#125; h-&gt;right = delet(h-&gt;right, key); &#125; else &#123; if(!h-&gt;right) return h-&gt;left; h-&gt;val = get(h-&gt;right, min(h-&gt;right)-&gt;key)-&gt;val; h-&gt;key = min(h-&gt;right)-&gt;key; h-&gt;right = deleteMin(h-&gt;right); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys(const Key&amp; m, const Key&amp; e) const&#123; vector&lt;Key&gt; res; keys(root, res, m, e); return res;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const&#123; if(!h) return ; int cmp1 = h-&gt;compareTo(m), cmp2 = h-&gt;compareTo(e); if(cmp1 &gt;= 0 &amp;&amp; cmp2 &lt;= 0) &#123; res.push_back(h-&gt;key); &#125; if(cmp1 &gt; 0) &#123; keys(h-&gt;left, res, m, e); &#125; if(cmp2 &lt; 0) &#123; keys(h-&gt;right, res, m, e); &#125;&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys() const&#123; return keys(min(), max());&#125;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"179.æœ€å¤§æ•°","slug":"leetcode179","date":"2020-01-11T12:18:40.000Z","updated":"2020-01-11T13:53:52.979Z","comments":true,"path":"2020/01/11/leetcode179/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode179/","excerpt":"","text":"ğŸ¥©å †æ’åº&emsp;&emsp;å †æ’åºï¼Œç„¶åå°†æ•°å­—æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸¤ä¸ªæ•°å­—ä¹‹é—´çš„æ¯”è¾ƒå¹¶ä¸èƒ½ç›´æ¥ç”¨&gt;&lt;æ¥è¿›è¡Œã€‚æˆ‘çš„æ–¹æ³•æ˜¯å®šä¹‰compareå‡½æ•°ï¼Œè¿›è¡Œæ¯”è¾ƒã€‚compareæ¯”è¾ƒä¸¤ä¸ªæ•°çš„æ–¹æ³•æ˜¯ï¼šæ¯”å¦‚121ï¼Œ12ï¼Œé‚£ä¹ˆå°±æ¯”è¾ƒ121|12å’Œ12|121çš„å¤§å° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; a) &#123; if(!a.size()) return &quot;&quot;; string s; //å †æ’åº a.insert(a.begin(), -1); int n = a.size() - 1; for(int i = 2; i &lt;= n; ++i) &#123; swim(a, i, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; while(n &gt; 1) &#123; swap(a[1], a[n--]); sink(a, 1, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; for(int i = 1; i &lt; a.size(); ++i) s += to_string(a[i]); int ct = 0; for(int i = 0; i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;; ++i) &#123; ++ct; &#125; if(ct == s.size()) return &quot;0&quot;; return s.substr(ct); &#125; void swim(vector&lt;int&gt;&amp; a, int k, int n) &#123; cout &lt;&lt; &quot;swim&quot; &lt;&lt; endl; int j; while(k &gt; 1) &#123; j = k /2; if(j &gt;= 1 &amp;&amp; compare(a[j],a[k]) != 1) break; swap(a[j], a[k]); k = j; &#125; &#125; void sink(vector&lt;int&gt;&amp; a, int k, int n) &#123; int j ; while(k &lt;= n / 2) &#123; j = 2 * k; if(j + 1 &lt;= n &amp;&amp; compare(a[j + 1], a[j]) == -1) ++j; if(compare(a[j], a[k]) != -1) break; swap(a[j], a[k]); k = j; &#125; &#125; int compare(int i, int j) &#123; if(i == j) return 0; int com = 0, ix = 0, jx = 0, ii = i, jj = j; while(ii / 10 &gt; 0) &#123; ix++; ii /= 10; &#125; while(jj / 10 &gt; 0) &#123; jx++; jj /= 10; &#125; long long ir ,jr; jr = j * pow(10, ix + 1) + i; ir = i * pow(10, jx + 1) + j; // cout &lt;&lt; &quot;i, j: &quot; &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; jr &lt;&lt; endl; if(ir &gt; jr) return 1; else if(jr &gt; ir) return -1; else return 0; &#125;&#125;; Accepted222/222 cases passed (8 ms) Your runtime beats 91.43 % of cpp submissions Your memory usage beats 79.45 % of cpp submissions (9.1 MB) ğŸˆ¶æ”¹è¿›&emsp;&emsp;ç›¸æ¯”ä¸æˆ‘å°†ä¸¤ä¸ªæ•°æ‹¼åœ¨ä¸€èµ·æ¯”è¾ƒï¼Œæ›´åŠ å¥½çš„æ–¹æ³•æ˜¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒ 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if (all_of(nums.begin(), nums.end(), [](int x) &#123; return x == 0; &#125;)) &#123; return string(&quot;0&quot;); &#125; vector&lt;string&gt; strNums(nums.size()); std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123; return std::to_string(x); &#125;); std::sort(strNums.begin(), strNums.end(), [](const string&amp; x, const string&amp; y) &#123; /* xä¸ºåé¢å…ƒç´ ï¼Œyä¸ºå‰é¢å…ƒç´ ï¼Œreturn trueåˆ™å°†xç§»åŠ¨åˆ°å‰é¢ */ return x + y &gt; y + x; &#125;); return std::accumulate(strNums.begin(), strNums.end(), string()); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"147.å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº","slug":"leetcode147","date":"2020-01-11T07:55:04.000Z","updated":"2020-01-11T11:51:35.600Z","comments":true,"path":"2020/01/11/leetcode147/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode147/","excerpt":"","text":"ğŸ¥§æ¨¡ä»¿æ•°ç»„çš„å®ç°&emsp;&emsp;æ³¨æ„preæŒ‡é’ˆçš„è°ƒæ•´ï¼Œåœ¨å†…å¾ªç¯æ”¹å˜ä¸€ä¸ªèŠ‚ç‚¹ptrçš„ä½ç½®åï¼Œå¤–å±‚å¾ªç¯çš„ptrçš„ä¸‹ä¸€ä¸ªå¾ªç¯å°±ä¸æ˜¯ptr-&gt;nextäº†ï¼Œè€Œæ˜¯pre-&gt;next 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head-&gt;next, *nex, *pre = head,*ptr2, *pre2, npre = ListNode(INT_MIN); npre.next = head; for( ; ptr != nullptr; ) &#123; for(ptr2 = npre.next, pre2 = &amp;npre; ptr2 != ptr; ptr2 = ptr2-&gt;next, pre2 = pre2-&gt;next)&#123; if(ptr2-&gt;val &gt;= ptr-&gt;val) &#123; pre-&gt;next = ptr-&gt;next; ptr-&gt;next = ptr2; pre2-&gt;next = ptr; break; &#125; &#125; if(ptr2 == ptr) &#123; ptr = ptr-&gt;next; pre = pre-&gt;next; &#125; else &#123; ptr = pre-&gt;next; &#125; // for(auto x = &amp;npre; x != nullptr; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; &#125; return npre.next; &#125;&#125;; Accepted 22/22 cases passed (100 ms) Your runtime beats 6.64 % of cpp submissions Your memory usage beats 13.73 % of cpp submissions (9.7 MB) ğŸ†æ”¹è¿›ç‰ˆ&emsp;&emsp;å¯¹äºæ’å…¥æ’åºæ¥è¯´ï¼Œæˆ‘ä»¬æ²¡æœ‰å¿…è¦è®°å½•é‚£ä¹ˆå¤šå‰ç½®èŠ‚ç‚¹çš„ä½ç½®ï¼Œæˆ‘ä»¬åªè¦ä¿è¯ptrå·¦è¾¹çš„åºåˆ—æœ‰åºå³å¯ 1234567891011121314151617181920212223class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head, *nex,*ptr2, npre = ListNode(INT_MIN); while(ptr) &#123; nex = ptr-&gt;next; ptr2 = &amp;npre; while(ptr2-&gt;next &amp;&amp; ptr2-&gt;next-&gt;val &lt; ptr-&gt;val) ptr2 = ptr2-&gt;next; ptr-&gt;next = ptr2-&gt;next; ptr2-&gt;next = ptr; // for(auto x = &amp;npre; x != NULL; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; &quot; cur: &quot; &lt;&lt; ptr-&gt;val &lt;&lt; endl; ptr = nex; &#125; return npre.next; &#125;&#125;; Accepted22/22 cases passed (48 ms)Your runtime beats 73.88 % of cpp submissions Your memory usage beats 15.9 % of cpp submissions (9.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"56.åˆå¹¶åŒºé—´","slug":"leetcode56","date":"2020-01-11T06:50:05.000Z","updated":"2020-01-11T07:20:33.360Z","comments":true,"path":"2020/01/11/leetcode56/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode56/","excerpt":"","text":"ğŸ¥›ä½¿ç”¨æ•°ç»„&emsp;&emsp;ä½¿ç”¨æ•°ç»„æ¥è¿›è¡Œæ“ä½œï¼Œç‰¹åˆ«[0,1][2,4]è¿™æ ·è¿åœ¨ä¸€èµ·ã€‚å´æ²¡æœ‰ç›¸äº¤çš„æƒ…å†µ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; char arr[3000] = &quot;&quot;; vector&lt;vector&lt;int&gt;&gt; res; for(auto x : intervals) &#123; memset(arr + x[0], &apos;1&apos; ,x[1] - x[0]); if(arr[x[1]] != &apos;1&apos;) arr[x[1]] = &apos;2&apos;; else arr[x[1]] = &apos;1&apos;; &#125; int count = 0, k; for(int i = 0; i &lt; 3000; ++i) &#123; if(arr[i] != &apos;\\0&apos;) &#123; count = 0; for(k = i; k &lt; 3000 &amp;&amp; arr[k] == &apos;1&apos;; ++k) &#123; arr[k] = &apos;\\0&apos;; ++count; &#125; arr[k] = &apos;\\0&apos;; res.push_back(vector&lt;int&gt;&#123;i, i + count&#125;); &#125; &#125; return res; &#125;&#125;; Accepted169/169 cases passed (20 ms)Your runtime beats 90.61 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (13.3 MB) ğŸš†æ’åºåæ¯”è¾ƒ&emsp;&emsp; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a ,const vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0]; &#125;); // for(auto x : intervals) &#123; // cout &lt;&lt; x[0] &lt;&lt; x[1] &lt;&lt; endl; // &#125; int i = 0, beg, endx, n = intervals.size(); while(i &lt; n) &#123; beg = intervals[i][0]; endx = intervals[i][1]; while(i &lt; n - 1&amp;&amp; intervals[i + 1][0] &lt;= endx) &#123; ++i; if(intervals[i][1] &gt; endx) endx = intervals[i][1]; &#125; // cout &lt;&lt; beg &lt;&lt; &quot; &quot; &lt;&lt; endx &lt;&lt; endl; res.push_back(vector&lt;int&gt;&#123;beg, endx&#125;); ++i; &#125; return res; &#125;&#125;; Accepted 169/169 cases passed (12 ms)Your runtime beats 99.88 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (12.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"75.é¢œè‰²åˆ†ç±»","slug":"leetcode75","date":"2020-01-11T03:33:29.000Z","updated":"2020-01-11T08:13:03.417Z","comments":true,"path":"2020/01/11/leetcode75/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode75/","excerpt":"","text":"ğŸ¥§å…¸å‹çš„å †æ’åºé¢˜ç›®&emsp;&emsp; 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; nums.insert(nums.begin(), 0); int n = nums.size() - 1; for(int i = n / 2; i &gt;= 1; --i) &#123; sink(nums, i, n); &#125; while(n &gt; 1) &#123; swap(nums[1], nums[n--]); sink(nums, 1, n); &#125; nums.erase(nums.begin()); &#125; void sink(vector&lt;int&gt;&amp; nums, int k,int n) &#123; int j; while(k &lt;= n / 2) &#123; j = k * 2; if(nums[j] &lt; nums[j + 1] &amp;&amp; j + 1 &lt;= n) ++j; if(nums[k] &gt;= nums[j]) break; swap(nums[k], nums[j]); k = j; &#125; &#125;&#125;; Accepted87/87 cases passed (0 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 5.17 % of cpp submissions (8.9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨","slug":"leetcode21","date":"2020-01-11T03:18:02.000Z","updated":"2020-01-23T12:53:20.141Z","comments":true,"path":"2020/01/11/leetcode21/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode21/","excerpt":"","text":"ğŸ¥›è¿­ä»£&emsp;&emsp;ç±»ä¼¼ä¸å½’å¹¶æ’åºçš„åˆå¹¶å‡½æ•°ï¼Œå®é™…è¿˜è¦æ›´ç®€å•ä¸€äº›ï¼Œæ²¡æœ‰é•¿åº¦çš„é™åˆ¶ 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode nd(0), *pre = &amp;nd; while(l1 || l2) &#123; if(!l1) &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; else if(!l2) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else if(l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; return nd.next; &#125;&#125;; Accepted208/208 cases passed (8 ms)Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 76.07 % of cpp submissions (9 MB) ğŸ¥›é€’å½’12345678910111213141516class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; else if(l2-&gt;val &lt; l1-&gt;val) &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; else &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; &#125;&#125;; Accepted208/208 cases passed (8 ms) Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 75.58 % of cpp submissions (9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"148. æ’åºé“¾è¡¨","slug":"leetcode148","date":"2020-01-10T16:51:18.000Z","updated":"2020-01-11T06:27:48.055Z","comments":true,"path":"2020/01/11/leetcode148/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode148/","excerpt":"","text":"ğŸ¥©è‡ªé¡¶å‘ä¸‹å½’å¹¶æ’åº&emsp;&emsp;åŸºç¡€ç‰ˆï¼Œæ ¹æ®ç®—æ³•4ä¸­çš„æ•°ç»„çš„å½’å¹¶ç®—æ³•æ”¹å¾— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head) return head; n = 1; ListNode* h = head; while(h-&gt;next != NULL) &#123; h = h-&gt;next; ++n; &#125; //cout &lt;&lt; &quot;count : &quot; &lt;&lt; n &lt;&lt; endl; aux = new int[n](); sortList(head, 0, n - 1); return head; &#125; void sortList(ListNode* head, int i, int j) &#123; if(i &gt;= j) return ; int mid = i + (j - i) / 2; sortList(head, i, mid); sortList(head, mid + 1, j); merge(head, i, mid, j); &#125; void merge(ListNode* head, int i,int mid, int j) &#123; //cout &lt;&lt; &quot;i,m.j : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ListNode* inode = at(head, i),* inode2 = inode; //cout &lt;&lt; &quot;inode-&gt;val: &quot; &lt;&lt; inode2-&gt;val &lt;&lt; endl; int lo = i - i, hi = mid + 1 - i; for(int k = 0; k &lt;= j - i; ++k , inode = inode-&gt;next) aux[k + i] = inode-&gt;val; // for(int k = i; k &lt;= j; ++k) &#123; //cout &lt;&lt; aux[k] &lt;&lt; &quot; &quot;; // &#125; //cout &lt;&lt; endl; for(int k = 0; k &lt;= j - i; ++k) &#123; if(lo &gt; mid - i)&#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else if (hi &gt; j - i) &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; else if (aux[lo + i] &gt; aux[hi + i]) &#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; //cout &lt;&lt; &quot;lo, hi : &quot; &lt;&lt; lo &lt;&lt; &quot; &quot; &lt;&lt; hi &lt;&lt; endl; inode2 = inode2-&gt;next; &#125; &#125; ListNode* at(ListNode* head, int n) &#123; while(n--) head = head-&gt;next; return head; &#125; int* aux; int n;&#125;; Accepted16/16 cases passed (1108 ms) Your runtime beats 5.09 % of cpp submissionsYour memory usage beats 62.56 % of cpp submissions (12.3 MB) ğŸ¥§è‡ªé¡¶å‘ä¸‹å½’å¹¶æ’åº2&emsp;&emsp;å­¦ä¹ è‡ªé“¾æ¥,ä»¥ä¸€ç§é“¾è¡¨å¾—æ–¹å¼æ¥åšï¼Œè€Œä¸æ˜¯ä»¥æ•°ç»„å¾—æ–¹å¼æ¥æ€è€ƒ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, * fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = nullptr; ListNode* left = sortList(head); ListNode* right = sortList(tmp); ListNode thead = ListNode(-1), *thd = &amp;thead; while(left || right) &#123; if(!left) &#123; thd-&gt;next = right; right = right-&gt;next; &#125; else if(!right) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else if (right-&gt;val &gt; left-&gt;val) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else &#123; thd-&gt;next = right; right = right-&gt;next; &#125; thd = thd-&gt;next; &#125; return thead.next; &#125; &#125;; Accepted 16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 72.66 % of cpp submissions (11.9 MB) ğŸ¥£è‡ªåº•å‘ä¸Šå½’å¹¶æ’åº&emsp;&emsp;å­¦ä¹ è‡ªé“¾æ¥ï¼Œè‡ªåº•å‘ä¸Šå¾—é“¾è¡¨ï¼Œæœ‰å‡ ä¸ªéš¾ç‚¹: å¦‚ä½•æ¯æ¬¡mergeåä¸åé¢å¾—é“¾è¡¨æ¥ä¸Š å¦‚ä½•ä¸²è”æˆä¸€ä¸ªé•¿å¾—é“¾è¡¨æœ€åè¿”å›1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* preNode = new ListNode(0), *pre = preNode; pre-&gt;next = head; int count = 0; while((pre = pre-&gt;next) &amp;&amp; ++count) ; // cout &lt;&lt; &quot;count : &quot; &lt;&lt; count &lt;&lt; endl; pre = preNode; for(int sz = 1; sz &lt; count; sz *=2) &#123; while(pre = sortList(pre, sz)) ; pre = preNode; &#125; return preNode-&gt;next; &#125; ListNode* sortList(ListNode* pre, int sz) &#123; ListNode* fl = pre-&gt;next, *ll = pre-&gt;next; for(int i = 0; i &lt; sz ; ++i) &#123; if(!ll) return nullptr; ll =ll-&gt;next; &#125; int lc = 0, fc = 0; while(fc &lt; sz) &#123; if(lc == sz || ll == nullptr || ll-&gt;val &gt; fl-&gt;val) &#123; ++fc; pre-&gt;next = fl; fl = fl-&gt;next; &#125; else &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; &#125; pre = pre-&gt;next; &#125; while(lc &lt; sz &amp;&amp; ll) &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next = ll; return pre; &#125;&#125;; Accepted16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 93.48 % of cpp submissions (11.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"å †æ’åº","slug":"alg4","date":"2020-01-10T14:59:59.000Z","updated":"2020-01-10T15:32:32.295Z","comments":true,"path":"2020/01/10/alg4/","link":"","permalink":"http://yoursite.com/2020/01/10/alg4/","excerpt":"","text":"ğŸ˜˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * å †æ’åº **/template&lt;typename T&gt;class HeapSort &#123; public: static void sort(vector&lt;T&gt;&amp;); private: static void sink(vector&lt;T&gt;&amp; a, int k, int N);&#125;;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123; int N = a.size() - 1; for(int i = N / 2; i &gt;= 1; --i) sink(a, i, N); while(N &gt; 1) &#123; swap(a[1], a[N--]); sink(a, 1, N); &#125;&#125;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123; int j; while(k &lt;= N / 2) &#123; j = 2 * k; if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j; if(a[k] &gt;= a[j]) break; swap(a[k], a[j]); k = j; &#125;&#125; ğŸ‘¿æ³¨æ„ è¦æ³¨æ„çˆ¶èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹æ—¶çš„æƒ…å†µï¼Œåœ¨sinkå‡½æ•°ä¸­ï¼ˆif(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;ï¼‰ä¸€å®šè¦æ³¨æ„j&lt;Nï¼Œä¸èƒ½è¶…å‡ºèŒƒå›´ æ„é€ æœ€å¤§å †æ—¶ï¼Œforå¾ªç¯ä»i = N / 2å¼€å§‹çš„åŸå› æ˜¯ï¼šsinkä¸­æœ‰é™åˆ¶æ¡ä»¶while(k &lt;= N / 2)ï¼Œæ‰€ä»¥N/2&lt;i&lt;Néƒ¨åˆ†æ— æ³•è¿›å…¥sinkçš„whileå¾ªç¯ï¼Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå¾’å¢N/2æ¬¡æ¯”è¾ƒ é€’å¢æ’åºä½¿ç”¨æœ€å¤§å †ï¼Œé€’å‡æ’åºä½¿ç”¨æœ€å°å † vectorçš„ç¬¬ä¸€ä¸ªå€¼ï¼ˆä¸‹æ ‡ä¸º0ï¼‰ä¸ä½¿ç”¨","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ç´¢å¼•ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg3","date":"2020-01-10T08:36:33.000Z","updated":"2020-01-10T14:28:54.460Z","comments":true,"path":"2020/01/10/alg3/","link":"","permalink":"http://yoursite.com/2020/01/10/alg3/","excerpt":"","text":"ğŸ¥›åˆ†æ12345678910111213141516public class IndexMaxPQ...&#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i//ä¸­é—´çœç•¥...public void insert(int i, Key key) &#123; ... n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n);&#125; &emsp;&emsp;æ ¹æ®ã€Šç®—æ³•4ã€‹ç»™å‡ºçš„ä»£ç ï¼Œåˆ†æè¿™ä¸¤æ®µä»£ç æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼š åœ¨å®šä¹‰å¤„å¯çŸ¥pqæ˜¯äºŒå‰å †çš„æ•°ç»„ ç”±qp[i] = n;pq[n] = i;å¯ä»¥çœ‹å‡ºæ¥ï¼Œqpè¿™ä¸ªæ•°ç»„çš„ç”¨å¤„å°±æ˜¯ä¸ºäº†è®°å½•**pqä¸­å€¼ä¸ºiçš„ä¸‹æ ‡æ˜¯å¤šå°‘**ï¼Œè¿™æ ·å½“æˆ‘ä»¬è¦æ”¹ä¸‹æ ‡ä¸ºiçš„å…ƒç´ çš„å€¼æ—¶ï¼Œæˆ‘ä»¬å°±ä¸ç”¨éå†pqæ¥è·å¾—ä½ç½®äº†ï¼Œ**ç”¨ç©ºé—´æ¥æ¢å–æ—¶é—´** å¹¶ä¸”è¿™ä¸ªç´¢å¼•iä»…ä»…ä¸ºäº†æ‰¾åˆ°å…ƒç´ å¯¹è±¡keyï¼Œå¹¶æ²¡å®é™…çš„æ„ä¹‰ã€‚næ‰æ˜¯å¯¹åº”äºŒå‰å †çš„ä½ç½®ã€‚ ğŸ˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ç´¢å¼•æœ€å°ä¼˜å…ˆé˜Ÿåˆ— **/ template&lt;typename T&gt;class IndexMinPQ &#123; public: IndexMinPQ(int max); void show() const; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125; void insert(int k, T item); void change(int k, T item); bool contain(int k) const &#123;return qp[k] != -1;&#125;; int delMin(); private: void sink(int i); void swim(int i); T* element; //å…ƒç´  int* pq; //äºŒå‰å † int *qp; //index int N; int _capacity;&#125;;template&lt;typename T&gt;IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) : element(new T[max + 1]), pq(new int[max + 1]) , qp(new int[max + 1]), N(0), _capacity(max) &#123; for(int i = 0; i &lt; max + 1; ++i) qp[i] = -1;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::sink(int n)&#123; while(n &lt; N) &#123; int m = n * 2; if(element[pq[m]] &gt; element[pq[m + 1]]) ++m; if(element[pq[m]] &lt; element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::swim(int n) &#123; while(n &gt; 1) &#123; int m = n / 2; if(element[pq[m]] &lt;= element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123; // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; if(capacity() == size())&#123; cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl; return ; &#125; pq[++N] = k; element[k] = item; qp[k] = N; swim(N); // show();&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::show() const&#123; cout &lt;&lt; &quot;pq: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;qp: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;element: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123; if(!contain(k)) &#123; cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl; return ; &#125; T old_one = element[k]; element[k] = item; if(item &gt; old_one) sink(qp[k]); else if(item &lt; old_one) swim(qp[k]);&#125;template&lt;typename T&gt;int IndexMinPQ&lt;T&gt;::delMin() &#123; int max = pq[1]; swap(pq[1], pq[N]); swap(qp[pq[1]], qp[pq[N]]); --N; show(); sink(1); show(); qp[max] = -1; element[max] = -1; pq[N + 1] = -1; return max;&#125;int main(int argc, char** argv) &#123; IndexMinPQ&lt;int&gt; pq(6); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6); for(size_t i = 0; i &lt; v.size(); ++i) &#123; pq.insert(i + 1, v[i]); &#125; pq.show(); pq.delMin(); pq.show(); return 0;&#125; ğŸ å‚è€ƒèµ„æ–™ï¼šé“¾æ¥","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg2","date":"2020-01-10T07:57:40.000Z","updated":"2020-01-10T08:36:50.374Z","comments":true,"path":"2020/01/10/alg2/","link":"","permalink":"http://yoursite.com/2020/01/10/alg2/","excerpt":"","text":"ğŸ ä¼˜å…ˆé˜Ÿåˆ—çš„å®ç°æœ‰ä¸‰ç§ï¼š æœ‰åºæ•°ç»„ æ— åºæ•°ç»„ å † ğŸ…æœ‰åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æœ‰åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class OrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit OrderArrayMaxPQ(int max); ~OrderArrayMaxPQ() &#123;delete [] arr;&#125; // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;// template&lt;typename T&gt;// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) // : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())// &#123;// copy(l.begin(), l.end(), arr);// &#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x; for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i) swap(arr[i], arr[i - 1]); &#125;template&lt;typename T&gt;pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; res = arr[N - 1]; arr[--N] = pair&lt;int , T&gt;(); return res;&#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; OrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¦æ— åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æ— åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class UnOrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit UnOrderArrayMaxPQ(int max); ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125; explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())&#123; copy(l.begin(), l.end(), arr);&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x;&#125;template&lt;typename T&gt;pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123; if(isEmpty()) return pair&lt;int, T&gt;(); int max_one = 0; for(int i = 0; i &lt; N; ++i) if(arr[max_one].first &lt; arr[i].first) &#123; max_one = i; &#125; swap(arr[max_one], arr[--N]); pair&lt;int,T&gt; res = arr[N]; arr[N] = pair&lt;int,T&gt;(); return res;&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; UnOrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥§å †1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * äºŒå‰å †å®ç° **/ template&lt;typename T&gt;class MaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; void swim(int i); void sink(int i); public: void show() const ; explicit MaxPQ(int max); ~MaxPQ() &#123;delete [] arr;&#125; void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;MaxPQ&lt;T&gt;::MaxPQ(int max) : arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)&#123; arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[++N] = x; swim(N);&#125;template&lt;typename T&gt;pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; swap(arr[N--], arr[1]); res = arr[N + 1]; arr[N + 1] = pair&lt;int ,T&gt;(); sink(1); return res;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 1; i &lt;= N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::swim(int i) &#123; while(i &gt; 1) &#123; if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]); i /= 2; &#125;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::sink(int i) &#123; int k; while(i &lt; N) &#123; k = 2 * i; if(arr[k].first &lt; arr[k + 1].first) ++k; if(arr[k].first &lt;= arr[i].first) break; swap(arr[k], arr[i]); i = k; &#125;&#125;int main(int argc, char** argv) &#123; MaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); // pq.show(); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¨æ—¶é—´å¤æ‚åº¦å¯¹æ¯” æœ‰åºæ•°ç»„ï¼š æ’å…¥ï¼šNï¼Œåˆ é™¤ï¼š1 æ— åºæ•°ç»„ï¼š æ’å…¥ï¼š1ï¼Œåˆ é™¤ï¼šN å †ï¼šæ’å…¥ã€åˆ é™¤ï¼šlgN ç†æƒ³æƒ…å†µï¼šéƒ½æ˜¯1","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¸ºç”šä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ","slug":"problems2","date":"2020-01-08T14:28:49.000Z","updated":"2020-01-08T15:06:10.423Z","comments":true,"path":"2020/01/08/problems2/","link":"","permalink":"http://yoursite.com/2020/01/08/problems2/","excerpt":"","text":"12unsigned int a = -1;printf(&quot;%d,%u,%x&quot;,a,a,a); -1,4294967295,ffffffffä»ç»“æœä¸Šæ¥è¯´,éªŒè¯äº†C++ä¸­ä½¿ç”¨çš„æ˜¯è¡¥ç ã€‚ ğŸ ç°åœ¨è¯´ä¸€è¯´ä¸ºä»€ä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ&emsp;&emsp;è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå‰æï¼Œä¸¤ä¸ªæ•°éƒ½æ˜¯intç±»å‹ï¼Œå› ä¸ºè¡¥ç çš„åŸå› ï¼Œå¦‚æœä¸¤ä¸ªæ•°çš„æ­£è´Ÿä¸åŒï¼Œé‚£ä¹ˆå®ƒä»¬çš„ç¬¬ä¸€ä½å°±ä¸åŒï¼Œå› ä¸ºintçš„ç¬¬ä¸€ä½æ˜¯æ­£è´Ÿçš„æ ‡å¿—ä½ã€‚é€šè¿‡å¼‚æˆ–ï¼Œé‚£ä¹ˆæ­£æ•°çš„ç¬¬ä¸€ä½ä¸º0ï¼Œè´Ÿæ•°çš„ç¬¬ä¸€ä½ä¸º1ï¼Œå¼‚æˆ–åç¬¬ä¸€ä½å°±ä¸º1ï¼Œæ‰€ä»¥å¯ä»¥å¾—åˆ°è®¡ç®—å‡ºçš„å€¼ä¸ºè´Ÿå€¼ã€‚ç›¸åå¦‚æœä¸¤è€…ç¬¦å·ç›¸åŒï¼Œé‚£ä¹ˆé€šè¿‡å¼‚æˆ–åï¼Œç¬¬ä¸€ä½å°±ä¸º0ï¼Œæ‰€ä»¥ä¸ºæ­£æ•°ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"äºŒåˆ†æŸ¥æ‰¾","slug":"alg1","date":"2020-01-07T14:24:36.000Z","updated":"2020-01-08T13:56:04.220Z","comments":true,"path":"2020/01/07/alg1/","link":"","permalink":"http://yoursite.com/2020/01/07/alg1/","excerpt":"","text":"æ—¶é—´å¤æ‚åº¦logN äºŒåˆ†æŸ¥æ‰¾çš„å®ç°å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯é€’å½’å¼çš„ã€å¦ä¸€ç§æ˜¯å¾ªç¯å¼çš„ğŸ˜œé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123; // if(lo &gt; ho) return -1; // int mid = (lo + ho) / 2; // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key); // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); // else return mid; if(lo &gt;= ho) return -1; int mid = (lo + ho) / 2; if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key); else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); else return mid;&#125; &emsp;&emsp;åŒºé—´çš„å¼€é—­è‡ªç”±é€‰å–ï¼Œä¸»è¦æ˜¯è¦ç»Ÿä¸€ï¼Œå¦‚æœè¦æ±‚ä¼ å…¥å·¦é—­å³å¼€åŒºé—´ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°å†…éƒ¨çš„å¤„ç†ä¹Ÿè¦ä¿æŒå·¦é—­å³å¼€ã€‚ä¸€èˆ¬çš„é€‰æ‹©åº”è¯¥æ—¶å·¦å³éƒ½æ˜¯é—­åŒºé—´ï¼Œè€Œåœ¨ç‰¹æ®Šæƒ…å†µæ—¶ï¼ˆæ•°ç»„ä¸­æœ‰å¤šä¸ªç›¸åŒçš„ç›®æ ‡æ—¶ï¼‰ï¼Œè¿™æ—¶é€‰æ‹©å·¦é—­å³å¼€ã€‚ğŸ¥›å‚è€ƒï¼šwikié“¾æ¥&emsp;&emsp;ä¸ºäº†é¿å…ho + lo å¤§äºINT_MAXæœ€å¥½æ”¹ç”¨lo + (ho - lo) / 2 ğŸˆ¶éé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123; int lo = 0, ho = a.size(), mid; while(lo &lt; ho) &#123; mid = (lo + ho) / 2; if(a[mid] &gt; key) ho = mid; else if(a[mid] &lt; key) lo = mid + 1; else return mid; &#125; return -1;&#125; é€’å½’è¦æ»¡è¶³ä¸‰ä¸ªåŸåˆ™ï¼š é€’å½’æ€»æœ‰ä¸€ä¸ªæœ€ç®€å•çš„æƒ…å†µâ€”æ–¹æ³•çš„ç¬¬ä¸€å¥æ€»æ˜¯ä¸€ä¸ªåŒ…å«returnçš„æ¡ä»¶è¯­å¥ã€‚ é€’å½’è°ƒç”¨æ€»è¦å°è¯•å–è§£å†³ä¸€ä¸ªè§„æ¨¡æ›´å°çš„å­é—®é¢˜ã€‚ é€’å½’è°ƒç”¨çš„çˆ¶é—®é¢˜å’Œå­é—®é¢˜ä¹‹é—´ä¸åº”è¯¥æœ‰äº¤é›†ã€‚ ğŸ¥˜æ¨èç›¸å…³èµ„æ–™ï¼šè®²è§£ ğŸ‘ç»ƒä¹ é¢˜ç›®1ï¼š4. å¯»æ‰¾ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //é¦–å…ˆè¦åˆ¤å®šæ‹¿ä¸ªåºåˆ—æ›´åŠ é•¿ if(nums1.size() &gt; nums2.size()) swap(nums1, nums2); //å·¦é—­å³å¼€ int imin = 0, imax = nums1.size(), j, i, m = nums1.size(), n = nums2.size(), halflen = (m + n + 1) / 2; while(imin &lt;= imax) &#123; i = (imax + imin ) / 2; j = halflen - i; // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; imin = i + 1; &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; imax = i; &#125; else &#123; // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; int leftMax, rightMin; if(i == 0 ) leftMax = nums2[j - 1]; else if(j == 0) leftMax = nums1[i - 1]; else leftMax = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2) return leftMax; if(i == m) rightMin = nums2[j ]; else if (j == n) rightMin = nums1[ i ]; else rightMin = min(nums1[i], nums2[j]) ; // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl; return static_cast&lt;double&gt;(leftMax + rightMin) / 2; &#125; &#125; return -1; &#125;&#125;; ğŸ‘ç»ƒä¹ é¢˜ç›®2ï¼š35. æœç´¢æ’å…¥ä½ç½®12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, ho = nums.size() - 1, mid; while(lo &lt; ho) &#123; mid = (lo + ho + 1) / 2; if(nums[mid] &gt; target) &#123; ho = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; if(nums[lo] &lt; target) return lo + 1; else return lo; &#125;&#125;;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"libuvæºç åˆ†æï¼ˆ6ï¼‰uv_queue_work","slug":"libuv6","date":"2019-11-26T12:06:58.000Z","updated":"2019-11-26T12:56:52.025Z","comments":true,"path":"2019/11/26/libuv6/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv6/","excerpt":"","text":"ğŸ¤é—®é¢˜æ¥ç”±&emsp;&emsp;åœ¨ä½¿ç”¨libuvçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éš¾å…é‡è§çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œæœ‰ä¸€äº›åº“æ²¡æœ‰å¼‚æ­¥ã€åªèƒ½åŒæ­¥è¿è¡Œï¼Œè¿™ç§æƒ…å†µè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿæ¯”å¦‚mysql-connector-cppã€‚ &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysql-connector-cppè¿™ç§ä¼šé˜»å¡çš„æ“ä½œæ˜¯ä¸ç¬¦åˆLibuvçš„reactoræ¨¡å¼çš„ã€‚ 123456void handle_json_lab(std::shared_ptr&lt;smpHttp::HttpRequest&gt; req,std::shared_ptr&lt;smpHttp::HttpResponse&gt; res) &#123; try&#123; Session mq = cli.getSession(); auto sqlres = mq.sql(\"Select content FROM labimformation where type = 'labIntroduction'\").execute(); ... &emsp;&emsp;ä¸Šé¢è¿™æ ·ä¾¿æ˜¯é”™è¯¯çš„æ¡ˆä¾‹ã€‚æˆ‘åœ¨å†™è¿™ä¸ªé¡¹ç›®æ—¶ï¼Œä¹‹å‰å°±é‡‡ç”¨äº†è¿™æ ·çš„é”™è¯¯åšæ³•ã€‚&emsp;&emsp;æˆ‘çš„è¿™ä¸ªé¡¹ç›®æ˜¯ä¸ªhttpåå°ï¼Œæˆ‘åœ¨æ¥å—åˆ°POSTè¯·æ±‚ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysqlæ“ä½œï¼Œè¿™æ—¶æ•´ä¸ªä¸»çº¿ç¨‹å°±é˜»å¡ä½äº†1ï¼Œè€Œè¿™å°±æ„å‘³ç€æˆ‘çš„httpåå°ä¸å†èƒ½æ¥å—ä»»ä½•è¯·æ±‚ï¼Œåªèƒ½ç­‰å¾…mysqlæ“ä½œå®Œæˆåï¼Œå›è°ƒå‡½æ•°è¿”å›ã€‚è€Œè¿™ä¸ªmysqlçš„æ“ä½œè€—æ—¶ä¸€èˆ¬åœ¨3sä»¥ä¸Šï¼Œè¿™å¯¹æˆ‘è¿™ä¸ªHttpåå°æ¥è¯´æ˜¯æ¯ç­æ€§çš„æ‰“å‡»ã€‚ã€‚ã€‚ã€‚ 1ï¼šç”¨æˆ·çš„å›è°ƒå‡½æ•°æ˜¯åœ¨work->doneå‡½æ•°çš„æœ€åæ‰§è¡Œçš„ï¼Œè€Œwork->doneæ˜¯åœ¨ä¸»çº¿ç¨‹uv_runä¸­çš„is_pollä¸­å”¤é†’loop->wq_asyncåæ‰§è¡Œçš„,åœ¨work->doneå‡½æ•°ä¸­é˜»å¡æ„å‘³ç€åœ¨ä¸»çº¿ç¨‹é˜»å¡ä½äº†ï¼Œuv_runä¸­çš„äº‹ä»¶å¾ªç¯å¡ä½ï¼Œä¸å†èƒ½æ¥å—requestï¼ˆè¿™éƒ¨åˆ†ä¸æ¸…æ¥šå¯ä»¥å»çœ‹æˆ‘çš„libuvæºç åˆ†ææ–‡ç« ï¼‰ ğŸŒ†è§£å†³åŠæ³•&emsp;&emsp;åœ¨æ‰‹å†ŒThread pool work schedulingä¸­ä¸ºæˆ‘ä»¬è¿™æ ·çš„éœ€æ±‚æä¾›äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼šuv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)ã€‚ &emsp;&emsp;è¿™ä¸ªå‡½æ•°å°±æ˜¯ä¸Šé¢æˆ‘ä»¬é—®é¢˜çš„è§£å†³åŠæ³•ã€‚ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯uv_async_tä¸å¯ä»¥æ›¿ä»£è¿™ä¸ªã€‚è™½ç„¶éƒ½æ˜¯æ‰§è¡Œç”¨æˆ·çš„å‡½æ•°ã€‚asyncæ˜¯è®©ç”¨æˆ·å‡½æ•°ç›´æ¥è¢«ä¸»çº¿ç¨‹åœ¨uv_runä¸­è¿è¡Œï¼Œè€Œuv_queue_workæ˜¯å°†work_cbæäº¤ç»™å­çº¿ç¨‹æ‰§è¡Œï¼Œå®Œæˆåé€šçŸ¥ä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹åœ¨uv_runä¸­æ‰§è¡Œafter_work_cbã€‚ &emsp;&emsp;æ€»ç»“ä¸‹æ¥å°±æ˜¯ï¼šuv_async_tç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼Œuv_queue_workæ‰§è¡Œè¦é˜»å¡çš„ä»»åŠ¡ï¼ˆè€ƒè™‘åˆ°çº¿ç¨‹åˆ‡æ¢çš„æ¶ˆè€—ä¸€èˆ¬ä¸ç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼‰ ğŸ‰çœ‹çœ‹æºç &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥ç»“åˆè¿™æˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*æ¥çœ‹ã€‚å¯ä»¥ä½œä¸ºä½è¯ï¼Œlibuvä¸­å¯¹ç€è¿™ç±»æ²¡æœ‰è‡ªå¸¦å¼‚æ­¥ç‰ˆæœ¬çš„é˜»å¡æ“ä½œçš„å¤„ç†æ˜¯ä¸€æ ·çš„ï¼šè®©å­çº¿ç¨‹å»æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯ï¼Œå®Œæˆåå­çº¿ç¨‹é€šçŸ¥ä¸»çº¿ç¨‹ã€‚uv_queue_workæºç ï¼š 123456789101112131415161718int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) &#123; if (work_cb == NULL) return UV_EINVAL; uv__req_init(loop, req, UV_WORK); req-&gt;loop = loop; req-&gt;work_cb = work_cb; req-&gt;after_work_cb = after_work_cb; uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, uv__queue_work, uv__queue_done); return 0;&#125; å†ç»“åˆæˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*ä¸­uv_fs_*å‡½æ•°çš„æºç ï¼Œè¿™äº›æ“ä½œå¯ä»¥æ€»ç»“æˆä»¥ä¸‹ä»£ç ï¼š 12345678UV_REQ_INIT(req, typ); //åˆå§‹åŒ–åŸºç±»uv_req_t uv__req_register(loop, req); //æ·»åŠ loopä¸­requestçš„è®¡æ•°ï¼Œé¿å…uv_runä¸­uv__loop_aliveè¿”å›0ï¼Œä½¿å¾—ä¸»çº¿ç¨‹uv_runé€€å‡º...//è¿™é‡Œæ˜¯é’ˆå¯¹ä¸åŒç±»å‹çš„æ“ä½œç‰¹æœ‰çš„åˆå§‹åŒ–éƒ¨åˆ†uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, //æ“ä½œç±»å‹ uv__queue_work, //è¦é˜»å¡çš„æ“ä½œï¼Œåœ¨fsä¸­æ˜¯uv__fs_work uv__queue_done); //å®Œæˆåçš„å›è°ƒï¼Œåœ¨fsä¸­æ˜¯uv__fs_done","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*","slug":"libuv5","date":"2019-11-25T18:57:15.000Z","updated":"2019-11-25T19:41:02.563Z","comments":true,"path":"2019/11/26/libuv5/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv5/","excerpt":"","text":"uv_fs_*&emsp;&emsp;uv_fs_*è¿™ä¸€ç³»åˆ—çš„å‡½æ•°åŸºæœ¬æ˜¯ä¸€è‡´çš„ï¼Œå®ƒä»¬çš„é€»è¾‘å¤§æ¦‚æ˜¯å¦‚ä¸‹ï¼š 123456//xä»£è¡¨ä¸€ç§æ“ä½œopenã€writeç­‰int uv_fs_x(...uv_fs_t* req...) &#123; INIT(x); //uv_fs_tå’Œå…¶åŸºç±»uv_req_tçš„åŸºæœ¬åˆå§‹åŒ– ... //è¿™é‡Œæ˜¯æ¯ä¸ªæ“ä½œå„è‡ªä¸åŒå¯¹äºreqçš„åˆå§‹åŒ– POST; //æäº¤è¿™ä¸ªä»»åŠ¡&#125; INIT&emsp;&emsp;INITè¿™ä¸ªå®å®šä¹‰å‡½æ•°æ²¡æœ‰ç‰¹åˆ«çš„åœ°æ–¹ï¼Œå°±æ˜¯æŠŠreqåˆå§‹åŒ–ï¼Œè¯¥ç½®0çš„ç½®0ã€‚ POST&emsp;&emsp;å…¶å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617#define POST do &#123; //dowhileåŒ…è£¹ä½œç”¨åŸŸ if (cb != NULL) &#123; uv__req_register(loop, req); uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_FAST_IO, uv__fs_work, uv__fs_done); return 0; &#125; else &#123; uv__fs_work(&amp;req-&gt;work_req); return req-&gt;result; &#125; &#125; while (0) &emsp;&emsp;è¿™é‡Œé€šè¿‡æœ‰æ— å›è°ƒå‡½æ•°æ¥å†³å®šè°ƒç”¨åŒæ­¥ç‰ˆæœ¬è¿˜æ˜¯å¼‚æ­¥ç‰ˆæœ¬ã€‚ http://docs.libuv.org/en/v1.x/fs.htmllibuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously. &emsp;&emsp;uv__fs_workè¿™ä¸ªå‡½æ•°å°±æ˜¯æ–‡ä»¶æ“ä½œçš„å°è£…ï¼Œæ‰€æœ‰çš„æ–‡ä»¶æ“ä½œéƒ½é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥å®Œæˆï¼Œå³ä½¿æ˜¯å¼‚æ­¥ï¼Œæœ€ç»ˆä¹Ÿè¦åœ¨åˆ«çš„çº¿ç¨‹ä¸­åŒæ­¥æ‰§è¡Œè¿™ä¸ªå‡½æ•°ã€‚ &emsp;&emsp;uv__fs_doneè¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨ç”¨æˆ·ç»™çš„å›è°ƒå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨uv_runä¸­çš„is_pollå‡½æ•°ä¸­å¾—åˆ°æ‰§è¡Œã€‚ &emsp;&emsp;uv__work_submitå‡½æ•°çš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678910void uv__work_submit(uv_loop_t* loop,struct uv__work* w,enum uv__work_kind kind, void (*work)(struct uv__work* w),void (*done)(struct uv__work* w, int status)) &#123; uv_once(&amp;once, init_once); w-&gt;loop = loop; w-&gt;work = work; w-&gt;done = done; post(&amp;w-&gt;wq, kind);&#125; &emsp;&emsp;uv_once(&amp;once, init_once);æ˜¯åˆå§‹åŒ–å¤šä¸ªçº¿ç¨‹ï¼Œæˆ‘åœ¨æˆ‘çš„ç¬¬ä¸‰ç¯‡æ–‡ç« ä¸­æœ‰ä»‹ç»ã€‚ä¸è¿‡å½“æ—¶å¯¹äºå­çº¿ç¨‹è¿è¡Œçš„workerå‡½æ•°æ²¡æœ‰æåŠï¼Œworkå‡½æ•°å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š 123456789101112131415161718192021222324252627282930static void worker(void* arg) &#123; ... uv_mutex_lock(&amp;mutex); for (;;) &#123; while (QUEUE_EMPTY(&amp;wq)...) &#123; idle_threads += 1; uv_cond_wait(&amp;cond, &amp;mutex); idle_threads -= 1; &#125; q = QUEUE_HEAD(&amp;wq); ... QUEUE_REMOVE(q); QUEUE_INIT(q); ... w = QUEUE_DATA(q, struct uv__work, wq); w-&gt;work(w); uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex); w-&gt;work = NULL; QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); uv_async_send(&amp;w-&gt;loop-&gt;wq_async); uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); uv_mutex_lock(&amp;mutex); ... &#125;&#125; &emsp;&emsp;æˆ‘å»æ‰äº†å¯¹äºslow_ioçš„å¤„ç†ï¼Œå¤§è‡´æ˜¯è¿™æ ·ä¸€ä¸ªè¿‡ç¨‹ã€‚ &emsp;&emsp;ä¸€å¼€å§‹çº¿ç¨‹ä¼šå¡åœ¨uv_cond_waitè¿™é‡Œï¼Œç›´åˆ°è¢«uv_cond_signalå”¤é†’ï¼Œå¦‚æœå”¤é†’æ—¶wqé˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡ï¼Œå®ƒå°±ä¼šæ‰§è¡Œä»»åŠ¡ï¼Œw-&gt;work(w)ä¹Ÿå°±æ˜¯è°ƒç”¨uv__fs_workã€‚ç„¶åæŠŠwæ”¾å…¥loop-&gt;wqï¼ˆä¸ºäº†uv__fs_doneçš„æ‰§è¡Œï¼‰ã€‚ &emsp;&emsp;uv_async_sendè°ƒç”¨è®©loop-&gt;wq_asyncå¯è¯»ï¼Œä¸»çº¿ç¨‹å°±ä»uv_runä¸­çš„uv__io_pollçš„epoll_pwaitä¸­é†’æ¥ï¼Œwq_asyncçš„å›è°ƒå‡½æ•°ä¼šéå†loop-&gt;wqæ‰§è¡Œw-&gt;doneã€‚ï¼ˆæˆ‘çš„ç¬¬å››ç¯‡æ–‡ç« æœ‰è®²è¿™ä¸€éƒ¨åˆ†çš„è¯¦ç»†å†…å®¹ï¼‰ è°æ¥è§¦å‘uv_cond_signalå”¤é†’å­çº¿ç¨‹å‘¢ï¼ŸğŸ¥£uv__work_submitä¸­çš„postå‡½æ•°ï¼š 123456uv_mutex_lock(&amp;mutex);...QUEUE_INSERT_TAIL(&amp;wq, q);if (idle_threads &gt; 0) uv_cond_signal(&amp;cond);uv_mutex_unlock(&amp;mutex); &emsp;&emsp;æˆ‘å†æ¬¡çœç•¥äº†slow_ioçš„éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒä»¬åªæ˜¯ç‰¹æ®Šå¤„ç†ã€‚ &emsp;&emsp;è¯¥å‡½æ•°æœ‰ç©ºé—²çš„çº¿ç¨‹å°±å”¤é†’ï¼Œä¸ç„¶å°±é˜»å¡è¯¥çº¿ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ4ï¼‰async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-25T19:24:48.508Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuvä¸­asyncçš„å¼€ç«¯åœ¨uv_loop_initå‡½æ•°ä¸­ï¼š 12345678//å‰é¢çœç•¥err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//åé¢çœç•¥ &emsp;&emsp;loop-&gt;wq_asyncæ˜¯ä¸ªuv_async_tç±»å‹ï¼Œå®ƒç”¨äºçº¿ç¨‹workå‡½æ•°è°ƒç”¨æœ€åå¤„ç†loop-&gt;wqä¸­çš„å›è°ƒï¼Œæš‚æ—¶ä¸ç”¨ç®¡,æˆ‘åœ¨æˆ‘çš„ç¬¬äº”ç¯‡æ–‡ç« ä¼šè®²åˆ°å®ƒçš„ç”¨é€”ã€‚&emsp;&emsp;æˆ‘ä»¬æ¥çœ‹uv_async_initå†…éƒ¨ï¼š 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;ç¬¬äº”è¡Œä»¥åçš„æ“ä½œå°±æ˜¯åˆå§‹åŒ–åŸºç±»uv_handle_tä»¥åŠå­ç±»uv_async_tï¼Œç„¶åå°†è¿™ä¸ªhandleæ”¾å…¥loop-&gt;queue(æ”¾uv_handle_tçš„é˜Ÿåˆ—)ä»¥åŠæ”¾å…¥loop-&gt;async_handlesï¼ˆæ”¾uv_async_tçš„é˜Ÿåˆ—ï¼‰ä¸­ï¼Œç„¶åuv__handle_startä¸­å°†loop-&gt;active_handlesåŠ ä¸€ã€‚&emsp;&emsp;æ€»è€Œè¨€ä¹‹ï¼Œç¬¬äº”è¡Œä»¥åçš„å†…å®¹å°±æ˜¯åˆå§‹åŒ–uv_async_tï¼Œå¯ä»¥ç†è§£æˆuv_async_tçš„æ„é€ å‡½æ•°ã€‚&emsp;&emsp;uv__async_startåˆ™ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯åˆå§‹åŒ–å‡½æ•°ï¼Œå®ƒåªä¼šè°ƒç”¨ä¸€æ¬¡ï¼ˆä¸€èˆ¬æƒ…å†µæ˜¯åœ¨uv_loop_initä¸­è°ƒç”¨ï¼‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹å®ƒçš„å®ç°ï¼š 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //ä¸­é—´çœç•¥ uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;çœ‹ç¬¬ä¸‰è¡Œloop-&gt;async_io_watcher.fdï¼Œå½“ä½ è°ƒç”¨è¿‡ä¸€æ¬¡è¿™ä¸ªå‡½æ•°åï¼Œloop-&gt;async_io_watcher.fdä¸ä¼šç­‰äº-1ï¼Œä»¥åä½ åˆå§‹åŒ–uv_async_tç±»å‹å˜é‡ï¼Œè°ƒç”¨uv_async_initå‡½æ•°æ—¶ï¼Œuv__async_startéƒ½æ˜¯ç›´æ¥è¿”å›çš„ã€‚&emsp;&emsp;æˆ‘çœç•¥æ‰äº†ä¸­é—´å¦‚æœeventfdæ²¡æœ‰åœ¨å½“å‰ç³»ç»Ÿä¸‹å®ç°æ—¶çš„å…¼å®¹æ€§å¤„ç†ã€‚æ€»çš„æ¥è¯´ï¼Œå°±æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherã€‚uv__io_tæ˜¯ä¸ºepollè®¾è®¡çš„ç»“æ„ä½“ã€‚è¿™é‡Œä½ è‚¯å®šæ„Ÿè§‰å¾ˆæ‡µé€¼ï¼Œè¯·åšæŒä¸€ä¸‹ï¼Œæœ€åæˆ‘ä¼šæ¢³ç†ä¸€ä¸‹æ€»ä½“çš„æ•´ä¸ªè¿‡ç¨‹ã€‚&emsp;&emsp;uv__io_tçš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678uv__io_t&#123; uv__io_cb cb; //å›è°ƒå‡½æ•° void* watcher_queue[2]; //æ”¾å…¥loop-&gt;watcher_queue void* pending_queue[2]; //åŒç† unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºepollæ³¨å†Œ&#125; &emsp;&emsp;è¿™é‡Œuv__io_initå‡½æ•°æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherè¿™ä¸ªç»“æ„ä½“ï¼š 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //å‰é¢æˆ‘ä»¬çš„eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_startå°†loop-&gt;async_io_watcheræ”¾å…¥loop-&gt;watcher_queueã€‚è¿˜æœ‰å¯¹äºloop-&gt;nfdså¤§å°çš„å¤„ç†ã€‚ 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;ç¬¬å››è¡Œä»¥åçš„æ“ä½œæ˜¯ä¸ºäº†åœ¨epollåï¼Œæˆ‘ä»¬å¾—åˆ°struct eventç»“æ„ä½“ï¼Œæˆ‘ä»¬ä»event-&gt;data.fdå¯ä»¥å¾—åˆ°fdï¼Œé‚£æˆ‘ä»¬å¦‚ä½•è·å–åˆ°å¯¹åº”çš„uv__io_tå‘¢ï¼Ÿ å°±æ˜¯é€šè¿‡loop-&gt;watchersè¿™ä¸ªæ•°ç»„ã€‚ uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCEï¼š 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;è¿™é‡Œè°ƒç”¨ä¸€æ¬¡ACCESS_ONCEï¼Œæ˜¯ä¸ºäº†å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œhandle-&gt;pendingå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼Œæ‰€ä»¥åˆ«ç»™æˆ‘ä¹±ä¼˜åŒ–ã€‚&emsp;&emsp;cmpxchgiæ˜¯åŸå­æ“ä½œcompare_and_changeã€‚pendingçš„æœ‰ä¸‰ä¸ªå–å€¼0ï¼Œ1ï¼Œ2ã€‚0ä»£è¡¨é—²ç½®ã€1ä»£è¡¨å¿™ï¼ˆæ¯”å¦‚uv_async_sendè°ƒç”¨é€”ä¸­ï¼‰ã€2ä»£è¡¨å®Œæˆã€‚loop-&gt;async_io_watcherè°ƒç”¨uv__async_ioæ—¶ï¼Œä¼šéå†loop-&gt;async_handlesï¼Œé€šè¿‡pendingæ¥åˆ¤æ–­å“ªäº›å›è°ƒè¯¥è¢«æ‰§è¡Œã€‚&emsp;&emsp;uv__async_sendå°±æ˜¯å‘loop-&gt;async_io_watcher.fdï¼ˆeventfdï¼‰å†™ï¼ˆè¿™é‡Œå…³ç³»åˆ°eventfdçš„æœºåˆ¶ï¼Œä¸æ‡‚å¯ä»¥man eventfdï¼‰ã€‚ æ•´ä½“è°ƒç”¨è¿‡ç¨‹&emsp;&emsp;è¿™é‡Œæ€»ä½“å½’çº³ä¸€ä¸‹asyncçš„è¿‡ç¨‹ã€‚&emsp;&emsp;1.åœ¨loop_uv_initä¸­åˆå§‹åŒ–async_io_watcherï¼Œå®ƒçš„fdä¸ºeventfdï¼Œå€¼ä¸º0ï¼Œä¸å¯è¯»ã€‚&emsp;&emsp;2.ç”¨æˆ·uv_async_initæ³¨å†Œuv_async_tå˜é‡ï¼Œè¢«æ·»åŠ åˆ°loop-&gt;async_handlesï¼Œè®¾ç½®å›è°ƒå‡½æ•°ã€‚&emsp;&emsp;3.å¦‚æœå¯¹uv_async_tå˜é‡è°ƒç”¨uv_async_sendï¼Œé‚£ä¹ˆuv_async_tå˜é‡çš„pendingå˜ä¸º2ï¼ˆdoneï¼‰ï¼Œå¹¶ä¸”å‘eventfdå†™ï¼Œloop-&gt;async_io_watcherå¯è¯»äº†ã€‚&emsp;&emsp;4.åœ¨uv_runçš„uv__io_pollä¸­ï¼Œæ¯æ¬¡éƒ½ä¼šæŠŠloop-&gt;watchersæ³¨å†Œåˆ°epollä¸­ï¼Œç¬¬å››æ­¥è¿™ä¸ªè¿‡ç¨‹åœ¨æ¯æ¬¡äº‹ä»¶å¾ªç¯ä¸­éƒ½åœ¨æ‰§è¡Œã€‚å¦‚æœasync_io_watcherçš„fdä¸å¯è¯»ï¼Œå°±æ²¡å®ƒäº‹å„¿ã€‚å¦‚æœå¯è¯»ï¼Œasync_io_watcherçš„å›è°ƒå‡½æ•°uv__async_ioæ‰§è¡Œï¼Œå®ƒéå†loop-&gt;async_handlesï¼Œå°†å…¶ä¸­pendingä¸º2çš„uv_async_tå˜é‡ç§»é™¤é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œå…¶å›è°ƒå‡½æ•°ã€‚ çœ‹æºç åå†™çš„å°DEMOï¼š https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config ä½ ä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ–‡å­—ï¼š 123456Host github.comUser ä½ çš„ç”¨æˆ·åï¼ˆä¾‹å¦‚97860xx@qq.comï¼‰Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 ç„¶åä¿å­˜é€€å‡ºï¼ˆä»£ç å¦‚ä¸‹ï¼‰ã€‚ 1:wq æ¥ä¸‹æ¥æµ‹è¯•ä¸€ä¸‹ï¼š 1ssh -T git@github.com å‡ºç°ä¸‹é¢çš„ç”»é¢ï¼šåœ¨å›¾ç‰‡å€’æ•°ç¬¬äº”è¡Œçš„åœ°æ–¹ä¼šè¯¢é—®æ˜¯å¦å»ºç«‹è¿æ¥ï¼Œè¾“å…¥yeså³å¯ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuvæºç åˆ†æï¼ˆ3ï¼‰init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"ç”±æ¥&emsp;&emsp;åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡æäº¤ioæ“ä½œæ—¶ï¼Œä¼šæœ‰uv_onceè¢«è°ƒç”¨ï¼Œæ¥æ£€æµ‹æ˜¯å¦åˆå§‹åŒ–è¿‡çº¿ç¨‹æ± ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç«‹åˆ»åˆå§‹åŒ–çº¿ç¨‹æ± ã€‚æ‰€ä»¥è¯´çº¿ç¨‹æ± å¹¶éä¸€å¼€å§‹åœ¨uv_runçš„æ—¶å€™æˆ–è€…åœ¨loopä¸­åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯åœ¨ioæ“ä½œå¼€å§‹å‰ã€‚æˆ‘ä»¥uv_openä¸ºä¾‹å­ç”»ä¸€ä¸‹UMLå›¾å¦‚ä¸‹ï¼šåœ¨uv_openä¸­å…ˆåˆå§‹åŒ–reqï¼Œç„¶åå‡†å¤‡æäº¤workï¼Œæäº¤å‰ä¼šè°ƒç”¨uv_onceæ£€æµ‹æ˜¯å¦åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæ²¡æœ‰åˆ™åˆå§‹åŒ–ã€‚ init_onceuv_onceå®ç°å¦‚ä¸‹ï¼š 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; åœ¨uv__work_submitä¸­uv_onceæ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼š 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚çœ‹TLPI 31.2éƒ¨åˆ†ï¼Œlibuvå¤šåšäº†pthread_atforkçš„å¤„ç†ã€‚&emsp;&emsp;pthread_atforkæ³¨å†Œreset_onceå‡½æ•°ï¼Œåœ¨forkä¹‹åé‡ç½®onceï¼Œä¿è¯åœ¨libuvå¾ªç¯ä¸­å¦‚æœä½ forkäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œå¦‚æœåœ¨é‚£ä¸ªæ–°çš„è¿›ç¨‹ä¸­ä½ ä¹Ÿå¯åŠ¨ä¸€ä¸ªlibuvï¼Œinit_threads()èƒ½è¢«è°ƒç”¨ã€‚ init_threadsğŸ¤æ¡ä»¶å˜é‡&emsp;&emsp;libuvåˆå§‹åŒ–æ¡ä»¶å˜é‡æ—¶ï¼Œè°ƒç”¨è‡ªå·±çš„uv_cond_initï¼Œè¿™ä¸ªå‡½æ•°åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å°†æ¡ä»¶å˜é‡çš„æ—¶é’Ÿè®¾ç½®ä¸ºç›¸å¯¹æ—¶é—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å€¼å¾—æˆ‘ä»¬è‡ªå·±å†™ä»£ç æ—¶å‚è€ƒçš„ï¼Œç›¸å¯¹æ—¶é—´ä¸å—ç³»ç»Ÿæ—¶é—´çš„å½±å“ã€‚ 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; ğŸ¥›äº’æ–¥é”&emsp;&emsp;åˆå§‹åŒ–äº’æ–¥é”æ—¶ï¼Œè°ƒç”¨uv_mutex_initï¼Œåœ¨DEBUGæ—¶ï¼Œlibuvä¼šå°†äº’æ–¥é”è®¾ç½®ä¸ºPTHREAD_MUTEX_ERRORCHECKï¼Œè¿™æ ·èƒ½è‡ªæˆ‘æ£€æµ‹æ˜¯å¦ä¸ºæ­»é”ï¼Œä¸è¿‡è¿™ä¼šæ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚ 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. ğŸ¥¡ä¿¡å·é‡&emsp;&emsp;åˆå§‹åŒ–æ¯ä¸ªçº¿ç¨‹æ—¶ï¼Œlibuvç”¨ä¿¡å·é‡æ¥ä¿è¯init_threadså‡½æ•°åœ¨åˆå§‹åŒ–å®Œæ‰€æœ‰çº¿ç¨‹åé€€å‡ºã€‚ 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); åœ¨linuxä¸‹å¹¶ä¸”glibcç‰ˆæœ¬å¤§äº2.21æ—¶ï¼Œuv_sem_init(&amp;sem, 0)å’Œsem_init(&amp;sem, 0)æ˜¯ä¸€æ ·çš„ï¼Œæ²¡æœ‰é¢å¤–çš„å¤„ç†ã€‚çº¿ç¨‹åˆ›å»ºå¥½åï¼Œåœ¨workerå‡½æ•°ä¸­ä¼šè°ƒç”¨uv_sem_posté‡Šæ”¾ä¿¡å·é‡ã€‚ 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; ğŸ¥šuv_thread_create&emsp;&emsp;uv_thread_createåšçš„äº‹æƒ…å°±æ˜¯è®¾ç½®çº¿ç¨‹çš„stackå¤§å°ï¼Œç„¶ååˆ›å»ºå®ƒã€‚thread_stack_sizeå‡½æ•°è·å–æ ˆå¤§å°ï¼Œæœ‰ä¸€äº›æ˜¯è·¨å¹³å°å…¼å®¹æ€§çš„å¤„ç†ã€‚ 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); å’Œif (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; ä¸Šé¢ä¸¤è¡Œçš„é™åˆ¶æ˜¯æ¥æºäºpthread_attr_setstacksizeå‡½æ•°ï¼Œä¸€ä¸‹æ˜¯pthread_attr_setstacksizeå‡½æ•°manæ‰‹å†Œçš„ä¸€éƒ¨åˆ†ã€‚ ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif ğŸ˜‚æ— è¶£çš„æ˜¯åœ¨linux Ubuntusæˆ‘çš„ç¯å¢ƒä¸‹æµ‹è¯•æ—¶ï¼Œattrçš„é»˜è®¤stacksizeå’Œthread_stack_sizeå‡½æ•°è®¾ç½®åˆ°çš„æ˜¯ä¸€æ ·çš„å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘çš„æµ‹è¯•ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ2ï¼‰uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"å‰è¨€&emsp;&emsp;ä¸Šä¸€ç¯‡è¯´äº†ä¸€ä¸‹æ•´ä½“çš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºUV_RUN_DEFAULTæ¨¡å¼æ¥è°ƒç”¨uv_runæ¥è¯´ï¼Œuv__loop_aliveå°±å†³å®šäº†æ˜¯å¦é€€å‡ºï¼Œè¿™ä¸€ç¯‡çœ‹ä¸€ä¸‹uv__loop_aliveçš„æºç ã€‚ è¯¦æƒ…12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;å¯è§loopçš„çŠ¶æ€å–å†³äºä¸‰ä¸ªæ–¹é¢ï¼šhandlesã€reqsã€closing_handles handles&emsp;&emsp;uv__has_active_handleså°±æ˜¯æ£€æŸ¥loop-&gt;active_handleså€¼æ˜¯å¦å¤§äº0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handlesåˆ—è¡¨å¦‚ä¸Šã€‚handleåœ¨è°ƒç”¨æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ï¼Œå°±æ˜¯uv__handle_startã€‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å“ªäº›å‡½æ•°è°ƒç”¨äº†uv__handle_startã€‚æœ‰ä¸€äº›handleä¸åœ¨å…¶ä¸­ï¼Œå¯èƒ½ä¸å…¶è°ƒç”¨æ–¹å¼æœ‰å…³ï¼Œæˆ‘æš‚æ—¶æ— æ³•è§£é‡Š 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_startå‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨uv__active_handle_addï¼Œuv__active_handle_addå°±æ˜¯å°†loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;ç›¸åº”çš„åœ¨handleç»“æŸæ—¶æœ‰uv__active_handle_rmçš„è°ƒç”¨ï¼Œ(h)-&gt;loop-&gt;active_handleså‡ä¸€ã€‚ 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqså’Œhandleçš„é“ç†ä¸€æ ·ï¼Œæ˜¯æ£€æµ‹(loop)-&gt;active_reqs.count &gt; 0ã€‚active_reqsæ˜¯ä¸ªå…±ç”¨ä½“ï¼Œå®ƒçš„å¦ä¸€ä¸ªç”¨é€”æš‚æ—¶æˆ‘è¿˜ä¸çŸ¥é“ã€‚ 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)ç­‰åŒäºhandleçš„uv__active_handle_addã€‚uv__req_registeråœ¨uv__req_initä¸­è°ƒç”¨ï¼Œå‡ ä¹ï¼ˆæ¼ç½‘çš„æš‚æ—¶æ²¡æ³•è§£é‡Š ï¼‰æ¯ä¸ªreqåœ¨åˆå§‹åŒ–æ—¶éƒ½è°ƒç”¨äº†uv__req_initã€‚ 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;ä¸‹å›¾æ‰€ç¤ºæ˜¯é‚£äº›å‡½æ•°è°ƒç”¨äº†uv__req_initï¼Œç”±åç§°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥å®ƒä»¬æ˜¯å±äºå“ªäº›reqçš„ã€‚&emsp;&emsp;åŒç†ï¼Œè¿˜æœ‰uv__req_unregisterã€‚ 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;è¦å…³é—­çš„handleä¼šä»¥é“¾è¡¨çš„å½¢å¼æŒ‚åœ¨loop-&gt;closing_handlesä¸Šã€‚è¿™ä¸ªæ“ä½œé€šè¿‡è°ƒç”¨uv__make_close_pendingæ¥å®ç°ã€‚ 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; å¦‚æœclosing_handlesä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿˜éœ€è¦è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œå»è°ƒç”¨å…³é—­çš„handleçš„å›è°ƒå‡½æ•°ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ1ï¼‰äº‹ä»¶å¾ªç¯åˆ†æ","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"å‰è¨€ &emsp;&emsp;libuvæ€»æ˜¯æŠ¥å‡ºä¸€äº›è®©äººéš¾ä»¥ç†è§£çš„é”™è¯¯ğŸ˜‚ï¼Œä½œä¸ºä¸€ä¸ªCçš„é¡¹ç›®ï¼Œä¸å…·æœ‰Javaã€JavaScriptã€phpé‚£æ ·çš„äººæ°”ï¼Œå¾ˆéš¾ç™¾åº¦åˆ°ä¸€äº›é—®é¢˜çš„ç­”æ¡ˆï¼Œç”šè‡³googleä¹Ÿä¸è¡Œã€‚ä¸ºäº†ç”¨å¥½libuvï¼Œä¹Ÿä¸ºäº†å­¦ä¹ å§ã€‚æˆ‘å¼€å§‹çœ‹libuvçš„æºç ï¼Œä¸çŸ¥é“è‡ªå·±èƒ½èµ°å¤šè¿œã€‚ã€‚ã€‚ äº‹ä»¶å¾ªç¯ è¿™æ˜¯å®˜æ–¹äº‹ä»¶å¾ªç¯çš„ç¤ºæ„å›¾ã€‚é“¾æ¥-&gt;å®˜æ–¹å›¾ç‰‡ä½ç½® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;æ•´ä¸ªäº‹ä»¶å¾ªç¯å°±æ˜¯åœ¨ä¸»çº¿ç¨‹çš„uv_runï¼ˆï¼‰è°ƒç”¨ä¸­æ‰§è¡Œçš„ã€‚æˆ‘å°±è·Ÿç€å®˜æ–¹çš„ä»‹ç»ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼ˆå®˜æ–¹ä»‹ç»ï¼‰ã€‚ ç¬¬ä¸€æ­¥ The loop concept of â€˜nowâ€™ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;ç¬¬ä¸€æ­¥æ˜¯æ›´æ–°æ—¶é—´ã€‚å¯¹åº”ä»£ç å¦‚ä¸‹ï¼š 1uv__update_time(loop); &emsp;&emsp;æ€»ç»“æ¥è¯´å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ›´æ–°æ—¶é—´ã€‚uv__update_timeå®ç°æˆ‘ä¸‹ä¸€ç¯‡æ¥ä»‹ç» ç¬¬äºŒæ­¥ If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and refâ€™d handles, active requests or closing handles itâ€™s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;ç”¨uv__loop_aliveå‡½æ•°è·å–loopçŠ¶æ€ã€‚&emsp;&emsp;å¦‚æœuv__loop_aliveè¿”å›é›¶æˆ–è€…loop-&gt;stop_flag == 1è¯´æ˜loopç»ˆæ­¢ï¼Œç›´æ¥è·³è¿‡å¾ªç¯ï¼Œåˆ°ä»£ç æœ€ä¸‹é¢ï¼ˆè¿™é‡Œæœ‰ä¸€äº›æ€§èƒ½çš„å¤„ç†æš‚æ—¶ä¸ç®¡ ï¼‰ï¼Œé€€å‡ºï¼š 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0çš„ä¸€ä¸ªæ¥æºæ˜¯è°ƒç”¨äº†uv_stopï¼Œè¿™ä¸ªå‡½æ•°åœ¨æ‰‹å†Œä¸­çœ‹è§ã€‚å®ƒçš„æºä»£ç ä¹Ÿå¾ˆæ¸…æ™°ã€‚ 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;å¦‚æœloopçŠ¶æ€OKï¼Œé‚£ä¹ˆå°±è¿›å…¥å¾ªç¯ä¸­ã€‚ ç¬¬ä¸‰æ­¥ Due timers are run. All active timers scheduled for a time before the loopâ€™s concept of now get their callbacks called. &emsp;&emsp;å¯¹åº”ä»£ç è¿™ä¸€éƒ¨åˆ†ï¼š 1234567891011121314151617181920uv__run_timers(loop);å…¶å®ç°ï¼švoid uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;å°†å †é‡Œé¢å·²ç»è¶…æ—¶çš„æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬å››æ­¥ Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. å¯¹åº”ï¼š 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);å…¶å®ç°ï¼šstatic int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;å°†loop-&gt;pending_queueä¸­çš„ä»»åŠ¡æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬äº”ã€å…­ã€ä¹æ­¥ 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;è¿™ä¸‰éƒ¨ä¸ºä»€ä¹ˆè¦ä¸€èµ·è¯´å‘¢ï¼Ÿå› ä¸ºå®ƒä»¬çš„å®è´¨æ˜¯ä¸€æ ·çš„ã€‚åœ¨æ¯æ¬¡å¾ªç¯å›ºå®šçš„ä½ç½®è°ƒç”¨ã€‚&emsp;&emsp;è¿™ä¸‰ä¸ªå‡½æ•°å®šä¹‰åœ¨loop-watcher.cè¿™ä¸ªæ–‡ä»¶é‡Œé¢ï¼Œå®ƒä»¬æ˜¯ç”¨å®å®šä¹‰å®šä¹‰çš„ã€‚åªæ”¹äº†idleã€prepareã€checkè¿™ä¸‰ä¸ªåå­—çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†å‡½æ•°éƒ½æ˜¯ä¸€æ ·çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) ç¬¬ä¸ƒæ­¥ Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;è¿™éƒ¨åˆ†æ˜¯å–å†³äºuv_runçš„æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼Œæš‚æ—¶ä¸ç»†çœ‹ã€‚ ç¬¬å…«æ­¥ The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯¹äºä¸åŒæ“ä½œç³»ç»Ÿæœ‰æ‰€ä¸åŒï¼Œlinuxæ˜¯pollï¼Œmacæ˜¯kqueueã€‚ ç¬¬åæ­¥ Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;è°ƒç”¨å„ç±»çš„closeå›è°ƒå‡½æ•°ã€‚ ç¬¬åä¸€ã€åäºŒæ­¥ 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. Itâ€™s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if itâ€™s still alive, otherwise it will also end. &emsp;&emsp;å¯¹äºuv_runä¸åŒæ¨¡å¼çš„ä¸€ç‚¹ç‰¹æ®Šå¤„ç†ã€‚ 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; å°ç»“&emsp;&emsp;å®è§‚ä¸Šæ¢³ç†ä¸€ä¸‹æ•´ä¸ªäº‹ä»¶å¾ªç¯çš„è¿‡ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2.5)","slug":"rax3","date":"2019-08-14T10:40:51.000Z","updated":"2019-11-25T19:51:03.317Z","comments":true,"path":"2019/08/14/rax3/","link":"","permalink":"http://yoursite.com/2019/08/14/rax3/","excerpt":"","text":"ç‚¹ç‚¹åºŸè¯&emsp;&emsp;æœ€è¿‘æ²¡æœ‰å†å°†raxçš„æºç å¾€ä¸‹çœ‹ï¼Œraxå¯¹äºä¸€ä¸ªæ–°æ‰‹æ¥è¯´è¿˜æ˜¯ä½“é‡è¿‡å¤§ï¼Œåœ¨å°è¯•è‡ªå·±å†™å†™ï¼Œåœ¨å†™çš„æ—¶å€™é‡åˆ°äº†ä¸€äº›å‘ï¼Œä¹Ÿä½“ä¼šåˆ°äº†raxçš„ä¸€äº›å†™æ³•çš„ç²¾å¦™ä¹‹å¤„ï¼Œè®°å½•ä¸€ä¸‹ã€‚ å®å®šä¹‰å‡½æ•°çš„æ³¨æ„ç‚¹ï¼š&emsp;&emsp;æˆ‘å®šä¹‰äº†è¿™æ ·ä¸€ä¸ªå®å®šä¹‰å‡½æ•°ï¼š 12#define radixNthChild(h, n) \\ (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*)) æˆ‘è¿™æ ·è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š 1radixNthChild(new_cur, new_cur-&gt;size - 1) è¿™æ ·ä¸€ä¸ªè°ƒç”¨å¤§å®¶è§‰å¾—æœ‰é—®é¢˜å—ï¼Ÿå—¯ï¼Œè‚¯å®šæ˜¯æœ‰é—®é¢˜çš„ï¼Œä¸ç„¶æˆ‘è¯´å•¥?ã€‚ è¿™é‡Œï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¸€èˆ¬çš„è°ƒç”¨å‡½æ•°çš„æ€è·¯ï¼Œè¿™æ ·ä¸€ä¸ªè°ƒç”¨çš„è¿è¡Œè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š è®¡ç®—å‡ºnew_cur-&gt;size - 1 å¸¦å…¥radixNthChildå‡½æ•° å®é™…ä¸Šæ°æ°ç›¸åï¼Œå®å®šä¹‰çš„å¤„ç†åœ¨é¢„ç¼–è¯‘æ—¶ï¼ˆg++ -Eï¼‰ï¼Œå®å®šä¹‰æ˜¯å°†å¯¹äºçš„å®šä¹‰æ›¿æ¢æ‰ï¼Œæ‰€ä»¥åœ¨é¢„ç¼–è¯‘åçš„ç»“æœå¦‚ä¸‹ï¼š 12# 363 &quot;radix_tree.c&quot; memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*)); å¯ä»¥çœ‹åˆ°æ˜¯ ï¼š + new_cur-&gt;size - 1 * sizeof(void)è€Œä¸æ˜¯æˆ‘æ‰€æƒ³çš„ï¼š + ï¼ˆnew_cur-&gt;size - 1ï¼‰ * sizeof(void) å¯ä»¥å¾—å‡ºå…¶è¿‡ç¨‹å…¶å®æ˜¯ï¼š å‡½æ•°å®å®šä¹‰æ›¿æ¢ è¿è¡Œæ—¶è®¡ç®— ç»“è®ºï¼š åœ¨å®å®šä¹‰å‡½æ•°è°ƒç”¨æ—¶æ³¨æ„æ‹¬å·çš„é—®é¢˜ï¼Œä¸åŠ æ‹¬å·å¯èƒ½ä¼šç”±äºè¿ç®—ç¬¦ä¼˜å…ˆçº§è€Œ å¯¼è‡´è¡¨è¾¾å¼æ„ä¹‰ä¸æˆ‘ä»¬æƒ³çš„æœ‰å‡ºå…¥? åœ°å€è¿ç®—æ³¨æ„ç‚¹å…ˆç»™å‡ºè¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼š 123struct test &#123; void* a, *b, *c;&#125;; int main(void) { cout &lt;&lt; sizeof(test) &lt;&lt; endl; test* p = new test; fprintf(stdout, &quot;%p:%p:%p:%p\\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1); return 0; }&emsp;&emsp;åœ¨è¿™æ ·ä¸€ä¸ªæµ‹è¯•ä»£ç ä¸­ï¼Œå¤§å®¶è§‰å¾—p + 1, (char)p + 1, (int)p+1è¿™ä¸‰ä¸ªç»“æœï¼Œç›¸å¯¹äºpçš„æ•°å€¼ç›¸å·®å¤šå°‘å‘¢ï¼Ÿ&emsp;&emsp;è¿è¡Œç»“æœæ˜¯è¿™æ ·çš„ã€‚ç±»å‹ä¸åœ°å€çš„è¿ç®—æ˜¯æœ‰ç€å¯†åˆ‡å…³ç³»çš„ã€‚ p + 1æ˜¯ä¸€ä¸ªé»˜è®¤æƒ…å†µï¼Œ è¿™æ—¶1çš„æ„ä¹‰æ˜¯ä¸€ä¸ªpçš„åœ°å€å®½åº¦ (char*)p + 1ï¼Œpè¢«è§£é‡Šä¸ºcharç±»å‹æŒ‡é’ˆï¼ŒæŒ‡å‘çš„åœ°å€è¢«è§£é‡Šä¸ºcharï¼Œäºæ˜¯1å°±æ˜¯ä¸€ä¸ªcharçš„åœ°å€å®½åº¦ã€‚ æ€»ç»“ï¼š åœ¨è®¡ç®—åœ°å€æ—¶ï¼Œè¦æ³¨æ„è¿ç®—ç¬¦å·¦è¾¹å€¼çš„ç±»å‹ã€‚ä½ åŠ ä¸Šçš„1å¯èƒ½å¹¶ä¸æ˜¯ä¸€ä¸ªå­—èŠ‚çš„å¤§å°ã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2)","slug":"rax2","date":"2019-08-12T10:51:18.000Z","updated":"2019-11-25T19:49:43.833Z","comments":true,"path":"2019/08/12/rax2/","link":"","permalink":"http://yoursite.com/2019/08/12/rax2/","excerpt":"","text":"ä»Šå¤©æˆ‘æƒ³è¦è¯´çš„æ˜¯raxä¸­çš„paddingè¿™ä¸ªå‡½æ•°ï¼Œæˆ‘æŸ¥äº†å¾ˆå¤šçš„èµ„æ–™ï¼Œå¤§å®¶çš„åšå®¢éƒ½å‘Šè¯‰æˆ‘ä»¬å†…å­˜å¯¹é½æé«˜æ€§èƒ½ï¼Œå´æ²¡æœ‰å»åˆ†æä¸ºä»€ä¹ˆï¼Œæ˜¯æœ‰æ ¹æ®è®©ä½œè€…é€‰æ‹©è¿™æ ·åšï¼Ÿå¦‚æœåªæ˜¯è¿™æ ·ç®€å•çš„æ”¾è¿‡ï¼Œæ€»æ„Ÿè§‰è®©äººæœ‰ä¸€ä¸çš„é—æ†¾ã€‚ &emsp;&emsp;å…ˆæŠŠä¸»è§’æ‹‰å‡ºæ¥ï¼š 12#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1)) &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯raxPaddingçš„ä½œç”¨æ˜¯ï¼šè®©raxNewNodeç”³è¯·çš„å†…å­˜nodesizeæ˜¯8çš„å€æ•°ã€‚ 123456789101112raxNode *raxNewNode(size_t children, int datafield) &#123; size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+ sizeof(raxNode*)*children; if (datafield) nodesize += sizeof(void*); raxNode *node = rax_malloc(nodesize); if (node == NULL) return NULL; node-&gt;iskey = 0; node-&gt;isnull = 0; node-&gt;iscompr = 0; node-&gt;size = children; return node;&#125; ç¬¬ä¸€ä¸ªé—®é¢˜ï¼šå¯¹é½çš„ä¼˜åŠ¿&emsp;&emsp;è¿™ä¸ªå¹¶ä¸æ˜¯æˆ‘æƒ³è¯´çš„é‡ç‚¹ï¼Œè¿™é‡Œæ˜¯å¤§å®¶éƒ½è°ˆåˆ°çš„ï¼Œä¹Ÿå°±æ˜¯ç»è¿‡å†…å­˜å¯¹é½ä¹‹åï¼ŒCPUçš„å†…å­˜è®¿é—®é€Ÿåº¦å¤§å¤§æå‡ã€‚å¯¹äºæˆ‘æ¥è¯´ï¼Œè¿™ä¸ªç»“è®ºæ„Ÿè§‰è¿˜æ˜¯å¤ªæ¨¡ç³Šï¼Œè¿™æ˜¯ä¸€ä¸ªå®šæ€§çš„ç»“è®ºï¼Œå…·ä½“çš„åº•å±‚ç»†èŠ‚å¯¹äºæˆ‘ä»¬åˆå­¦è€…æ¥è¯´å€’æ˜¯æ²¡å¿…è¦å»æ·±ç©¶ã€‚ ç¬¬äºŒä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå»åšï¼Ÿ&emsp;&emsp;raxçš„ä½œè€…è¿™æ ·çš„åšæ³•å…¶å®æ˜¯å‚è€ƒç»“æ„ä½“çš„åšæ³•ã€‚ä¸¾ä¸ªä¾‹å­ï¼š 123456struct X&#123; char a; int c; double b;&#125;S2; è¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼Œå®ƒçš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿç­”æ¡ˆæ˜¯16ã€‚åœ¨cè¯­è¨€çš„å†…éƒ¨ï¼Œåšäº†è¿™æ ·çš„å†…å­˜å¯¹é½å¤„ç†ï¼š è¿™é‡Œè½¬è½½äº†è¿™ç¯‡æ–‡ç« ä¸­çš„å¾ˆå¤šèµ„æºï¼Œå¤§å®¶ä¹Ÿå¯ä»¥å»çœ‹çœ‹è¿™ç¯‡æ–‡ç« ï¼Œå†™çš„å¾ˆä¸é”™ã€‚ä¹Ÿæœ‰æ›´å¤šä¾‹å­ã€‚ å›åˆ°raxä¸Šæ¥&emsp;&emsp; åœ¨raxçš„raxNodeè¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œå› ä¸ºä½¿ç”¨äº†æŸ”æ€§æ•°ç»„ï¼Œæ‰€ä»¥åœ¨cè¯­è¨€æœ¬èº«æ˜¯æ— æ³•å¸®åŠ©æˆ‘ä»¬å®ç°åƒä¸Šé¢ä¸€æ ·çš„å†…å­˜å¯¹é½çš„ï¼ˆsizeof(raxNode) == 4,æˆ‘ä»¬ç”³è¯·çš„å†…å­˜å¤§å°å†³å®šäº†æŸ”æ€§æ•°ç»„çš„é•¿åº¦ï¼Œè¯¦æƒ…è¯·ç™¾åº¦æŸ”æ€§æ•°ç»„ï¼‰ ï¼Œcè¯­è¨€å¯¹äºç»“æ„ä½“çš„ä¼˜åŒ–æ²¡æœ‰åŒ…å«æŸ”æ€§æ•°ç»„è¿™ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»è‡ªå·±æ¥æ¥ç®¡è¿™ä¸€éƒ¨åˆ†çš„å†…å­˜å¯¹é½ï¼Œä¿è¯ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚ typedef struct raxNode { uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; /* Number of children, or compressed string len. */ unsigned char data[]; } raxNode; è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(1)","slug":"rax1","date":"2019-08-11T16:11:44.000Z","updated":"2019-11-25T19:48:25.184Z","comments":true,"path":"2019/08/12/rax1/","link":"","permalink":"http://yoursite.com/2019/08/12/rax1/","excerpt":"","text":"&emsp;&emsp;æœ€è¿‘æƒ³ç”¨libuvå†™ä¸ªhttpæœåŠ¡å™¨ï¼Œçœ‹åˆ°äº†è¿™ä¸ªå¼€æºé¡¹ç›®haywireï¼Œåœ¨çœ‹åˆ°ç¬¬39æ¬¡æäº¤çš„æ—¶å€™ï¼Œä½œè€…ç”¨åŸºæ•°æ ‘æ¥å­˜å‚¨ä¸åŒè·¯ç”±çš„controllerï¼Œä¸è¿‡åœ¨åç»­ç‰ˆæœ¬ä¸­æ”¹ä¸ºäº†ä½¿ç”¨hashï¼Œä¸è¿‡æƒ³æ¥ä¸å¦‚æ­£å¥½å­¦å­¦åŸºæ•°æ ‘ï¼Œä½œè€…ä½¿ç”¨çš„åŸºæ•°æ ‘æ˜¯è¿™ä¸ªç‰ˆæœ¬radix_treeï¼Œè¿™ä¸ªç‰ˆæœ¬ç¼ºå°‘æ³¨é‡Šï¼Œä¸”å’Œä¸€èˆ¬æ€è·¯ä¸ä¸€æ ·çš„ä½¿ç”¨çš„æ˜¯äºŒå‰æ ‘è€ŒéNå‰æ ‘ï¼Œä¸ºäº†ç†è§£æ–¹ä¾¿ï¼Œæˆ‘é€‰æ‹©äº†æ³¨é‡Šè¾ƒå¤šçš„rax æ•°æ®ç»“æ„&emsp;&emsp;é¦–å…ˆè¦æåˆ°çš„æ˜¯raxçš„æ•°æ®ç»“æ„è®¾è®¡ï¼š 1234567typedef struct raxNode &#123; uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; / unsigned char data[];&#125; raxNode; è¿™é‡Œç¬¬ä¸€ä¸ªè¦è¯´åˆ°çš„ç‚¹æ˜¯ï¼šä½ è§‰å¾—è¿™æ ·ä¸€ä¸ªæ•°æ®ç»“æ„çš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿ24ï¼Ÿ 16ï¼Ÿ è¿˜æ˜¯8ï¼Ÿ&emsp;&emsp;ç¬¬ä¸€ä¸ªåŸå› æ˜¯ä½åŸŸï¼Œä¹Ÿå°±æ˜¯ç»“æ„ä½“ä¸­çš„å†’å·ï¼š ï¼Œå†’å·åœ¨è¿™é‡Œå£°æ˜å®é™…éœ€è¦ä½¿ç”¨çš„ä½æ•°ï¼Œiskeyï¼Œisnullï¼Œiscomprï¼Œsizeå››ä¸ªä¸€å…±åŠ èµ·æ¥32ä½ï¼Œå 4ä¸ªå­—èŠ‚ã€‚&emsp;&emsp;ç¬¬äºŒä¸ªåŸå› æ˜¯data[]å 0ä¸ªå­—èŠ‚ã€‚unsigned char data[];è¿™æ ·ä¸€ä¸ªç»“æ„åœ¨è¿™é‡Œå¹¶ä¸æ˜¯ç†è§£æˆä¸€ä¸ªæŒ‡é’ˆ8ä¸ªå­—èŠ‚ã€‚è€Œæ˜¯ä¸€ä¸ªæŸ”æ€§æ•°ç»„çš„æ¦‚å¿µï¼Œå®ç°ä¸€ä¸ªå¯å˜é•¿åº¦ã€‚data[1]å ç»“æ„ä½“1ä¸ªå­—èŠ‚ï¼Œdata[2]å ç»“æ„ä½“2ä¸ªå­—èŠ‚â€¦â€¦.data[13]å 13ä¸ªå­—èŠ‚ã€‚æ•°ç»„ç±»å‹çš„å†…å­˜æ˜¯ç»“æ„ä½“ä¸­ç›´æ¥åˆ†é…çš„ï¼Œè€Œä¸æ˜¯åƒæŒ‡é’ˆä¸€æ ·éœ€è¦æˆ‘ä»¬åæ¥åˆ†é…ã€‚å¦‚ä¸‹å›¾å¯è§ï¼š 12345678910typedef struct raxNode &#123; unsigned char data[13];&#125; raxNode;int main(int argc, char *argv[])&#123; printf(&quot;%d\\n&quot;, sizeof(raxNode)); return 0;&#125; data[]&emsp;&emsp;æ¥ä¸‹æ¥æˆ‘ä»¬è¿˜æ˜¯è¦è°ˆdataï¼Œåœ¨è¿™é‡Œdataçš„æ„ä¹‰å¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•çš„unsigned charæ•°ç»„ï¼Œå®ƒå­˜å‚¨çš„æ˜¯é”®å€¼keyå’ŒradixNodeæŒ‡é’ˆä¸¤ç§å˜é‡ã€‚å›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132dataçš„å®é™…ä½¿ç”¨æ–¹å¼åœ¨å¤§å¤šæ•°æ—¶å€™æ˜¯ä»¥å†…å­˜åœ°å€çš„æ–¹å¼è¿›è¡Œçš„ã€‚ 123456#define raxNodeLastChildPtr(n) ((raxNode**) ( \\ ((char*)(n)) + \\ raxNodeCurrentLength(n) - \\ sizeof(raxNode*) - \\ (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \\)) &emsp;&emsp;è¿™æ˜¯è®¿é—®æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯è®¿é—®å›¾ä¸­çš„A-ptrï¼‰ã€‚næ˜¯ä¸€ä¸ªraxNode*æŒ‡é’ˆï¼Œå¯¹è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„åœ°å€è¿›è¡Œï¼‹æ“ä½œæ¥å¾—åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚ èŠ‚ç‚¹çš„è¡¨ç¤ºå›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132&emsp;&emsp;å‡è®¾åŸºæ•°æ ‘ä¸­æœ‰â€œabcdâ€è¿™ä¸ªé”®å€¼çš„èŠ‚ç‚¹ã€‚é‚£ä¹ˆå®ƒçš„è¡¨ç¤ºå½¢å¼æ˜¯åƒä¸Šå›¾è¿™æ ·çš„ã€‚â€œabcdâ€è¿™ä¸ªèŠ‚ç‚¹çš„value-dataå­˜å‚¨åœ¨å›¾ç‰‡ä¸‹åŠéƒ¨åˆ†çš„èŠ‚ç‚¹å¤„ï¼Œå¹¶ä¸”ä¸‹é¢ä¸€ä¸ªèŠ‚ç‚¹iskeyè®¾ä¸º1.&emsp;&emsp;ä¸ºä»€ä¹ˆä¸æ˜¯ç›´æ¥åªæœ‰å›¾ç‰‡çš„ä¸ŠåŠéƒ¨åˆ†ï¼Œç”±å›¾ç‰‡ä¸ŠåŠéƒ¨åˆ†é‚£ä¸ªèŠ‚ç‚¹å°†iskeyè®¾ç½®ä¸º1å¹¶ä¸”å°†å€¼å­˜å‚¨åœ¨å…¶valueÂ·dataä¸­å‘¢ï¼Ÿåƒè¿™æ ·ï¼š [iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr] å…ˆç»™å‡ºç»“è®ºï¼š åœ¨raxä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å­˜åœ¨ï¼ˆiskey == 1ï¼‰æ˜¯ç”±dataä¸­å¯¹åº”çš„å­èŠ‚ç‚¹æ¥è¡¨ç¤ºçš„ã€‚åŸå› å¾ˆç®€å•ï¼šåœ¨è¿™ä¸ªä¾‹å­é‡Œé¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰å‹ç¼©çš„èŠ‚ç‚¹ï¼Œè¿™ä¸€å±‚ç”±aå’ŒAä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœåœ¨å½“å‰å±‚æ¬¡è¡¨ç¤ºï¼Œå¦‚ä½•åˆ†è¾¨ä½ æŒ‡å®šçš„æ˜¯aè¿˜æ˜¯Aï¼Ÿæ‰€ä»¥ç”¨å¼•å‡ºå­èŠ‚ç‚¹æ¥è¡¨ç¤ºã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}]}