{"meta":{"title":"lurenaaのblog","subtitle":"","description":"","author":"两天宇宙人","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2019-11-21T19:51:46.860Z","updated":"2019-11-21T19:51:46.860Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T20:04:05.184Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T19:32:31.327Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-11-21T20:12:46.614Z","updated":"2019-11-21T20:12:46.614Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"179.最大数","slug":"leetcode179","date":"2020-01-11T12:18:40.000Z","updated":"2020-01-11T13:53:52.979Z","comments":true,"path":"2020/01/11/leetcode179/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode179/","excerpt":"","text":"🥩堆排序&emsp;&emsp;堆排序，然后将数字拼接成字符串，但是两个数字之间的比较并不能直接用&gt;&lt;来进行。我的方法是定义compare函数，进行比较。compare比较两个数的方法是：比如121，12，那么就比较121|12和12|121的大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; a) &#123; if(!a.size()) return &quot;&quot;; string s; //堆排序 a.insert(a.begin(), -1); int n = a.size() - 1; for(int i = 2; i &lt;= n; ++i) &#123; swim(a, i, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; while(n &gt; 1) &#123; swap(a[1], a[n--]); sink(a, 1, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; for(int i = 1; i &lt; a.size(); ++i) s += to_string(a[i]); int ct = 0; for(int i = 0; i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;; ++i) &#123; ++ct; &#125; if(ct == s.size()) return &quot;0&quot;; return s.substr(ct); &#125; void swim(vector&lt;int&gt;&amp; a, int k, int n) &#123; cout &lt;&lt; &quot;swim&quot; &lt;&lt; endl; int j; while(k &gt; 1) &#123; j = k /2; if(j &gt;= 1 &amp;&amp; compare(a[j],a[k]) != 1) break; swap(a[j], a[k]); k = j; &#125; &#125; void sink(vector&lt;int&gt;&amp; a, int k, int n) &#123; int j ; while(k &lt;= n / 2) &#123; j = 2 * k; if(j + 1 &lt;= n &amp;&amp; compare(a[j + 1], a[j]) == -1) ++j; if(compare(a[j], a[k]) != -1) break; swap(a[j], a[k]); k = j; &#125; &#125; int compare(int i, int j) &#123; if(i == j) return 0; int com = 0, ix = 0, jx = 0, ii = i, jj = j; while(ii / 10 &gt; 0) &#123; ix++; ii /= 10; &#125; while(jj / 10 &gt; 0) &#123; jx++; jj /= 10; &#125; long long ir ,jr; jr = j * pow(10, ix + 1) + i; ir = i * pow(10, jx + 1) + j; // cout &lt;&lt; &quot;i, j: &quot; &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; jr &lt;&lt; endl; if(ir &gt; jr) return 1; else if(jr &gt; ir) return -1; else return 0; &#125;&#125;; Accepted222/222 cases passed (8 ms) Your runtime beats 91.43 % of cpp submissions Your memory usage beats 79.45 % of cpp submissions (9.1 MB) 🈶改进&emsp;&emsp;相比与我将两个数拼在一起比较，更加好的方法是转化为字符串比较 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if (all_of(nums.begin(), nums.end(), [](int x) &#123; return x == 0; &#125;)) &#123; return string(&quot;0&quot;); &#125; vector&lt;string&gt; strNums(nums.size()); std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123; return std::to_string(x); &#125;); std::sort(strNums.begin(), strNums.end(), [](const string&amp; x, const string&amp; y) &#123; /* x为后面元素，y为前面元素，return true则将x移动到前面 */ return x + y &gt; y + x; &#125;); return std::accumulate(strNums.begin(), strNums.end(), string()); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"147.对链表进行插入排序","slug":"leetcode147","date":"2020-01-11T07:55:04.000Z","updated":"2020-01-11T11:51:35.600Z","comments":true,"path":"2020/01/11/leetcode147/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode147/","excerpt":"","text":"🥧模仿数组的实现&emsp;&emsp;注意pre指针的调整，在内循环改变一个节点ptr的位置后，外层循环的ptr的下一个循环就不是ptr-&gt;next了，而是pre-&gt;next 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head-&gt;next, *nex, *pre = head,*ptr2, *pre2, npre = ListNode(INT_MIN); npre.next = head; for( ; ptr != nullptr; ) &#123; for(ptr2 = npre.next, pre2 = &amp;npre; ptr2 != ptr; ptr2 = ptr2-&gt;next, pre2 = pre2-&gt;next)&#123; if(ptr2-&gt;val &gt;= ptr-&gt;val) &#123; pre-&gt;next = ptr-&gt;next; ptr-&gt;next = ptr2; pre2-&gt;next = ptr; break; &#125; &#125; if(ptr2 == ptr) &#123; ptr = ptr-&gt;next; pre = pre-&gt;next; &#125; else &#123; ptr = pre-&gt;next; &#125; // for(auto x = &amp;npre; x != nullptr; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; &#125; return npre.next; &#125;&#125;; Accepted 22/22 cases passed (100 ms) Your runtime beats 6.64 % of cpp submissions Your memory usage beats 13.73 % of cpp submissions (9.7 MB) 🏆改进版&emsp;&emsp;对于插入排序来说，我们没有必要记录那么多前置节点的位置，我们只要保证ptr左边的序列有序即可 1234567891011121314151617181920212223class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head, *nex,*ptr2, npre = ListNode(INT_MIN); while(ptr) &#123; nex = ptr-&gt;next; ptr2 = &amp;npre; while(ptr2-&gt;next &amp;&amp; ptr2-&gt;next-&gt;val &lt; ptr-&gt;val) ptr2 = ptr2-&gt;next; ptr-&gt;next = ptr2-&gt;next; ptr2-&gt;next = ptr; // for(auto x = &amp;npre; x != NULL; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; &quot; cur: &quot; &lt;&lt; ptr-&gt;val &lt;&lt; endl; ptr = nex; &#125; return npre.next; &#125;&#125;; Accepted22/22 cases passed (48 ms)Your runtime beats 73.88 % of cpp submissions Your memory usage beats 15.9 % of cpp submissions (9.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"56.合并区间","slug":"leetcode56","date":"2020-01-11T06:50:05.000Z","updated":"2020-01-11T07:20:33.360Z","comments":true,"path":"2020/01/11/leetcode56/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode56/","excerpt":"","text":"🥛使用数组&emsp;&emsp;使用数组来进行操作，特别[0,1][2,4]这样连在一起。却没有相交的情况 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; char arr[3000] = &quot;&quot;; vector&lt;vector&lt;int&gt;&gt; res; for(auto x : intervals) &#123; memset(arr + x[0], &apos;1&apos; ,x[1] - x[0]); if(arr[x[1]] != &apos;1&apos;) arr[x[1]] = &apos;2&apos;; else arr[x[1]] = &apos;1&apos;; &#125; int count = 0, k; for(int i = 0; i &lt; 3000; ++i) &#123; if(arr[i] != &apos;\\0&apos;) &#123; count = 0; for(k = i; k &lt; 3000 &amp;&amp; arr[k] == &apos;1&apos;; ++k) &#123; arr[k] = &apos;\\0&apos;; ++count; &#125; arr[k] = &apos;\\0&apos;; res.push_back(vector&lt;int&gt;&#123;i, i + count&#125;); &#125; &#125; return res; &#125;&#125;; Accepted169/169 cases passed (20 ms)Your runtime beats 90.61 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (13.3 MB) 🚆排序后比较&emsp;&emsp; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a ,const vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0]; &#125;); // for(auto x : intervals) &#123; // cout &lt;&lt; x[0] &lt;&lt; x[1] &lt;&lt; endl; // &#125; int i = 0, beg, endx, n = intervals.size(); while(i &lt; n) &#123; beg = intervals[i][0]; endx = intervals[i][1]; while(i &lt; n - 1&amp;&amp; intervals[i + 1][0] &lt;= endx) &#123; ++i; if(intervals[i][1] &gt; endx) endx = intervals[i][1]; &#125; // cout &lt;&lt; beg &lt;&lt; &quot; &quot; &lt;&lt; endx &lt;&lt; endl; res.push_back(vector&lt;int&gt;&#123;beg, endx&#125;); ++i; &#125; return res; &#125;&#125;; Accepted 169/169 cases passed (12 ms)Your runtime beats 99.88 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (12.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"75.颜色分类","slug":"leetcode75","date":"2020-01-11T03:33:29.000Z","updated":"2020-01-11T08:13:03.417Z","comments":true,"path":"2020/01/11/leetcode75/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode75/","excerpt":"","text":"🥧典型的堆排序题目&emsp;&emsp; 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; nums.insert(nums.begin(), 0); int n = nums.size() - 1; for(int i = n / 2; i &gt;= 1; --i) &#123; sink(nums, i, n); &#125; while(n &gt; 1) &#123; swap(nums[1], nums[n--]); sink(nums, 1, n); &#125; nums.erase(nums.begin()); &#125; void sink(vector&lt;int&gt;&amp; nums, int k,int n) &#123; int j; while(k &lt;= n / 2) &#123; j = k * 2; if(nums[j] &lt; nums[j + 1] &amp;&amp; j + 1 &lt;= n) ++j; if(nums[k] &gt;= nums[j]) break; swap(nums[k], nums[j]); k = j; &#125; &#125;&#125;; Accepted87/87 cases passed (0 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 5.17 % of cpp submissions (8.9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"21.合并两个有序链表","slug":"leetcode21","date":"2020-01-11T03:18:02.000Z","updated":"2020-01-11T03:29:41.869Z","comments":true,"path":"2020/01/11/leetcode21/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode21/","excerpt":"","text":"🥛迭代&emsp;&emsp;类似与归并排序的合并函数，实际还要更简单一些，没有长度的限制 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode nd(0), *pre = &amp;nd; while(l1 || l2) &#123; if(!l1) &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; else if(!l2) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else if(l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; return nd.next; &#125;&#125;; Accepted208/208 cases passed (8 ms)Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 76.07 % of cpp submissions (9 MB) 🥛递归12345678910111213141516class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; else if(l2-&gt;val &lt; l1-&gt;val) &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; else &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; &#125;&#125;; Accepted208/208 cases passed (8 ms) Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 75.58 % of cpp submissions (9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"148. 排序链表","slug":"leetcode148","date":"2020-01-10T16:51:18.000Z","updated":"2020-01-11T06:27:48.055Z","comments":true,"path":"2020/01/11/leetcode148/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode148/","excerpt":"","text":"🥩自顶向下归并排序&emsp;&emsp;基础版，根据算法4中的数组的归并算法改得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head) return head; n = 1; ListNode* h = head; while(h-&gt;next != NULL) &#123; h = h-&gt;next; ++n; &#125; //cout &lt;&lt; &quot;count : &quot; &lt;&lt; n &lt;&lt; endl; aux = new int[n](); sortList(head, 0, n - 1); return head; &#125; void sortList(ListNode* head, int i, int j) &#123; if(i &gt;= j) return ; int mid = i + (j - i) / 2; sortList(head, i, mid); sortList(head, mid + 1, j); merge(head, i, mid, j); &#125; void merge(ListNode* head, int i,int mid, int j) &#123; //cout &lt;&lt; &quot;i,m.j : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ListNode* inode = at(head, i),* inode2 = inode; //cout &lt;&lt; &quot;inode-&gt;val: &quot; &lt;&lt; inode2-&gt;val &lt;&lt; endl; int lo = i - i, hi = mid + 1 - i; for(int k = 0; k &lt;= j - i; ++k , inode = inode-&gt;next) aux[k + i] = inode-&gt;val; // for(int k = i; k &lt;= j; ++k) &#123; //cout &lt;&lt; aux[k] &lt;&lt; &quot; &quot;; // &#125; //cout &lt;&lt; endl; for(int k = 0; k &lt;= j - i; ++k) &#123; if(lo &gt; mid - i)&#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else if (hi &gt; j - i) &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; else if (aux[lo + i] &gt; aux[hi + i]) &#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; //cout &lt;&lt; &quot;lo, hi : &quot; &lt;&lt; lo &lt;&lt; &quot; &quot; &lt;&lt; hi &lt;&lt; endl; inode2 = inode2-&gt;next; &#125; &#125; ListNode* at(ListNode* head, int n) &#123; while(n--) head = head-&gt;next; return head; &#125; int* aux; int n;&#125;; Accepted16/16 cases passed (1108 ms) Your runtime beats 5.09 % of cpp submissionsYour memory usage beats 62.56 % of cpp submissions (12.3 MB) 🥧自顶向下归并排序2&emsp;&emsp;学习自链接,以一种链表得方式来做，而不是以数组得方式来思考 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, * fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = nullptr; ListNode* left = sortList(head); ListNode* right = sortList(tmp); ListNode thead = ListNode(-1), *thd = &amp;thead; while(left || right) &#123; if(!left) &#123; thd-&gt;next = right; right = right-&gt;next; &#125; else if(!right) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else if (right-&gt;val &gt; left-&gt;val) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else &#123; thd-&gt;next = right; right = right-&gt;next; &#125; thd = thd-&gt;next; &#125; return thead.next; &#125; &#125;; Accepted 16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 72.66 % of cpp submissions (11.9 MB) 🥣自底向上归并排序&emsp;&emsp;学习自链接，自底向上得链表，有几个难点: 如何每次merge后与后面得链表接上 如何串联成一个长得链表最后返回1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* preNode = new ListNode(0), *pre = preNode; pre-&gt;next = head; int count = 0; while((pre = pre-&gt;next) &amp;&amp; ++count) ; // cout &lt;&lt; &quot;count : &quot; &lt;&lt; count &lt;&lt; endl; pre = preNode; for(int sz = 1; sz &lt; count; sz *=2) &#123; while(pre = sortList(pre, sz)) ; pre = preNode; &#125; return preNode-&gt;next; &#125; ListNode* sortList(ListNode* pre, int sz) &#123; ListNode* fl = pre-&gt;next, *ll = pre-&gt;next; for(int i = 0; i &lt; sz ; ++i) &#123; if(!ll) return nullptr; ll =ll-&gt;next; &#125; int lc = 0, fc = 0; while(fc &lt; sz) &#123; if(lc == sz || ll == nullptr || ll-&gt;val &gt; fl-&gt;val) &#123; ++fc; pre-&gt;next = fl; fl = fl-&gt;next; &#125; else &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; &#125; pre = pre-&gt;next; &#125; while(lc &lt; sz &amp;&amp; ll) &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next = ll; return pre; &#125;&#125;; Accepted16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 93.48 % of cpp submissions (11.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"堆排序","slug":"alg4","date":"2020-01-10T14:59:59.000Z","updated":"2020-01-10T15:32:32.295Z","comments":true,"path":"2020/01/10/alg4/","link":"","permalink":"http://yoursite.com/2020/01/10/alg4/","excerpt":"","text":"😘代码实现123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 堆排序 **/template&lt;typename T&gt;class HeapSort &#123; public: static void sort(vector&lt;T&gt;&amp;); private: static void sink(vector&lt;T&gt;&amp; a, int k, int N);&#125;;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123; int N = a.size() - 1; for(int i = N / 2; i &gt;= 1; --i) sink(a, i, N); while(N &gt; 1) &#123; swap(a[1], a[N--]); sink(a, 1, N); &#125;&#125;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123; int j; while(k &lt;= N / 2) &#123; j = 2 * k; if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j; if(a[k] &gt;= a[j]) break; swap(a[k], a[j]); k = j; &#125;&#125; 👿注意 要注意父节点只有一个子节点时的情况，在sink函数中（if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;）一定要注意j&lt;N，不能超出范围 构造最大堆时，for循环从i = N / 2开始的原因是：sink中有限制条件while(k &lt;= N / 2)，所以N/2&lt;i&lt;N部分无法进入sink的while循环，是没有意义的，徒增N/2次比较 递增排序使用最大堆，递减排序使用最小堆 vector的第一个值（下标为0）不使用","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"索引优先队列","slug":"alg3","date":"2020-01-10T08:36:33.000Z","updated":"2020-01-10T14:28:54.460Z","comments":true,"path":"2020/01/10/alg3/","link":"","permalink":"http://yoursite.com/2020/01/10/alg3/","excerpt":"","text":"🥛分析12345678910111213141516public class IndexMaxPQ...&#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i//中间省略...public void insert(int i, Key key) &#123; ... n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n);&#125; &emsp;&emsp;根据《算法4》给出的代码，分析这两段代码我们可以看出来： 在定义处可知pq是二叉堆的数组 由qp[i] = n;pq[n] = i;可以看出来，qp这个数组的用处就是为了记录**pq中值为i的下标是多少**，这样当我们要改下标为i的元素的值时，我们就不用遍历pq来获得位置了，**用空间来换取时间** 并且这个索引i仅仅为了找到元素对象key，并没实际的意义。n才是对应二叉堆的位置。 😍代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * 索引最小优先队列 **/ template&lt;typename T&gt;class IndexMinPQ &#123; public: IndexMinPQ(int max); void show() const; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125; void insert(int k, T item); void change(int k, T item); bool contain(int k) const &#123;return qp[k] != -1;&#125;; int delMin(); private: void sink(int i); void swim(int i); T* element; //元素 int* pq; //二叉堆 int *qp; //index int N; int _capacity;&#125;;template&lt;typename T&gt;IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) : element(new T[max + 1]), pq(new int[max + 1]) , qp(new int[max + 1]), N(0), _capacity(max) &#123; for(int i = 0; i &lt; max + 1; ++i) qp[i] = -1;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::sink(int n)&#123; while(n &lt; N) &#123; int m = n * 2; if(element[pq[m]] &gt; element[pq[m + 1]]) ++m; if(element[pq[m]] &lt; element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::swim(int n) &#123; while(n &gt; 1) &#123; int m = n / 2; if(element[pq[m]] &lt;= element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123; // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; if(capacity() == size())&#123; cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl; return ; &#125; pq[++N] = k; element[k] = item; qp[k] = N; swim(N); // show();&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::show() const&#123; cout &lt;&lt; &quot;pq: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;qp: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;element: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123; if(!contain(k)) &#123; cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl; return ; &#125; T old_one = element[k]; element[k] = item; if(item &gt; old_one) sink(qp[k]); else if(item &lt; old_one) swim(qp[k]);&#125;template&lt;typename T&gt;int IndexMinPQ&lt;T&gt;::delMin() &#123; int max = pq[1]; swap(pq[1], pq[N]); swap(qp[pq[1]], qp[pq[N]]); --N; show(); sink(1); show(); qp[max] = -1; element[max] = -1; pq[N + 1] = -1; return max;&#125;int main(int argc, char** argv) &#123; IndexMinPQ&lt;int&gt; pq(6); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6); for(size_t i = 0; i &lt; v.size(); ++i) &#123; pq.insert(i + 1, v[i]); &#125; pq.show(); pq.delMin(); pq.show(); return 0;&#125; 🍠参考资料：链接","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"优先队列","slug":"alg2","date":"2020-01-10T07:57:40.000Z","updated":"2020-01-10T08:36:50.374Z","comments":true,"path":"2020/01/10/alg2/","link":"","permalink":"http://yoursite.com/2020/01/10/alg2/","excerpt":"","text":"🍠优先队列的实现有三种： 有序数组 无序数组 堆 🍅有序数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * 优先队列 * 2.4.3 有序数组实现 **/ template&lt;typename T&gt;class OrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit OrderArrayMaxPQ(int max); ~OrderArrayMaxPQ() &#123;delete [] arr;&#125; // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;// template&lt;typename T&gt;// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) // : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())// &#123;// copy(l.begin(), l.end(), arr);// &#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x; for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i) swap(arr[i], arr[i - 1]); &#125;template&lt;typename T&gt;pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; res = arr[N - 1]; arr[--N] = pair&lt;int , T&gt;(); return res;&#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; OrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥦无序数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * 优先队列 * 2.4.3 无序数组实现 **/ template&lt;typename T&gt;class UnOrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit UnOrderArrayMaxPQ(int max); ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125; explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())&#123; copy(l.begin(), l.end(), arr);&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x;&#125;template&lt;typename T&gt;pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123; if(isEmpty()) return pair&lt;int, T&gt;(); int max_one = 0; for(int i = 0; i &lt; N; ++i) if(arr[max_one].first &lt; arr[i].first) &#123; max_one = i; &#125; swap(arr[max_one], arr[--N]); pair&lt;int,T&gt; res = arr[N]; arr[N] = pair&lt;int,T&gt;(); return res;&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; UnOrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥧堆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * 优先队列 * 二叉堆实现 **/ template&lt;typename T&gt;class MaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; void swim(int i); void sink(int i); public: void show() const ; explicit MaxPQ(int max); ~MaxPQ() &#123;delete [] arr;&#125; void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;MaxPQ&lt;T&gt;::MaxPQ(int max) : arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)&#123; arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[++N] = x; swim(N);&#125;template&lt;typename T&gt;pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; swap(arr[N--], arr[1]); res = arr[N + 1]; arr[N + 1] = pair&lt;int ,T&gt;(); sink(1); return res;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 1; i &lt;= N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::swim(int i) &#123; while(i &gt; 1) &#123; if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]); i /= 2; &#125;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::sink(int i) &#123; int k; while(i &lt; N) &#123; k = 2 * i; if(arr[k].first &lt; arr[k + 1].first) ++k; if(arr[k].first &lt;= arr[i].first) break; swap(arr[k], arr[i]); i = k; &#125;&#125;int main(int argc, char** argv) &#123; MaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); // pq.show(); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; 🥨时间复杂度对比 有序数组： 插入：N，删除：1 无序数组： 插入：1，删除：N 堆：插入、删除：lgN 理想情况：都是1","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"为甚么异或能够确定两个数的符号是否相同？","slug":"problems2","date":"2020-01-08T14:28:49.000Z","updated":"2020-01-08T15:06:10.423Z","comments":true,"path":"2020/01/08/problems2/","link":"","permalink":"http://yoursite.com/2020/01/08/problems2/","excerpt":"","text":"12unsigned int a = -1;printf(&quot;%d,%u,%x&quot;,a,a,a); -1,4294967295,ffffffff从结果上来说,验证了C++中使用的是补码。 🍠现在说一说为什么异或能够确定两个数的符号是否相同？&emsp;&emsp;这里还有一个前提，两个数都是int类型，因为补码的原因，如果两个数的正负不同，那么它们的第一位就不同，因为int的第一位是正负的标志位。通过异或，那么正数的第一位为0，负数的第一位为1，异或后第一位就为1，所以可以得到计算出的值为负值。相反如果两者符号相同，那么通过异或后，第一位就为0，所以为正数。","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"二分查找","slug":"alg1","date":"2020-01-07T14:24:36.000Z","updated":"2020-01-08T13:56:04.220Z","comments":true,"path":"2020/01/07/alg1/","link":"","permalink":"http://yoursite.com/2020/01/07/alg1/","excerpt":"","text":"时间复杂度logN 二分查找的实现可以分为两种，一种是递归式的、另一种是循环式的😜递归式 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123; // if(lo &gt; ho) return -1; // int mid = (lo + ho) / 2; // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key); // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); // else return mid; if(lo &gt;= ho) return -1; int mid = (lo + ho) / 2; if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key); else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); else return mid;&#125; &emsp;&emsp;区间的开闭自由选取，主要是要统一，如果要求传入左闭右开区间，那么在函数内部的处理也要保持左闭右开。一般的选择应该时左右都是闭区间，而在特殊情况时（数组中有多个相同的目标时），这时选择左闭右开。🥛参考：wiki链接&emsp;&emsp;为了避免ho + lo 大于INT_MAX最好改用lo + (ho - lo) / 2 🈶非递归式 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123; int lo = 0, ho = a.size(), mid; while(lo &lt; ho) &#123; mid = (lo + ho) / 2; if(a[mid] &gt; key) ho = mid; else if(a[mid] &lt; key) lo = mid + 1; else return mid; &#125; return -1;&#125; 递归要满足三个原则： 递归总有一个最简单的情况—方法的第一句总是一个包含return的条件语句。 递归调用总要尝试取解决一个规模更小的子问题。 递归调用的父问题和子问题之间不应该有交集。 🥘推荐相关资料：讲解 👍练习题目1：4. 寻找两个有序数组的中位数123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //首先要判定拿个序列更加长 if(nums1.size() &gt; nums2.size()) swap(nums1, nums2); //左闭右开 int imin = 0, imax = nums1.size(), j, i, m = nums1.size(), n = nums2.size(), halflen = (m + n + 1) / 2; while(imin &lt;= imax) &#123; i = (imax + imin ) / 2; j = halflen - i; // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; imin = i + 1; &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; imax = i; &#125; else &#123; // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; int leftMax, rightMin; if(i == 0 ) leftMax = nums2[j - 1]; else if(j == 0) leftMax = nums1[i - 1]; else leftMax = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2) return leftMax; if(i == m) rightMin = nums2[j ]; else if (j == n) rightMin = nums1[ i ]; else rightMin = min(nums1[i], nums2[j]) ; // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl; return static_cast&lt;double&gt;(leftMax + rightMin) / 2; &#125; &#125; return -1; &#125;&#125;; 👍练习题目2：35. 搜索插入位置12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, ho = nums.size() - 1, mid; while(lo &lt; ho) &#123; mid = (lo + ho + 1) / 2; if(nums[mid] &gt; target) &#123; ho = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; if(nums[lo] &lt; target) return lo + 1; else return lo; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"libuv源码分析（6）uv_queue_work","slug":"libuv6","date":"2019-11-26T12:06:58.000Z","updated":"2019-11-26T12:56:52.025Z","comments":true,"path":"2019/11/26/libuv6/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv6/","excerpt":"","text":"🏤问题来由&emsp;&emsp;在使用libuv的过程中，我们难免遇见的一个问题是，有一些库没有异步、只能同步运行，这种情况该怎么办呢？比如mysql-connector-cpp。 &emsp;&emsp;首先要说的是，直接在回调函数中执行mysql-connector-cpp这种会阻塞的操作是不符合Libuv的reactor模式的。 123456void handle_json_lab(std::shared_ptr&lt;smpHttp::HttpRequest&gt; req,std::shared_ptr&lt;smpHttp::HttpResponse&gt; res) &#123; try&#123; Session mq = cli.getSession(); auto sqlres = mq.sql(\"Select content FROM labimformation where type = 'labIntroduction'\").execute(); ... &emsp;&emsp;上面这样便是错误的案例。我在写这个项目时，之前就采用了这样的错误做法。&emsp;&emsp;我的这个项目是个http后台，我在接受到POST请求，直接在回调函数中执行mysql操作，这时整个主线程就阻塞住了1，而这就意味着我的http后台不再能接受任何请求，只能等待mysql操作完成后，回调函数返回。而这个mysql的操作耗时一般在3s以上，这对我这个Http后台来说是毁灭性的打击。。。。 1：用户的回调函数是在work->done函数的最后执行的，而work->done是在主线程uv_run中的is_poll中唤醒loop->wq_async后执行的,在work->done函数中阻塞意味着在主线程阻塞住了，uv_run中的事件循环卡住，不再能接受request（这部分不清楚可以去看我的libuv源码分析文章） 🌆解决办法&emsp;&emsp;在手册Thread pool work scheduling中为我们这样的需求提供了这样一个函数：uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)。 &emsp;&emsp;这个函数就是上面我们问题的解决办法。但是要注意的是uv_async_t不可以替代这个。虽然都是执行用户的函数。async是让用户函数直接被主线程在uv_run中运行，而uv_queue_work是将work_cb提交给子线程执行，完成后通知主线程，主线程在uv_run中执行after_work_cb。 &emsp;&emsp;总结下来就是：uv_async_t用来执行不阻塞的任务，uv_queue_work执行要阻塞的任务（考虑到线程切换的消耗一般不用来执行不阻塞的任务） 🉐看看源码&emsp;&emsp;这一部分可以结合这我的这篇文章-libuv源码分析（5）uv_fs_*来看。可以作为佐证，libuv中对着这类没有自带异步版本的阻塞操作的处理是一样的：让子线程去执行这个任务，避免阻塞主线程的事件循环，完成后子线程通知主线程。uv_queue_work源码： 123456789101112131415161718int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) &#123; if (work_cb == NULL) return UV_EINVAL; uv__req_init(loop, req, UV_WORK); req-&gt;loop = loop; req-&gt;work_cb = work_cb; req-&gt;after_work_cb = after_work_cb; uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, uv__queue_work, uv__queue_done); return 0;&#125; 再结合我的这篇文章-libuv源码分析（5）uv_fs_*中uv_fs_*函数的源码，这些操作可以总结成以下代码： 12345678UV_REQ_INIT(req, typ); //初始化基类uv_req_t uv__req_register(loop, req); //添加loop中request的计数，避免uv_run中uv__loop_alive返回0，使得主线程uv_run退出...//这里是针对不同类型的操作特有的初始化部分uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, //操作类型 uv__queue_work, //要阻塞的操作，在fs中是uv__fs_work uv__queue_done); //完成后的回调，在fs中是uv__fs_done","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（5）uv_fs_*","slug":"libuv5","date":"2019-11-25T18:57:15.000Z","updated":"2019-11-25T19:41:02.563Z","comments":true,"path":"2019/11/26/libuv5/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv5/","excerpt":"","text":"uv_fs_*&emsp;&emsp;uv_fs_*这一系列的函数基本是一致的，它们的逻辑大概是如下： 123456//x代表一种操作open、write等int uv_fs_x(...uv_fs_t* req...) &#123; INIT(x); //uv_fs_t和其基类uv_req_t的基本初始化 ... //这里是每个操作各自不同对于req的初始化 POST; //提交这个任务&#125; INIT&emsp;&emsp;INIT这个宏定义函数没有特别的地方，就是把req初始化，该置0的置0。 POST&emsp;&emsp;其实现如下： 1234567891011121314151617#define POST do &#123; //dowhile包裹作用域 if (cb != NULL) &#123; uv__req_register(loop, req); uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_FAST_IO, uv__fs_work, uv__fs_done); return 0; &#125; else &#123; uv__fs_work(&amp;req-&gt;work_req); return req-&gt;result; &#125; &#125; while (0) &emsp;&emsp;这里通过有无回调函数来决定调用同步版本还是异步版本。 http://docs.libuv.org/en/v1.x/fs.htmllibuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously. &emsp;&emsp;uv__fs_work这个函数就是文件操作的封装，所有的文件操作都通过这个函数来完成，即使是异步，最终也要在别的线程中同步执行这个函数。 &emsp;&emsp;uv__fs_done这个函数会调用用户给的回调函数，这个函数会在uv_run中的is_poll函数中得到执行。 &emsp;&emsp;uv__work_submit函数的实现是这样的： 12345678910void uv__work_submit(uv_loop_t* loop,struct uv__work* w,enum uv__work_kind kind, void (*work)(struct uv__work* w),void (*done)(struct uv__work* w, int status)) &#123; uv_once(&amp;once, init_once); w-&gt;loop = loop; w-&gt;work = work; w-&gt;done = done; post(&amp;w-&gt;wq, kind);&#125; &emsp;&emsp;uv_once(&amp;once, init_once);是初始化多个线程，我在我的第三篇文章中有介绍。不过当时对于子线程运行的worker函数没有提及，work函数大概是这样的： 123456789101112131415161718192021222324252627282930static void worker(void* arg) &#123; ... uv_mutex_lock(&amp;mutex); for (;;) &#123; while (QUEUE_EMPTY(&amp;wq)...) &#123; idle_threads += 1; uv_cond_wait(&amp;cond, &amp;mutex); idle_threads -= 1; &#125; q = QUEUE_HEAD(&amp;wq); ... QUEUE_REMOVE(q); QUEUE_INIT(q); ... w = QUEUE_DATA(q, struct uv__work, wq); w-&gt;work(w); uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex); w-&gt;work = NULL; QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); uv_async_send(&amp;w-&gt;loop-&gt;wq_async); uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); uv_mutex_lock(&amp;mutex); ... &#125;&#125; &emsp;&emsp;我去掉了对于slow_io的处理，大致是这样一个过程。 &emsp;&emsp;一开始线程会卡在uv_cond_wait这里，直到被uv_cond_signal唤醒，如果唤醒时wq队列中有任务，它就会执行任务，w-&gt;work(w)也就是调用uv__fs_work。然后把w放入loop-&gt;wq（为了uv__fs_done的执行）。 &emsp;&emsp;uv_async_send调用让loop-&gt;wq_async可读，主线程就从uv_run中的uv__io_poll的epoll_pwait中醒来，wq_async的回调函数会遍历loop-&gt;wq执行w-&gt;done。（我的第四篇文章有讲这一部分的详细内容） 谁来触发uv_cond_signal唤醒子线程呢？🥣uv__work_submit中的post函数： 123456uv_mutex_lock(&amp;mutex);...QUEUE_INSERT_TAIL(&amp;wq, q);if (idle_threads &gt; 0) uv_cond_signal(&amp;cond);uv_mutex_unlock(&amp;mutex); &emsp;&emsp;我再次省略了slow_io的部分，因为它们只是特殊处理。 &emsp;&emsp;该函数有空闲的线程就唤醒，不然就阻塞该线程。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（4）async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-25T19:24:48.508Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuv中async的开端在uv_loop_init函数中： 12345678//前面省略err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//后面省略 &emsp;&emsp;loop-&gt;wq_async是个uv_async_t类型，它用于线程work函数调用最后处理loop-&gt;wq中的回调，暂时不用管,我在我的第五篇文章会讲到它的用途。&emsp;&emsp;我们来看uv_async_init内部： 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;第五行以后的操作就是初始化基类uv_handle_t以及子类uv_async_t，然后将这个handle放入loop-&gt;queue(放uv_handle_t的队列)以及放入loop-&gt;async_handles（放uv_async_t的队列）中，然后uv__handle_start中将loop-&gt;active_handles加一。&emsp;&emsp;总而言之，第五行以后的内容就是初始化uv_async_t，可以理解成uv_async_t的构造函数。&emsp;&emsp;uv__async_start则不一样，它是初始化函数，它只会调用一次（一般情况是在uv_loop_init中调用），我们先看下它的实现： 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //中间省略 uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;看第三行loop-&gt;async_io_watcher.fd，当你调用过一次这个函数后，loop-&gt;async_io_watcher.fd不会等于-1，以后你初始化uv_async_t类型变量，调用uv_async_init函数时，uv__async_start都是直接返回的。&emsp;&emsp;我省略掉了中间如果eventfd没有在当前系统下实现时的兼容性处理。总的来说，就是初始化loop-&gt;async_io_watcher。uv__io_t是为epoll设计的结构体。这里你肯定感觉很懵逼，请坚持一下，最后我会梳理一下总体的整个过程。&emsp;&emsp;uv__io_t的实现是这样的： 12345678uv__io_t&#123; uv__io_cb cb; //回调函数 void* watcher_queue[2]; //放入loop-&gt;watcher_queue void* pending_queue[2]; //同理 unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //文件描述符，用于epoll注册&#125; &emsp;&emsp;这里uv__io_init函数是初始化loop-&gt;async_io_watcher这个结构体： 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //前面我们的eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_start将loop-&gt;async_io_watcher放入loop-&gt;watcher_queue。还有对于loop-&gt;nfds大小的处理。 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;第四行以后的操作是为了在epoll后，我们得到struct event结构体，我们从event-&gt;data.fd可以得到fd，那我们如何获取到对应的uv__io_t呢？ 就是通过loop-&gt;watchers这个数组。 uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCE： 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;这里调用一次ACCESS_ONCE，是为了告诉编译器，handle-&gt;pending可能被其他线程修改，所以别给我乱优化。&emsp;&emsp;cmpxchgi是原子操作compare_and_change。pending的有三个取值0，1，2。0代表闲置、1代表忙（比如uv_async_send调用途中）、2代表完成。loop-&gt;async_io_watcher调用uv__async_io时，会遍历loop-&gt;async_handles，通过pending来判断哪些回调该被执行。&emsp;&emsp;uv__async_send就是向loop-&gt;async_io_watcher.fd（eventfd）写（这里关系到eventfd的机制，不懂可以man eventfd）。 整体调用过程&emsp;&emsp;这里总体归纳一下async的过程。&emsp;&emsp;1.在loop_uv_init中初始化async_io_watcher，它的fd为eventfd，值为0，不可读。&emsp;&emsp;2.用户uv_async_init注册uv_async_t变量，被添加到loop-&gt;async_handles，设置回调函数。&emsp;&emsp;3.如果对uv_async_t变量调用uv_async_send，那么uv_async_t变量的pending变为2（done），并且向eventfd写，loop-&gt;async_io_watcher可读了。&emsp;&emsp;4.在uv_run的uv__io_poll中，每次都会把loop-&gt;watchers注册到epoll中，第四步这个过程在每次事件循环中都在执行。如果async_io_watcher的fd不可读，就没它事儿。如果可读，async_io_watcher的回调函数uv__async_io执行，它遍历loop-&gt;async_handles，将其中pending为2的uv_async_t变量移除队列，并执行其回调函数。 看源码后写的小DEMO： https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config 你会发现这是一个新文件，在其中添加以下文字： 123456Host github.comUser 你的用户名（例如97860xx@qq.com）Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 然后保存退出（代码如下）。 1:wq 接下来测试一下： 1ssh -T git@github.com 出现下面的画面：在图片倒数第五行的地方会询问是否建立连接，输入yes即可。","categories":[],"tags":[{"name":"遇见的问题","slug":"遇见的问题","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuv源码分析（3）init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"由来&emsp;&emsp;在我们第一次提交io操作时，会有uv_once被调用，来检测是否初始化过线程池，如果没有则立刻初始化线程池。所以说线程池并非一开始在uv_run的时候或者在loop中初始化的，而是在io操作开始前。我以uv_open为例子画一下UML图如下：在uv_open中先初始化req，然后准备提交work，提交前会调用uv_once检测是否初始化线程池，没有则初始化。 init_onceuv_once实现如下： 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; 在uv__work_submit中uv_once是这样被调用的： 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;这一部分可以参看TLPI 31.2部分，libuv多做了pthread_atfork的处理。&emsp;&emsp;pthread_atfork注册reset_once函数，在fork之后重置once，保证在libuv循环中如果你fork了一个进程，如果在那个新的进程中你也启动一个libuv，init_threads()能被调用。 init_threads🐤条件变量&emsp;&emsp;libuv初始化条件变量时，调用自己的uv_cond_init，这个函数只做了一件事情，就是将条件变量的时钟设置为相对时间，这一点是值得我们自己写代码时参考的，相对时间不受系统时间的影响。 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; 🥛互斥锁&emsp;&emsp;初始化互斥锁时，调用uv_mutex_init，在DEBUG时，libuv会将互斥锁设置为PTHREAD_MUTEX_ERRORCHECK，这样能自我检测是否为死锁，不过这会消耗性能，所以在运行时设置为默认值。 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. 🥡信号量&emsp;&emsp;初始化每个线程时，libuv用信号量来保证init_threads函数在初始化完所有线程后退出。 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); 在linux下并且glibc版本大于2.21时，uv_sem_init(&amp;sem, 0)和sem_init(&amp;sem, 0)是一样的，没有额外的处理。线程创建好后，在worker函数中会调用uv_sem_post释放信号量。 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; 🥚uv_thread_create&emsp;&emsp;uv_thread_create做的事情就是设置线程的stack大小，然后创建它。thread_stack_size函数获取栈大小，有一些是跨平台兼容性的处理。 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); 和if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; 上面两行的限制是来源于pthread_attr_setstacksize函数，一下是pthread_attr_setstacksize函数man手册的一部分。 ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif 😂无趣的是在linux Ubuntus我的环境下测试时，attr的默认stacksize和thread_stack_size函数设置到的是一样的值。下面是我的测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（2）uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"前言&emsp;&emsp;上一篇说了一下整体的事件循环，对于UV_RUN_DEFAULT模式来调用uv_run来说，uv__loop_alive就决定了是否退出，这一篇看一下uv__loop_alive的源码。 详情12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;可见loop的状态取决于三个方面：handles、reqs、closing_handles handles&emsp;&emsp;uv__has_active_handles就是检查loop-&gt;active_handles值是否大于0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handles列表如上。handle在调用时，会包含一个函数的调用，就是uv__handle_start。下图所示，是哪些函数调用了uv__handle_start。有一些handle不在其中，可能与其调用方式有关，我暂时无法解释 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_start函数在调用时，会调用uv__active_handle_add，uv__active_handle_add就是将loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;相应的在handle结束时有uv__active_handle_rm的调用，(h)-&gt;loop-&gt;active_handles减一。 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqs和handle的道理一样，是检测(loop)-&gt;active_reqs.count &gt; 0。active_reqs是个共用体，它的另一个用途暂时我还不知道。 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)等同于handle的uv__active_handle_add。uv__req_register在uv__req_init中调用，几乎（漏网的暂时没法解释 ）每个req在初始化时都调用了uv__req_init。 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;下图所示是那些函数调用了uv__req_init，由名称我们可以看出来它们是属于哪些req的。&emsp;&emsp;同理，还有uv__req_unregister。 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;要关闭的handle会以链表的形式挂在loop-&gt;closing_handles上。这个操作通过调用uv__make_close_pending来实现。 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; 如果closing_handles不为空，那么还需要进入事件循环，去调用关闭的handle的回调函数。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuv源码分析（1）事件循环分析","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"前言 &emsp;&emsp;libuv总是报出一些让人难以理解的错误😂，作为一个C的项目，不具有Java、JavaScript、php那样的人气，很难百度到一些问题的答案，甚至google也不行。为了用好libuv，也为了学习吧。我开始看libuv的源码，不知道自己能走多远。。。 事件循环 这是官方事件循环的示意图。链接-&gt;官方图片位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;整个事件循环就是在主线程的uv_run（）调用中执行的。我就跟着官方的介绍一步一步来看（官方介绍）。 第一步 The loop concept of ‘now’ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;第一步是更新时间。对应代码如下： 1uv__update_time(loop); &emsp;&emsp;总结来说就是调用这个函数，更新时间。uv__update_time实现我下一篇来介绍 第二步 If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and ref’d handles, active requests or closing handles it’s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;用uv__loop_alive函数获取loop状态。&emsp;&emsp;如果uv__loop_alive返回零或者loop-&gt;stop_flag == 1说明loop终止，直接跳过循环，到代码最下面（这里有一些性能的处理暂时不管 ），退出： 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0的一个来源是调用了uv_stop，这个函数在手册中看见。它的源代码也很清晰。 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;如果loop状态OK，那么就进入循环中。 第三步 Due timers are run. All active timers scheduled for a time before the loop’s concept of now get their callbacks called. &emsp;&emsp;对应代码这一部分： 1234567891011121314151617181920uv__run_timers(loop);其实现：void uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;将堆里面已经超时的拿出来运行。 第四步 Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. 对应： 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);其实现：static int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;将loop-&gt;pending_queue中的任务拿出来运行。 第五、六、九步 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;这三部为什么要一起说呢？因为它们的实质是一样的。在每次循环固定的位置调用。&emsp;&emsp;这三个函数定义在loop-watcher.c这个文件里面，它们是用宏定义定义的。只改了idle、prepare、check这三个名字的部分，其余部分函数都是一样的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) 第七步 Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;这部分是取决于uv_run的模式的特殊处理，暂时不细看。 第八步 The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;这一部分对于不同操作系统有所不同，linux是poll，mac是kqueue。 第十步 Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;调用各类的close回调函数。 第十一、十二步 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. It’s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if it’s still alive, otherwise it will also end. &emsp;&emsp;对于uv_run不同模式的一点特殊处理。 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; 小结&emsp;&emsp;宏观上梳理一下整个事件循环的过程。","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"redis基数树rax源码分析(2.5)","slug":"rax3","date":"2019-08-14T10:40:51.000Z","updated":"2019-11-25T19:51:03.317Z","comments":true,"path":"2019/08/14/rax3/","link":"","permalink":"http://yoursite.com/2019/08/14/rax3/","excerpt":"","text":"点点废话&emsp;&emsp;最近没有再将rax的源码往下看，rax对于一个新手来说还是体量过大，在尝试自己写写，在写的时候遇到了一些坑，也体会到了rax的一些写法的精妙之处，记录一下。 宏定义函数的注意点：&emsp;&emsp;我定义了这样一个宏定义函数： 12#define radixNthChild(h, n) \\ (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*)) 我这样调用这个函数： 1radixNthChild(new_cur, new_cur-&gt;size - 1) 这样一个调用大家觉得有问题吗？嗯，肯定是有问题的，不然我说啥?。 这里，按照我们一般的调用函数的思路，这样一个调用的运行过程是这样的： 计算出new_cur-&gt;size - 1 带入radixNthChild函数 实际上恰恰相反，宏定义的处理在预编译时（g++ -E），宏定义是将对于的定义替换掉，所以在预编译后的结果如下： 12# 363 &quot;radix_tree.c&quot; memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*)); 可以看到是 ： + new_cur-&gt;size - 1 * sizeof(void)而不是我所想的： + （new_cur-&gt;size - 1） * sizeof(void) 可以得出其过程其实是： 函数宏定义替换 运行时计算 结论： 在宏定义函数调用时注意括号的问题，不加括号可能会由于运算符优先级而 导致表达式意义与我们想的有出入? 地址运算注意点先给出这样一个结构体： 123struct test &#123; void* a, *b, *c;&#125;; int main(void) { cout &lt;&lt; sizeof(test) &lt;&lt; endl; test* p = new test; fprintf(stdout, &quot;%p:%p:%p:%p\\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1); return 0; }&emsp;&emsp;在这样一个测试代码中，大家觉得p + 1, (char)p + 1, (int)p+1这三个结果，相对于p的数值相差多少呢？&emsp;&emsp;运行结果是这样的。类型与地址的运算是有着密切关系的。 p + 1是一个默认情况， 这时1的意义是一个p的地址宽度 (char*)p + 1，p被解释为char类型指针，指向的地址被解释为char，于是1就是一个char的地址宽度。 总结： 在计算地址时，要注意运算符左边值的类型。你加上的1可能并不是一个字节的大小。 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redis基数树rax源码分析(2)","slug":"rax2","date":"2019-08-12T10:51:18.000Z","updated":"2019-11-25T19:49:43.833Z","comments":true,"path":"2019/08/12/rax2/","link":"","permalink":"http://yoursite.com/2019/08/12/rax2/","excerpt":"","text":"今天我想要说的是rax中的padding这个函数，我查了很多的资料，大家的博客都告诉我们内存对齐提高性能，却没有去分析为什么，是有根据让作者选择这样做？如果只是这样简单的放过，总感觉让人有一丝的遗憾。 &emsp;&emsp;先把主角拉出来： 12#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1)) &emsp;&emsp;首先要说的是raxPadding的作用是：让raxNewNode申请的内存nodesize是8的倍数。 123456789101112raxNode *raxNewNode(size_t children, int datafield) &#123; size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+ sizeof(raxNode*)*children; if (datafield) nodesize += sizeof(void*); raxNode *node = rax_malloc(nodesize); if (node == NULL) return NULL; node-&gt;iskey = 0; node-&gt;isnull = 0; node-&gt;iscompr = 0; node-&gt;size = children; return node;&#125; 第一个问题：对齐的优势&emsp;&emsp;这个并不是我想说的重点，这里是大家都谈到的，也就是经过内存对齐之后，CPU的内存访问速度大大提升。对于我来说，这个结论感觉还是太模糊，这是一个定性的结论，具体的底层细节对于我们初学者来说倒是没必要去深究。 第二个问题：为什么要这么去做？&emsp;&emsp;rax的作者这样的做法其实是参考结构体的做法。举个例子： 123456struct X&#123; char a; int c; double b;&#125;S2; 这样一个结构体，它的大小是多少？答案是16。在c语言的内部，做了这样的内存对齐处理： 这里转载了这篇文章中的很多资源，大家也可以去看看这篇文章，写的很不错。也有更多例子。 回到rax上来&emsp;&emsp; 在rax的raxNode这个结构体中，因为使用了柔性数组，所以在c语言本身是无法帮助我们实现像上面一样的内存对齐的（sizeof(raxNode) == 4,我们申请的内存大小决定了柔性数组的长度，详情请百度柔性数组） ，c语言对于结构体的优化没有包含柔性数组这个部分，所以我们必须自己来接管这一部分的内存对齐，保证程序的运行效率。 typedef struct raxNode { uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; /* Number of children, or compressed string len. */ unsigned char data[]; } raxNode; 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redis基数树rax源码分析(1)","slug":"rax1","date":"2019-08-11T16:11:44.000Z","updated":"2019-11-25T19:48:25.184Z","comments":true,"path":"2019/08/12/rax1/","link":"","permalink":"http://yoursite.com/2019/08/12/rax1/","excerpt":"","text":"&emsp;&emsp;最近想用libuv写个http服务器，看到了这个开源项目haywire，在看到第39次提交的时候，作者用基数树来存储不同路由的controller，不过在后续版本中改为了使用hash，不过想来不如正好学学基数树，作者使用的基数树是这个版本radix_tree，这个版本缺少注释，且和一般思路不一样的使用的是二叉树而非N叉树，为了理解方便，我选择了注释较多的rax 数据结构&emsp;&emsp;首先要提到的是rax的数据结构设计： 1234567typedef struct raxNode &#123; uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; / unsigned char data[];&#125; raxNode; 这里第一个要说到的点是：你觉得这样一个数据结构的大小是多少？24？ 16？ 还是8？&emsp;&emsp;第一个原因是位域，也就是结构体中的冒号： ，冒号在这里声明实际需要使用的位数，iskey，isnull，iscompr，size四个一共加起来32位，占4个字节。&emsp;&emsp;第二个原因是data[]占0个字节。unsigned char data[];这样一个结构在这里并不是理解成一个指针8个字节。而是一个柔性数组的概念，实现一个可变长度。data[1]占结构体1个字节，data[2]占结构体2个字节…….data[13]占13个字节。数组类型的内存是结构体中直接分配的，而不是像指针一样需要我们后来分配。如下图可见： 12345678910typedef struct raxNode &#123; unsigned char data[13];&#125; raxNode;int main(int argc, char *argv[])&#123; printf(&quot;%d\\n&quot;, sizeof(raxNode)); return 0;&#125; data[]&emsp;&emsp;接下来我们还是要谈data，在这里data的意义并不是一个简单的unsigned char数组，它存储的是键值key和radixNode指针两种变量。图来自：https://my.oschina.net/yunqi/blog/3039132data的实际使用方式在大多数时候是以内存地址的方式进行的。 123456#define raxNodeLastChildPtr(n) ((raxNode**) ( \\ ((char*)(n)) + \\ raxNodeCurrentLength(n) - \\ sizeof(raxNode*) - \\ (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \\)) &emsp;&emsp;这是访问最后一个节点的函数（也就是访问图中的A-ptr）。n是一个raxNode*指针，对这个指针指向的地址进行＋操作来得到最后一个节点的地址。 节点的表示图来自：https://my.oschina.net/yunqi/blog/3039132&emsp;&emsp;假设基数树中有“abcd”这个键值的节点。那么它的表示形式是像上图这样的。“abcd”这个节点的value-data存储在图片下半部分的节点处，并且下面一个节点iskey设为1.&emsp;&emsp;为什么不是直接只有图片的上半部分，由图片上半部分那个节点将iskey设置为1并且将值存储在其value·data中呢？像这样： [iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr] 先给出结论： 在rax中一个节点的存在（iskey == 1）是由data中对应的子节点来表示的。原因很简单：在这个例子里面，这是一个没有压缩的节点，这一层由a和A两个子节点，如果在当前层次表示，如何分辨你指定的是a还是A？所以用引出子节点来表示。 这是我边看rax边实现的一个小练习，欢迎大家指教：https://github.com/LurenAA/radix_tree ，好想要个star，求求了，兄弟萌:kissing_heart:","categories":[],"tags":[{"name":"rax源码阅读","slug":"rax源码阅读","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}]}