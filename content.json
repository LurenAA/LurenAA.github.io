{"meta":{"title":"lurenaaã®blog","subtitle":"","description":"","author":"ä¸¤å¤©å®‡å®™äºº","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨** å¯èƒ½æ˜¯è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«åˆ é™¤"},{"title":"å…³äº","date":"2019-11-21T19:51:46.860Z","updated":"2019-11-21T19:51:46.860Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T20:04:05.184Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T19:32:31.327Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":""},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"å½’æ¡£","date":"2019-11-21T20:12:46.614Z","updated":"2019-11-21T20:12:46.614Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"179.æœ€å¤§æ•°","slug":"leetcode179","date":"2020-01-11T12:18:40.000Z","updated":"2020-01-11T13:53:52.979Z","comments":true,"path":"2020/01/11/leetcode179/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode179/","excerpt":"","text":"ğŸ¥©å †æ’åº&emsp;&emsp;å †æ’åºï¼Œç„¶åå°†æ•°å­—æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œä½†æ˜¯ä¸¤ä¸ªæ•°å­—ä¹‹é—´çš„æ¯”è¾ƒå¹¶ä¸èƒ½ç›´æ¥ç”¨&gt;&lt;æ¥è¿›è¡Œã€‚æˆ‘çš„æ–¹æ³•æ˜¯å®šä¹‰compareå‡½æ•°ï¼Œè¿›è¡Œæ¯”è¾ƒã€‚compareæ¯”è¾ƒä¸¤ä¸ªæ•°çš„æ–¹æ³•æ˜¯ï¼šæ¯”å¦‚121ï¼Œ12ï¼Œé‚£ä¹ˆå°±æ¯”è¾ƒ121|12å’Œ12|121çš„å¤§å° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; a) &#123; if(!a.size()) return &quot;&quot;; string s; //å †æ’åº a.insert(a.begin(), -1); int n = a.size() - 1; for(int i = 2; i &lt;= n; ++i) &#123; swim(a, i, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; while(n &gt; 1) &#123; swap(a[1], a[n--]); sink(a, 1, n); &#125; // for(auto x : a) &#123; // cout &lt;&lt; x &lt;&lt; &quot; &quot;; // &#125; for(int i = 1; i &lt; a.size(); ++i) s += to_string(a[i]); int ct = 0; for(int i = 0; i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;; ++i) &#123; ++ct; &#125; if(ct == s.size()) return &quot;0&quot;; return s.substr(ct); &#125; void swim(vector&lt;int&gt;&amp; a, int k, int n) &#123; cout &lt;&lt; &quot;swim&quot; &lt;&lt; endl; int j; while(k &gt; 1) &#123; j = k /2; if(j &gt;= 1 &amp;&amp; compare(a[j],a[k]) != 1) break; swap(a[j], a[k]); k = j; &#125; &#125; void sink(vector&lt;int&gt;&amp; a, int k, int n) &#123; int j ; while(k &lt;= n / 2) &#123; j = 2 * k; if(j + 1 &lt;= n &amp;&amp; compare(a[j + 1], a[j]) == -1) ++j; if(compare(a[j], a[k]) != -1) break; swap(a[j], a[k]); k = j; &#125; &#125; int compare(int i, int j) &#123; if(i == j) return 0; int com = 0, ix = 0, jx = 0, ii = i, jj = j; while(ii / 10 &gt; 0) &#123; ix++; ii /= 10; &#125; while(jj / 10 &gt; 0) &#123; jx++; jj /= 10; &#125; long long ir ,jr; jr = j * pow(10, ix + 1) + i; ir = i * pow(10, jx + 1) + j; // cout &lt;&lt; &quot;i, j: &quot; &lt;&lt; ir &lt;&lt; &quot; &quot; &lt;&lt; jr &lt;&lt; endl; if(ir &gt; jr) return 1; else if(jr &gt; ir) return -1; else return 0; &#125;&#125;; Accepted222/222 cases passed (8 ms) Your runtime beats 91.43 % of cpp submissions Your memory usage beats 79.45 % of cpp submissions (9.1 MB) ğŸˆ¶æ”¹è¿›&emsp;&emsp;ç›¸æ¯”ä¸æˆ‘å°†ä¸¤ä¸ªæ•°æ‹¼åœ¨ä¸€èµ·æ¯”è¾ƒï¼Œæ›´åŠ å¥½çš„æ–¹æ³•æ˜¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒ 12345678910111213141516171819class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if (all_of(nums.begin(), nums.end(), [](int x) &#123; return x == 0; &#125;)) &#123; return string(&quot;0&quot;); &#125; vector&lt;string&gt; strNums(nums.size()); std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) &#123; return std::to_string(x); &#125;); std::sort(strNums.begin(), strNums.end(), [](const string&amp; x, const string&amp; y) &#123; /* xä¸ºåé¢å…ƒç´ ï¼Œyä¸ºå‰é¢å…ƒç´ ï¼Œreturn trueåˆ™å°†xç§»åŠ¨åˆ°å‰é¢ */ return x + y &gt; y + x; &#125;); return std::accumulate(strNums.begin(), strNums.end(), string()); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"147.å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº","slug":"leetcode147","date":"2020-01-11T07:55:04.000Z","updated":"2020-01-11T11:51:35.600Z","comments":true,"path":"2020/01/11/leetcode147/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode147/","excerpt":"","text":"ğŸ¥§æ¨¡ä»¿æ•°ç»„çš„å®ç°&emsp;&emsp;æ³¨æ„preæŒ‡é’ˆçš„è°ƒæ•´ï¼Œåœ¨å†…å¾ªç¯æ”¹å˜ä¸€ä¸ªèŠ‚ç‚¹ptrçš„ä½ç½®åï¼Œå¤–å±‚å¾ªç¯çš„ptrçš„ä¸‹ä¸€ä¸ªå¾ªç¯å°±ä¸æ˜¯ptr-&gt;nextäº†ï¼Œè€Œæ˜¯pre-&gt;next 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head-&gt;next, *nex, *pre = head,*ptr2, *pre2, npre = ListNode(INT_MIN); npre.next = head; for( ; ptr != nullptr; ) &#123; for(ptr2 = npre.next, pre2 = &amp;npre; ptr2 != ptr; ptr2 = ptr2-&gt;next, pre2 = pre2-&gt;next)&#123; if(ptr2-&gt;val &gt;= ptr-&gt;val) &#123; pre-&gt;next = ptr-&gt;next; ptr-&gt;next = ptr2; pre2-&gt;next = ptr; break; &#125; &#125; if(ptr2 == ptr) &#123; ptr = ptr-&gt;next; pre = pre-&gt;next; &#125; else &#123; ptr = pre-&gt;next; &#125; // for(auto x = &amp;npre; x != nullptr; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; endl; &#125; return npre.next; &#125;&#125;; Accepted 22/22 cases passed (100 ms) Your runtime beats 6.64 % of cpp submissions Your memory usage beats 13.73 % of cpp submissions (9.7 MB) ğŸ†æ”¹è¿›ç‰ˆ&emsp;&emsp;å¯¹äºæ’å…¥æ’åºæ¥è¯´ï¼Œæˆ‘ä»¬æ²¡æœ‰å¿…è¦è®°å½•é‚£ä¹ˆå¤šå‰ç½®èŠ‚ç‚¹çš„ä½ç½®ï¼Œæˆ‘ä»¬åªè¦ä¿è¯ptrå·¦è¾¹çš„åºåˆ—æœ‰åºå³å¯ 1234567891011121314151617181920212223class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* ptr = head, *nex,*ptr2, npre = ListNode(INT_MIN); while(ptr) &#123; nex = ptr-&gt;next; ptr2 = &amp;npre; while(ptr2-&gt;next &amp;&amp; ptr2-&gt;next-&gt;val &lt; ptr-&gt;val) ptr2 = ptr2-&gt;next; ptr-&gt;next = ptr2-&gt;next; ptr2-&gt;next = ptr; // for(auto x = &amp;npre; x != NULL; x = x-&gt;next) &#123; // cout &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;; // &#125; // cout &lt;&lt; &quot; cur: &quot; &lt;&lt; ptr-&gt;val &lt;&lt; endl; ptr = nex; &#125; return npre.next; &#125;&#125;; Accepted22/22 cases passed (48 ms)Your runtime beats 73.88 % of cpp submissions Your memory usage beats 15.9 % of cpp submissions (9.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"56.åˆå¹¶åŒºé—´","slug":"leetcode56","date":"2020-01-11T06:50:05.000Z","updated":"2020-01-11T07:20:33.360Z","comments":true,"path":"2020/01/11/leetcode56/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode56/","excerpt":"","text":"ğŸ¥›ä½¿ç”¨æ•°ç»„&emsp;&emsp;ä½¿ç”¨æ•°ç»„æ¥è¿›è¡Œæ“ä½œï¼Œç‰¹åˆ«[0,1][2,4]è¿™æ ·è¿åœ¨ä¸€èµ·ã€‚å´æ²¡æœ‰ç›¸äº¤çš„æƒ…å†µ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; char arr[3000] = &quot;&quot;; vector&lt;vector&lt;int&gt;&gt; res; for(auto x : intervals) &#123; memset(arr + x[0], &apos;1&apos; ,x[1] - x[0]); if(arr[x[1]] != &apos;1&apos;) arr[x[1]] = &apos;2&apos;; else arr[x[1]] = &apos;1&apos;; &#125; int count = 0, k; for(int i = 0; i &lt; 3000; ++i) &#123; if(arr[i] != &apos;\\0&apos;) &#123; count = 0; for(k = i; k &lt; 3000 &amp;&amp; arr[k] == &apos;1&apos;; ++k) &#123; arr[k] = &apos;\\0&apos;; ++count; &#125; arr[k] = &apos;\\0&apos;; res.push_back(vector&lt;int&gt;&#123;i, i + count&#125;); &#125; &#125; return res; &#125;&#125;; Accepted169/169 cases passed (20 ms)Your runtime beats 90.61 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (13.3 MB) ğŸš†æ’åºåæ¯”è¾ƒ&emsp;&emsp; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a ,const vector&lt;int&gt;&amp; b)&#123; return a[0] &lt; b[0]; &#125;); // for(auto x : intervals) &#123; // cout &lt;&lt; x[0] &lt;&lt; x[1] &lt;&lt; endl; // &#125; int i = 0, beg, endx, n = intervals.size(); while(i &lt; n) &#123; beg = intervals[i][0]; endx = intervals[i][1]; while(i &lt; n - 1&amp;&amp; intervals[i + 1][0] &lt;= endx) &#123; ++i; if(intervals[i][1] &gt; endx) endx = intervals[i][1]; &#125; // cout &lt;&lt; beg &lt;&lt; &quot; &quot; &lt;&lt; endx &lt;&lt; endl; res.push_back(vector&lt;int&gt;&#123;beg, endx&#125;); ++i; &#125; return res; &#125;&#125;; Accepted 169/169 cases passed (12 ms)Your runtime beats 99.88 % of cpp submissionsYour memory usage beats 5.08 % of cpp submissions (12.7 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"75.é¢œè‰²åˆ†ç±»","slug":"leetcode75","date":"2020-01-11T03:33:29.000Z","updated":"2020-01-11T08:13:03.417Z","comments":true,"path":"2020/01/11/leetcode75/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode75/","excerpt":"","text":"ğŸ¥§å…¸å‹çš„å †æ’åºé¢˜ç›®&emsp;&emsp; 12345678910111213141516171819202122232425class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; nums.insert(nums.begin(), 0); int n = nums.size() - 1; for(int i = n / 2; i &gt;= 1; --i) &#123; sink(nums, i, n); &#125; while(n &gt; 1) &#123; swap(nums[1], nums[n--]); sink(nums, 1, n); &#125; nums.erase(nums.begin()); &#125; void sink(vector&lt;int&gt;&amp; nums, int k,int n) &#123; int j; while(k &lt;= n / 2) &#123; j = k * 2; if(nums[j] &lt; nums[j + 1] &amp;&amp; j + 1 &lt;= n) ++j; if(nums[k] &gt;= nums[j]) break; swap(nums[k], nums[j]); k = j; &#125; &#125;&#125;; Accepted87/87 cases passed (0 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 5.17 % of cpp submissions (8.9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨","slug":"leetcode21","date":"2020-01-11T03:18:02.000Z","updated":"2020-01-11T03:29:41.869Z","comments":true,"path":"2020/01/11/leetcode21/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode21/","excerpt":"","text":"ğŸ¥›è¿­ä»£&emsp;&emsp;ç±»ä¼¼ä¸å½’å¹¶æ’åºçš„åˆå¹¶å‡½æ•°ï¼Œå®é™…è¿˜è¦æ›´ç®€å•ä¸€äº›ï¼Œæ²¡æœ‰é•¿åº¦çš„é™åˆ¶ 1234567891011121314151617181920212223class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode nd(0), *pre = &amp;nd; while(l1 || l2) &#123; if(!l1) &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; else if(!l2) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else if(l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; return nd.next; &#125;&#125;; Accepted208/208 cases passed (8 ms)Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 76.07 % of cpp submissions (9 MB) ğŸ¥›é€’å½’12345678910111213141516class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; else if(l2-&gt;val &lt; l1-&gt;val) &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; else &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; &#125;&#125;; Accepted208/208 cases passed (8 ms) Your runtime beats 93.28 % of cpp submissionsYour memory usage beats 75.58 % of cpp submissions (9 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"148. æ’åºé“¾è¡¨","slug":"leetcode148","date":"2020-01-10T16:51:18.000Z","updated":"2020-01-11T06:27:48.055Z","comments":true,"path":"2020/01/11/leetcode148/","link":"","permalink":"http://yoursite.com/2020/01/11/leetcode148/","excerpt":"","text":"ğŸ¥©è‡ªé¡¶å‘ä¸‹å½’å¹¶æ’åº&emsp;&emsp;åŸºç¡€ç‰ˆï¼Œæ ¹æ®ç®—æ³•4ä¸­çš„æ•°ç»„çš„å½’å¹¶ç®—æ³•æ”¹å¾— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head) return head; n = 1; ListNode* h = head; while(h-&gt;next != NULL) &#123; h = h-&gt;next; ++n; &#125; //cout &lt;&lt; &quot;count : &quot; &lt;&lt; n &lt;&lt; endl; aux = new int[n](); sortList(head, 0, n - 1); return head; &#125; void sortList(ListNode* head, int i, int j) &#123; if(i &gt;= j) return ; int mid = i + (j - i) / 2; sortList(head, i, mid); sortList(head, mid + 1, j); merge(head, i, mid, j); &#125; void merge(ListNode* head, int i,int mid, int j) &#123; //cout &lt;&lt; &quot;i,m.j : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; ListNode* inode = at(head, i),* inode2 = inode; //cout &lt;&lt; &quot;inode-&gt;val: &quot; &lt;&lt; inode2-&gt;val &lt;&lt; endl; int lo = i - i, hi = mid + 1 - i; for(int k = 0; k &lt;= j - i; ++k , inode = inode-&gt;next) aux[k + i] = inode-&gt;val; // for(int k = i; k &lt;= j; ++k) &#123; //cout &lt;&lt; aux[k] &lt;&lt; &quot; &quot;; // &#125; //cout &lt;&lt; endl; for(int k = 0; k &lt;= j - i; ++k) &#123; if(lo &gt; mid - i)&#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else if (hi &gt; j - i) &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; else if (aux[lo + i] &gt; aux[hi + i]) &#123; inode2-&gt;val = aux[hi + i]; ++hi; &#125; else &#123; inode2-&gt;val = aux[lo + i]; ++lo; &#125; //cout &lt;&lt; &quot;lo, hi : &quot; &lt;&lt; lo &lt;&lt; &quot; &quot; &lt;&lt; hi &lt;&lt; endl; inode2 = inode2-&gt;next; &#125; &#125; ListNode* at(ListNode* head, int n) &#123; while(n--) head = head-&gt;next; return head; &#125; int* aux; int n;&#125;; Accepted16/16 cases passed (1108 ms) Your runtime beats 5.09 % of cpp submissionsYour memory usage beats 62.56 % of cpp submissions (12.3 MB) ğŸ¥§è‡ªé¡¶å‘ä¸‹å½’å¹¶æ’åº2&emsp;&emsp;å­¦ä¹ è‡ªé“¾æ¥,ä»¥ä¸€ç§é“¾è¡¨å¾—æ–¹å¼æ¥åšï¼Œè€Œä¸æ˜¯ä»¥æ•°ç»„å¾—æ–¹å¼æ¥æ€è€ƒ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, * fast = head-&gt;next; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = nullptr; ListNode* left = sortList(head); ListNode* right = sortList(tmp); ListNode thead = ListNode(-1), *thd = &amp;thead; while(left || right) &#123; if(!left) &#123; thd-&gt;next = right; right = right-&gt;next; &#125; else if(!right) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else if (right-&gt;val &gt; left-&gt;val) &#123; thd-&gt;next = left; left = left-&gt;next; &#125; else &#123; thd-&gt;next = right; right = right-&gt;next; &#125; thd = thd-&gt;next; &#125; return thead.next; &#125; &#125;; Accepted 16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 72.66 % of cpp submissions (11.9 MB) ğŸ¥£è‡ªåº•å‘ä¸Šå½’å¹¶æ’åº&emsp;&emsp;å­¦ä¹ è‡ªé“¾æ¥ï¼Œè‡ªåº•å‘ä¸Šå¾—é“¾è¡¨ï¼Œæœ‰å‡ ä¸ªéš¾ç‚¹: å¦‚ä½•æ¯æ¬¡mergeåä¸åé¢å¾—é“¾è¡¨æ¥ä¸Š å¦‚ä½•ä¸²è”æˆä¸€ä¸ªé•¿å¾—é“¾è¡¨æœ€åè¿”å›1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* preNode = new ListNode(0), *pre = preNode; pre-&gt;next = head; int count = 0; while((pre = pre-&gt;next) &amp;&amp; ++count) ; // cout &lt;&lt; &quot;count : &quot; &lt;&lt; count &lt;&lt; endl; pre = preNode; for(int sz = 1; sz &lt; count; sz *=2) &#123; while(pre = sortList(pre, sz)) ; pre = preNode; &#125; return preNode-&gt;next; &#125; ListNode* sortList(ListNode* pre, int sz) &#123; ListNode* fl = pre-&gt;next, *ll = pre-&gt;next; for(int i = 0; i &lt; sz ; ++i) &#123; if(!ll) return nullptr; ll =ll-&gt;next; &#125; int lc = 0, fc = 0; while(fc &lt; sz) &#123; if(lc == sz || ll == nullptr || ll-&gt;val &gt; fl-&gt;val) &#123; ++fc; pre-&gt;next = fl; fl = fl-&gt;next; &#125; else &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; &#125; pre = pre-&gt;next; &#125; while(lc &lt; sz &amp;&amp; ll) &#123; ++lc; pre-&gt;next = ll; ll = ll-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next = ll; return pre; &#125;&#125;; Accepted16/16 cases passed (24 ms)Your runtime beats 100 % of cpp submissionsYour memory usage beats 93.48 % of cpp submissions (11.5 MB)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"å †æ’åº","slug":"alg4","date":"2020-01-10T14:59:59.000Z","updated":"2020-01-10T15:32:32.295Z","comments":true,"path":"2020/01/10/alg4/","link":"","permalink":"http://yoursite.com/2020/01/10/alg4/","excerpt":"","text":"ğŸ˜˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * å †æ’åº **/template&lt;typename T&gt;class HeapSort &#123; public: static void sort(vector&lt;T&gt;&amp;); private: static void sink(vector&lt;T&gt;&amp; a, int k, int N);&#125;;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123; int N = a.size() - 1; for(int i = N / 2; i &gt;= 1; --i) sink(a, i, N); while(N &gt; 1) &#123; swap(a[1], a[N--]); sink(a, 1, N); &#125;&#125;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123; int j; while(k &lt;= N / 2) &#123; j = 2 * k; if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j; if(a[k] &gt;= a[j]) break; swap(a[k], a[j]); k = j; &#125;&#125; ğŸ‘¿æ³¨æ„ è¦æ³¨æ„çˆ¶èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹æ—¶çš„æƒ…å†µï¼Œåœ¨sinkå‡½æ•°ä¸­ï¼ˆif(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;ï¼‰ä¸€å®šè¦æ³¨æ„j&lt;Nï¼Œä¸èƒ½è¶…å‡ºèŒƒå›´ æ„é€ æœ€å¤§å †æ—¶ï¼Œforå¾ªç¯ä»i = N / 2å¼€å§‹çš„åŸå› æ˜¯ï¼šsinkä¸­æœ‰é™åˆ¶æ¡ä»¶while(k &lt;= N / 2)ï¼Œæ‰€ä»¥N/2&lt;i&lt;Néƒ¨åˆ†æ— æ³•è¿›å…¥sinkçš„whileå¾ªç¯ï¼Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå¾’å¢N/2æ¬¡æ¯”è¾ƒ é€’å¢æ’åºä½¿ç”¨æœ€å¤§å †ï¼Œé€’å‡æ’åºä½¿ç”¨æœ€å°å † vectorçš„ç¬¬ä¸€ä¸ªå€¼ï¼ˆä¸‹æ ‡ä¸º0ï¼‰ä¸ä½¿ç”¨","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ç´¢å¼•ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg3","date":"2020-01-10T08:36:33.000Z","updated":"2020-01-10T14:28:54.460Z","comments":true,"path":"2020/01/10/alg3/","link":"","permalink":"http://yoursite.com/2020/01/10/alg3/","excerpt":"","text":"ğŸ¥›åˆ†æ12345678910111213141516public class IndexMaxPQ...&#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i//ä¸­é—´çœç•¥...public void insert(int i, Key key) &#123; ... n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n);&#125; &emsp;&emsp;æ ¹æ®ã€Šç®—æ³•4ã€‹ç»™å‡ºçš„ä»£ç ï¼Œåˆ†æè¿™ä¸¤æ®µä»£ç æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼š åœ¨å®šä¹‰å¤„å¯çŸ¥pqæ˜¯äºŒå‰å †çš„æ•°ç»„ ç”±qp[i] = n;pq[n] = i;å¯ä»¥çœ‹å‡ºæ¥ï¼Œqpè¿™ä¸ªæ•°ç»„çš„ç”¨å¤„å°±æ˜¯ä¸ºäº†è®°å½•**pqä¸­å€¼ä¸ºiçš„ä¸‹æ ‡æ˜¯å¤šå°‘**ï¼Œè¿™æ ·å½“æˆ‘ä»¬è¦æ”¹ä¸‹æ ‡ä¸ºiçš„å…ƒç´ çš„å€¼æ—¶ï¼Œæˆ‘ä»¬å°±ä¸ç”¨éå†pqæ¥è·å¾—ä½ç½®äº†ï¼Œ**ç”¨ç©ºé—´æ¥æ¢å–æ—¶é—´** å¹¶ä¸”è¿™ä¸ªç´¢å¼•iä»…ä»…ä¸ºäº†æ‰¾åˆ°å…ƒç´ å¯¹è±¡keyï¼Œå¹¶æ²¡å®é™…çš„æ„ä¹‰ã€‚næ‰æ˜¯å¯¹åº”äºŒå‰å †çš„ä½ç½®ã€‚ ğŸ˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ç´¢å¼•æœ€å°ä¼˜å…ˆé˜Ÿåˆ— **/ template&lt;typename T&gt;class IndexMinPQ &#123; public: IndexMinPQ(int max); void show() const; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125; void insert(int k, T item); void change(int k, T item); bool contain(int k) const &#123;return qp[k] != -1;&#125;; int delMin(); private: void sink(int i); void swim(int i); T* element; //å…ƒç´  int* pq; //äºŒå‰å † int *qp; //index int N; int _capacity;&#125;;template&lt;typename T&gt;IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) : element(new T[max + 1]), pq(new int[max + 1]) , qp(new int[max + 1]), N(0), _capacity(max) &#123; for(int i = 0; i &lt; max + 1; ++i) qp[i] = -1;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::sink(int n)&#123; while(n &lt; N) &#123; int m = n * 2; if(element[pq[m]] &gt; element[pq[m + 1]]) ++m; if(element[pq[m]] &lt; element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::swim(int n) &#123; while(n &gt; 1) &#123; int m = n / 2; if(element[pq[m]] &lt;= element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123; // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; if(capacity() == size())&#123; cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl; return ; &#125; pq[++N] = k; element[k] = item; qp[k] = N; swim(N); // show();&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::show() const&#123; cout &lt;&lt; &quot;pq: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;qp: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;element: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123; if(!contain(k)) &#123; cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl; return ; &#125; T old_one = element[k]; element[k] = item; if(item &gt; old_one) sink(qp[k]); else if(item &lt; old_one) swim(qp[k]);&#125;template&lt;typename T&gt;int IndexMinPQ&lt;T&gt;::delMin() &#123; int max = pq[1]; swap(pq[1], pq[N]); swap(qp[pq[1]], qp[pq[N]]); --N; show(); sink(1); show(); qp[max] = -1; element[max] = -1; pq[N + 1] = -1; return max;&#125;int main(int argc, char** argv) &#123; IndexMinPQ&lt;int&gt; pq(6); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6); for(size_t i = 0; i &lt; v.size(); ++i) &#123; pq.insert(i + 1, v[i]); &#125; pq.show(); pq.delMin(); pq.show(); return 0;&#125; ğŸ å‚è€ƒèµ„æ–™ï¼šé“¾æ¥","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg2","date":"2020-01-10T07:57:40.000Z","updated":"2020-01-10T08:36:50.374Z","comments":true,"path":"2020/01/10/alg2/","link":"","permalink":"http://yoursite.com/2020/01/10/alg2/","excerpt":"","text":"ğŸ ä¼˜å…ˆé˜Ÿåˆ—çš„å®ç°æœ‰ä¸‰ç§ï¼š æœ‰åºæ•°ç»„ æ— åºæ•°ç»„ å † ğŸ…æœ‰åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æœ‰åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class OrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit OrderArrayMaxPQ(int max); ~OrderArrayMaxPQ() &#123;delete [] arr;&#125; // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;// template&lt;typename T&gt;// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) // : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())// &#123;// copy(l.begin(), l.end(), arr);// &#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x; for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i) swap(arr[i], arr[i - 1]); &#125;template&lt;typename T&gt;pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; res = arr[N - 1]; arr[--N] = pair&lt;int , T&gt;(); return res;&#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; OrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¦æ— åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æ— åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class UnOrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit UnOrderArrayMaxPQ(int max); ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125; explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())&#123; copy(l.begin(), l.end(), arr);&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x;&#125;template&lt;typename T&gt;pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123; if(isEmpty()) return pair&lt;int, T&gt;(); int max_one = 0; for(int i = 0; i &lt; N; ++i) if(arr[max_one].first &lt; arr[i].first) &#123; max_one = i; &#125; swap(arr[max_one], arr[--N]); pair&lt;int,T&gt; res = arr[N]; arr[N] = pair&lt;int,T&gt;(); return res;&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; UnOrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥§å †1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * äºŒå‰å †å®ç° **/ template&lt;typename T&gt;class MaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; void swim(int i); void sink(int i); public: void show() const ; explicit MaxPQ(int max); ~MaxPQ() &#123;delete [] arr;&#125; void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;MaxPQ&lt;T&gt;::MaxPQ(int max) : arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)&#123; arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[++N] = x; swim(N);&#125;template&lt;typename T&gt;pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; swap(arr[N--], arr[1]); res = arr[N + 1]; arr[N + 1] = pair&lt;int ,T&gt;(); sink(1); return res;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 1; i &lt;= N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::swim(int i) &#123; while(i &gt; 1) &#123; if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]); i /= 2; &#125;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::sink(int i) &#123; int k; while(i &lt; N) &#123; k = 2 * i; if(arr[k].first &lt; arr[k + 1].first) ++k; if(arr[k].first &lt;= arr[i].first) break; swap(arr[k], arr[i]); i = k; &#125;&#125;int main(int argc, char** argv) &#123; MaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); // pq.show(); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¨æ—¶é—´å¤æ‚åº¦å¯¹æ¯” æœ‰åºæ•°ç»„ï¼š æ’å…¥ï¼šNï¼Œåˆ é™¤ï¼š1 æ— åºæ•°ç»„ï¼š æ’å…¥ï¼š1ï¼Œåˆ é™¤ï¼šN å †ï¼šæ’å…¥ã€åˆ é™¤ï¼šlgN ç†æƒ³æƒ…å†µï¼šéƒ½æ˜¯1","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¸ºç”šä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ","slug":"problems2","date":"2020-01-08T14:28:49.000Z","updated":"2020-01-08T15:06:10.423Z","comments":true,"path":"2020/01/08/problems2/","link":"","permalink":"http://yoursite.com/2020/01/08/problems2/","excerpt":"","text":"12unsigned int a = -1;printf(&quot;%d,%u,%x&quot;,a,a,a); -1,4294967295,ffffffffä»ç»“æœä¸Šæ¥è¯´,éªŒè¯äº†C++ä¸­ä½¿ç”¨çš„æ˜¯è¡¥ç ã€‚ ğŸ ç°åœ¨è¯´ä¸€è¯´ä¸ºä»€ä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ&emsp;&emsp;è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå‰æï¼Œä¸¤ä¸ªæ•°éƒ½æ˜¯intç±»å‹ï¼Œå› ä¸ºè¡¥ç çš„åŸå› ï¼Œå¦‚æœä¸¤ä¸ªæ•°çš„æ­£è´Ÿä¸åŒï¼Œé‚£ä¹ˆå®ƒä»¬çš„ç¬¬ä¸€ä½å°±ä¸åŒï¼Œå› ä¸ºintçš„ç¬¬ä¸€ä½æ˜¯æ­£è´Ÿçš„æ ‡å¿—ä½ã€‚é€šè¿‡å¼‚æˆ–ï¼Œé‚£ä¹ˆæ­£æ•°çš„ç¬¬ä¸€ä½ä¸º0ï¼Œè´Ÿæ•°çš„ç¬¬ä¸€ä½ä¸º1ï¼Œå¼‚æˆ–åç¬¬ä¸€ä½å°±ä¸º1ï¼Œæ‰€ä»¥å¯ä»¥å¾—åˆ°è®¡ç®—å‡ºçš„å€¼ä¸ºè´Ÿå€¼ã€‚ç›¸åå¦‚æœä¸¤è€…ç¬¦å·ç›¸åŒï¼Œé‚£ä¹ˆé€šè¿‡å¼‚æˆ–åï¼Œç¬¬ä¸€ä½å°±ä¸º0ï¼Œæ‰€ä»¥ä¸ºæ­£æ•°ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"äºŒåˆ†æŸ¥æ‰¾","slug":"alg1","date":"2020-01-07T14:24:36.000Z","updated":"2020-01-08T13:56:04.220Z","comments":true,"path":"2020/01/07/alg1/","link":"","permalink":"http://yoursite.com/2020/01/07/alg1/","excerpt":"","text":"æ—¶é—´å¤æ‚åº¦logN äºŒåˆ†æŸ¥æ‰¾çš„å®ç°å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯é€’å½’å¼çš„ã€å¦ä¸€ç§æ˜¯å¾ªç¯å¼çš„ğŸ˜œé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123; // if(lo &gt; ho) return -1; // int mid = (lo + ho) / 2; // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key); // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); // else return mid; if(lo &gt;= ho) return -1; int mid = (lo + ho) / 2; if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key); else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); else return mid;&#125; &emsp;&emsp;åŒºé—´çš„å¼€é—­è‡ªç”±é€‰å–ï¼Œä¸»è¦æ˜¯è¦ç»Ÿä¸€ï¼Œå¦‚æœè¦æ±‚ä¼ å…¥å·¦é—­å³å¼€åŒºé—´ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°å†…éƒ¨çš„å¤„ç†ä¹Ÿè¦ä¿æŒå·¦é—­å³å¼€ã€‚ä¸€èˆ¬çš„é€‰æ‹©åº”è¯¥æ—¶å·¦å³éƒ½æ˜¯é—­åŒºé—´ï¼Œè€Œåœ¨ç‰¹æ®Šæƒ…å†µæ—¶ï¼ˆæ•°ç»„ä¸­æœ‰å¤šä¸ªç›¸åŒçš„ç›®æ ‡æ—¶ï¼‰ï¼Œè¿™æ—¶é€‰æ‹©å·¦é—­å³å¼€ã€‚ğŸ¥›å‚è€ƒï¼šwikié“¾æ¥&emsp;&emsp;ä¸ºäº†é¿å…ho + lo å¤§äºINT_MAXæœ€å¥½æ”¹ç”¨lo + (ho - lo) / 2 ğŸˆ¶éé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123; int lo = 0, ho = a.size(), mid; while(lo &lt; ho) &#123; mid = (lo + ho) / 2; if(a[mid] &gt; key) ho = mid; else if(a[mid] &lt; key) lo = mid + 1; else return mid; &#125; return -1;&#125; é€’å½’è¦æ»¡è¶³ä¸‰ä¸ªåŸåˆ™ï¼š é€’å½’æ€»æœ‰ä¸€ä¸ªæœ€ç®€å•çš„æƒ…å†µâ€”æ–¹æ³•çš„ç¬¬ä¸€å¥æ€»æ˜¯ä¸€ä¸ªåŒ…å«returnçš„æ¡ä»¶è¯­å¥ã€‚ é€’å½’è°ƒç”¨æ€»è¦å°è¯•å–è§£å†³ä¸€ä¸ªè§„æ¨¡æ›´å°çš„å­é—®é¢˜ã€‚ é€’å½’è°ƒç”¨çš„çˆ¶é—®é¢˜å’Œå­é—®é¢˜ä¹‹é—´ä¸åº”è¯¥æœ‰äº¤é›†ã€‚ ğŸ¥˜æ¨èç›¸å…³èµ„æ–™ï¼šè®²è§£ ğŸ‘ç»ƒä¹ é¢˜ç›®1ï¼š4. å¯»æ‰¾ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //é¦–å…ˆè¦åˆ¤å®šæ‹¿ä¸ªåºåˆ—æ›´åŠ é•¿ if(nums1.size() &gt; nums2.size()) swap(nums1, nums2); //å·¦é—­å³å¼€ int imin = 0, imax = nums1.size(), j, i, m = nums1.size(), n = nums2.size(), halflen = (m + n + 1) / 2; while(imin &lt;= imax) &#123; i = (imax + imin ) / 2; j = halflen - i; // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; imin = i + 1; &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; imax = i; &#125; else &#123; // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; int leftMax, rightMin; if(i == 0 ) leftMax = nums2[j - 1]; else if(j == 0) leftMax = nums1[i - 1]; else leftMax = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2) return leftMax; if(i == m) rightMin = nums2[j ]; else if (j == n) rightMin = nums1[ i ]; else rightMin = min(nums1[i], nums2[j]) ; // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl; return static_cast&lt;double&gt;(leftMax + rightMin) / 2; &#125; &#125; return -1; &#125;&#125;; ğŸ‘ç»ƒä¹ é¢˜ç›®2ï¼š35. æœç´¢æ’å…¥ä½ç½®12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, ho = nums.size() - 1, mid; while(lo &lt; ho) &#123; mid = (lo + ho + 1) / 2; if(nums[mid] &gt; target) &#123; ho = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; if(nums[lo] &lt; target) return lo + 1; else return lo; &#125;&#125;;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"libuvæºç åˆ†æï¼ˆ6ï¼‰uv_queue_work","slug":"libuv6","date":"2019-11-26T12:06:58.000Z","updated":"2019-11-26T12:56:52.025Z","comments":true,"path":"2019/11/26/libuv6/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv6/","excerpt":"","text":"ğŸ¤é—®é¢˜æ¥ç”±&emsp;&emsp;åœ¨ä½¿ç”¨libuvçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éš¾å…é‡è§çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œæœ‰ä¸€äº›åº“æ²¡æœ‰å¼‚æ­¥ã€åªèƒ½åŒæ­¥è¿è¡Œï¼Œè¿™ç§æƒ…å†µè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿæ¯”å¦‚mysql-connector-cppã€‚ &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysql-connector-cppè¿™ç§ä¼šé˜»å¡çš„æ“ä½œæ˜¯ä¸ç¬¦åˆLibuvçš„reactoræ¨¡å¼çš„ã€‚ 123456void handle_json_lab(std::shared_ptr&lt;smpHttp::HttpRequest&gt; req,std::shared_ptr&lt;smpHttp::HttpResponse&gt; res) &#123; try&#123; Session mq = cli.getSession(); auto sqlres = mq.sql(\"Select content FROM labimformation where type = 'labIntroduction'\").execute(); ... &emsp;&emsp;ä¸Šé¢è¿™æ ·ä¾¿æ˜¯é”™è¯¯çš„æ¡ˆä¾‹ã€‚æˆ‘åœ¨å†™è¿™ä¸ªé¡¹ç›®æ—¶ï¼Œä¹‹å‰å°±é‡‡ç”¨äº†è¿™æ ·çš„é”™è¯¯åšæ³•ã€‚&emsp;&emsp;æˆ‘çš„è¿™ä¸ªé¡¹ç›®æ˜¯ä¸ªhttpåå°ï¼Œæˆ‘åœ¨æ¥å—åˆ°POSTè¯·æ±‚ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysqlæ“ä½œï¼Œè¿™æ—¶æ•´ä¸ªä¸»çº¿ç¨‹å°±é˜»å¡ä½äº†1ï¼Œè€Œè¿™å°±æ„å‘³ç€æˆ‘çš„httpåå°ä¸å†èƒ½æ¥å—ä»»ä½•è¯·æ±‚ï¼Œåªèƒ½ç­‰å¾…mysqlæ“ä½œå®Œæˆåï¼Œå›è°ƒå‡½æ•°è¿”å›ã€‚è€Œè¿™ä¸ªmysqlçš„æ“ä½œè€—æ—¶ä¸€èˆ¬åœ¨3sä»¥ä¸Šï¼Œè¿™å¯¹æˆ‘è¿™ä¸ªHttpåå°æ¥è¯´æ˜¯æ¯ç­æ€§çš„æ‰“å‡»ã€‚ã€‚ã€‚ã€‚ 1ï¼šç”¨æˆ·çš„å›è°ƒå‡½æ•°æ˜¯åœ¨work->doneå‡½æ•°çš„æœ€åæ‰§è¡Œçš„ï¼Œè€Œwork->doneæ˜¯åœ¨ä¸»çº¿ç¨‹uv_runä¸­çš„is_pollä¸­å”¤é†’loop->wq_asyncåæ‰§è¡Œçš„,åœ¨work->doneå‡½æ•°ä¸­é˜»å¡æ„å‘³ç€åœ¨ä¸»çº¿ç¨‹é˜»å¡ä½äº†ï¼Œuv_runä¸­çš„äº‹ä»¶å¾ªç¯å¡ä½ï¼Œä¸å†èƒ½æ¥å—requestï¼ˆè¿™éƒ¨åˆ†ä¸æ¸…æ¥šå¯ä»¥å»çœ‹æˆ‘çš„libuvæºç åˆ†ææ–‡ç« ï¼‰ ğŸŒ†è§£å†³åŠæ³•&emsp;&emsp;åœ¨æ‰‹å†ŒThread pool work schedulingä¸­ä¸ºæˆ‘ä»¬è¿™æ ·çš„éœ€æ±‚æä¾›äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼šuv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)ã€‚ &emsp;&emsp;è¿™ä¸ªå‡½æ•°å°±æ˜¯ä¸Šé¢æˆ‘ä»¬é—®é¢˜çš„è§£å†³åŠæ³•ã€‚ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯uv_async_tä¸å¯ä»¥æ›¿ä»£è¿™ä¸ªã€‚è™½ç„¶éƒ½æ˜¯æ‰§è¡Œç”¨æˆ·çš„å‡½æ•°ã€‚asyncæ˜¯è®©ç”¨æˆ·å‡½æ•°ç›´æ¥è¢«ä¸»çº¿ç¨‹åœ¨uv_runä¸­è¿è¡Œï¼Œè€Œuv_queue_workæ˜¯å°†work_cbæäº¤ç»™å­çº¿ç¨‹æ‰§è¡Œï¼Œå®Œæˆåé€šçŸ¥ä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹åœ¨uv_runä¸­æ‰§è¡Œafter_work_cbã€‚ &emsp;&emsp;æ€»ç»“ä¸‹æ¥å°±æ˜¯ï¼šuv_async_tç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼Œuv_queue_workæ‰§è¡Œè¦é˜»å¡çš„ä»»åŠ¡ï¼ˆè€ƒè™‘åˆ°çº¿ç¨‹åˆ‡æ¢çš„æ¶ˆè€—ä¸€èˆ¬ä¸ç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼‰ ğŸ‰çœ‹çœ‹æºç &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥ç»“åˆè¿™æˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*æ¥çœ‹ã€‚å¯ä»¥ä½œä¸ºä½è¯ï¼Œlibuvä¸­å¯¹ç€è¿™ç±»æ²¡æœ‰è‡ªå¸¦å¼‚æ­¥ç‰ˆæœ¬çš„é˜»å¡æ“ä½œçš„å¤„ç†æ˜¯ä¸€æ ·çš„ï¼šè®©å­çº¿ç¨‹å»æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯ï¼Œå®Œæˆåå­çº¿ç¨‹é€šçŸ¥ä¸»çº¿ç¨‹ã€‚uv_queue_workæºç ï¼š 123456789101112131415161718int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) &#123; if (work_cb == NULL) return UV_EINVAL; uv__req_init(loop, req, UV_WORK); req-&gt;loop = loop; req-&gt;work_cb = work_cb; req-&gt;after_work_cb = after_work_cb; uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, uv__queue_work, uv__queue_done); return 0;&#125; å†ç»“åˆæˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*ä¸­uv_fs_*å‡½æ•°çš„æºç ï¼Œè¿™äº›æ“ä½œå¯ä»¥æ€»ç»“æˆä»¥ä¸‹ä»£ç ï¼š 12345678UV_REQ_INIT(req, typ); //åˆå§‹åŒ–åŸºç±»uv_req_t uv__req_register(loop, req); //æ·»åŠ loopä¸­requestçš„è®¡æ•°ï¼Œé¿å…uv_runä¸­uv__loop_aliveè¿”å›0ï¼Œä½¿å¾—ä¸»çº¿ç¨‹uv_runé€€å‡º...//è¿™é‡Œæ˜¯é’ˆå¯¹ä¸åŒç±»å‹çš„æ“ä½œç‰¹æœ‰çš„åˆå§‹åŒ–éƒ¨åˆ†uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, //æ“ä½œç±»å‹ uv__queue_work, //è¦é˜»å¡çš„æ“ä½œï¼Œåœ¨fsä¸­æ˜¯uv__fs_work uv__queue_done); //å®Œæˆåçš„å›è°ƒï¼Œåœ¨fsä¸­æ˜¯uv__fs_done","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*","slug":"libuv5","date":"2019-11-25T18:57:15.000Z","updated":"2019-11-25T19:41:02.563Z","comments":true,"path":"2019/11/26/libuv5/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv5/","excerpt":"","text":"uv_fs_*&emsp;&emsp;uv_fs_*è¿™ä¸€ç³»åˆ—çš„å‡½æ•°åŸºæœ¬æ˜¯ä¸€è‡´çš„ï¼Œå®ƒä»¬çš„é€»è¾‘å¤§æ¦‚æ˜¯å¦‚ä¸‹ï¼š 123456//xä»£è¡¨ä¸€ç§æ“ä½œopenã€writeç­‰int uv_fs_x(...uv_fs_t* req...) &#123; INIT(x); //uv_fs_tå’Œå…¶åŸºç±»uv_req_tçš„åŸºæœ¬åˆå§‹åŒ– ... //è¿™é‡Œæ˜¯æ¯ä¸ªæ“ä½œå„è‡ªä¸åŒå¯¹äºreqçš„åˆå§‹åŒ– POST; //æäº¤è¿™ä¸ªä»»åŠ¡&#125; INIT&emsp;&emsp;INITè¿™ä¸ªå®å®šä¹‰å‡½æ•°æ²¡æœ‰ç‰¹åˆ«çš„åœ°æ–¹ï¼Œå°±æ˜¯æŠŠreqåˆå§‹åŒ–ï¼Œè¯¥ç½®0çš„ç½®0ã€‚ POST&emsp;&emsp;å…¶å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617#define POST do &#123; //dowhileåŒ…è£¹ä½œç”¨åŸŸ if (cb != NULL) &#123; uv__req_register(loop, req); uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_FAST_IO, uv__fs_work, uv__fs_done); return 0; &#125; else &#123; uv__fs_work(&amp;req-&gt;work_req); return req-&gt;result; &#125; &#125; while (0) &emsp;&emsp;è¿™é‡Œé€šè¿‡æœ‰æ— å›è°ƒå‡½æ•°æ¥å†³å®šè°ƒç”¨åŒæ­¥ç‰ˆæœ¬è¿˜æ˜¯å¼‚æ­¥ç‰ˆæœ¬ã€‚ http://docs.libuv.org/en/v1.x/fs.htmllibuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously. &emsp;&emsp;uv__fs_workè¿™ä¸ªå‡½æ•°å°±æ˜¯æ–‡ä»¶æ“ä½œçš„å°è£…ï¼Œæ‰€æœ‰çš„æ–‡ä»¶æ“ä½œéƒ½é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥å®Œæˆï¼Œå³ä½¿æ˜¯å¼‚æ­¥ï¼Œæœ€ç»ˆä¹Ÿè¦åœ¨åˆ«çš„çº¿ç¨‹ä¸­åŒæ­¥æ‰§è¡Œè¿™ä¸ªå‡½æ•°ã€‚ &emsp;&emsp;uv__fs_doneè¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨ç”¨æˆ·ç»™çš„å›è°ƒå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨uv_runä¸­çš„is_pollå‡½æ•°ä¸­å¾—åˆ°æ‰§è¡Œã€‚ &emsp;&emsp;uv__work_submitå‡½æ•°çš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678910void uv__work_submit(uv_loop_t* loop,struct uv__work* w,enum uv__work_kind kind, void (*work)(struct uv__work* w),void (*done)(struct uv__work* w, int status)) &#123; uv_once(&amp;once, init_once); w-&gt;loop = loop; w-&gt;work = work; w-&gt;done = done; post(&amp;w-&gt;wq, kind);&#125; &emsp;&emsp;uv_once(&amp;once, init_once);æ˜¯åˆå§‹åŒ–å¤šä¸ªçº¿ç¨‹ï¼Œæˆ‘åœ¨æˆ‘çš„ç¬¬ä¸‰ç¯‡æ–‡ç« ä¸­æœ‰ä»‹ç»ã€‚ä¸è¿‡å½“æ—¶å¯¹äºå­çº¿ç¨‹è¿è¡Œçš„workerå‡½æ•°æ²¡æœ‰æåŠï¼Œworkå‡½æ•°å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š 123456789101112131415161718192021222324252627282930static void worker(void* arg) &#123; ... uv_mutex_lock(&amp;mutex); for (;;) &#123; while (QUEUE_EMPTY(&amp;wq)...) &#123; idle_threads += 1; uv_cond_wait(&amp;cond, &amp;mutex); idle_threads -= 1; &#125; q = QUEUE_HEAD(&amp;wq); ... QUEUE_REMOVE(q); QUEUE_INIT(q); ... w = QUEUE_DATA(q, struct uv__work, wq); w-&gt;work(w); uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex); w-&gt;work = NULL; QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); uv_async_send(&amp;w-&gt;loop-&gt;wq_async); uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); uv_mutex_lock(&amp;mutex); ... &#125;&#125; &emsp;&emsp;æˆ‘å»æ‰äº†å¯¹äºslow_ioçš„å¤„ç†ï¼Œå¤§è‡´æ˜¯è¿™æ ·ä¸€ä¸ªè¿‡ç¨‹ã€‚ &emsp;&emsp;ä¸€å¼€å§‹çº¿ç¨‹ä¼šå¡åœ¨uv_cond_waitè¿™é‡Œï¼Œç›´åˆ°è¢«uv_cond_signalå”¤é†’ï¼Œå¦‚æœå”¤é†’æ—¶wqé˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡ï¼Œå®ƒå°±ä¼šæ‰§è¡Œä»»åŠ¡ï¼Œw-&gt;work(w)ä¹Ÿå°±æ˜¯è°ƒç”¨uv__fs_workã€‚ç„¶åæŠŠwæ”¾å…¥loop-&gt;wqï¼ˆä¸ºäº†uv__fs_doneçš„æ‰§è¡Œï¼‰ã€‚ &emsp;&emsp;uv_async_sendè°ƒç”¨è®©loop-&gt;wq_asyncå¯è¯»ï¼Œä¸»çº¿ç¨‹å°±ä»uv_runä¸­çš„uv__io_pollçš„epoll_pwaitä¸­é†’æ¥ï¼Œwq_asyncçš„å›è°ƒå‡½æ•°ä¼šéå†loop-&gt;wqæ‰§è¡Œw-&gt;doneã€‚ï¼ˆæˆ‘çš„ç¬¬å››ç¯‡æ–‡ç« æœ‰è®²è¿™ä¸€éƒ¨åˆ†çš„è¯¦ç»†å†…å®¹ï¼‰ è°æ¥è§¦å‘uv_cond_signalå”¤é†’å­çº¿ç¨‹å‘¢ï¼ŸğŸ¥£uv__work_submitä¸­çš„postå‡½æ•°ï¼š 123456uv_mutex_lock(&amp;mutex);...QUEUE_INSERT_TAIL(&amp;wq, q);if (idle_threads &gt; 0) uv_cond_signal(&amp;cond);uv_mutex_unlock(&amp;mutex); &emsp;&emsp;æˆ‘å†æ¬¡çœç•¥äº†slow_ioçš„éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒä»¬åªæ˜¯ç‰¹æ®Šå¤„ç†ã€‚ &emsp;&emsp;è¯¥å‡½æ•°æœ‰ç©ºé—²çš„çº¿ç¨‹å°±å”¤é†’ï¼Œä¸ç„¶å°±é˜»å¡è¯¥çº¿ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ4ï¼‰async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-25T19:24:48.508Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuvä¸­asyncçš„å¼€ç«¯åœ¨uv_loop_initå‡½æ•°ä¸­ï¼š 12345678//å‰é¢çœç•¥err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//åé¢çœç•¥ &emsp;&emsp;loop-&gt;wq_asyncæ˜¯ä¸ªuv_async_tç±»å‹ï¼Œå®ƒç”¨äºçº¿ç¨‹workå‡½æ•°è°ƒç”¨æœ€åå¤„ç†loop-&gt;wqä¸­çš„å›è°ƒï¼Œæš‚æ—¶ä¸ç”¨ç®¡,æˆ‘åœ¨æˆ‘çš„ç¬¬äº”ç¯‡æ–‡ç« ä¼šè®²åˆ°å®ƒçš„ç”¨é€”ã€‚&emsp;&emsp;æˆ‘ä»¬æ¥çœ‹uv_async_initå†…éƒ¨ï¼š 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;ç¬¬äº”è¡Œä»¥åçš„æ“ä½œå°±æ˜¯åˆå§‹åŒ–åŸºç±»uv_handle_tä»¥åŠå­ç±»uv_async_tï¼Œç„¶åå°†è¿™ä¸ªhandleæ”¾å…¥loop-&gt;queue(æ”¾uv_handle_tçš„é˜Ÿåˆ—)ä»¥åŠæ”¾å…¥loop-&gt;async_handlesï¼ˆæ”¾uv_async_tçš„é˜Ÿåˆ—ï¼‰ä¸­ï¼Œç„¶åuv__handle_startä¸­å°†loop-&gt;active_handlesåŠ ä¸€ã€‚&emsp;&emsp;æ€»è€Œè¨€ä¹‹ï¼Œç¬¬äº”è¡Œä»¥åçš„å†…å®¹å°±æ˜¯åˆå§‹åŒ–uv_async_tï¼Œå¯ä»¥ç†è§£æˆuv_async_tçš„æ„é€ å‡½æ•°ã€‚&emsp;&emsp;uv__async_startåˆ™ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯åˆå§‹åŒ–å‡½æ•°ï¼Œå®ƒåªä¼šè°ƒç”¨ä¸€æ¬¡ï¼ˆä¸€èˆ¬æƒ…å†µæ˜¯åœ¨uv_loop_initä¸­è°ƒç”¨ï¼‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹å®ƒçš„å®ç°ï¼š 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //ä¸­é—´çœç•¥ uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;çœ‹ç¬¬ä¸‰è¡Œloop-&gt;async_io_watcher.fdï¼Œå½“ä½ è°ƒç”¨è¿‡ä¸€æ¬¡è¿™ä¸ªå‡½æ•°åï¼Œloop-&gt;async_io_watcher.fdä¸ä¼šç­‰äº-1ï¼Œä»¥åä½ åˆå§‹åŒ–uv_async_tç±»å‹å˜é‡ï¼Œè°ƒç”¨uv_async_initå‡½æ•°æ—¶ï¼Œuv__async_startéƒ½æ˜¯ç›´æ¥è¿”å›çš„ã€‚&emsp;&emsp;æˆ‘çœç•¥æ‰äº†ä¸­é—´å¦‚æœeventfdæ²¡æœ‰åœ¨å½“å‰ç³»ç»Ÿä¸‹å®ç°æ—¶çš„å…¼å®¹æ€§å¤„ç†ã€‚æ€»çš„æ¥è¯´ï¼Œå°±æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherã€‚uv__io_tæ˜¯ä¸ºepollè®¾è®¡çš„ç»“æ„ä½“ã€‚è¿™é‡Œä½ è‚¯å®šæ„Ÿè§‰å¾ˆæ‡µé€¼ï¼Œè¯·åšæŒä¸€ä¸‹ï¼Œæœ€åæˆ‘ä¼šæ¢³ç†ä¸€ä¸‹æ€»ä½“çš„æ•´ä¸ªè¿‡ç¨‹ã€‚&emsp;&emsp;uv__io_tçš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678uv__io_t&#123; uv__io_cb cb; //å›è°ƒå‡½æ•° void* watcher_queue[2]; //æ”¾å…¥loop-&gt;watcher_queue void* pending_queue[2]; //åŒç† unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºepollæ³¨å†Œ&#125; &emsp;&emsp;è¿™é‡Œuv__io_initå‡½æ•°æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherè¿™ä¸ªç»“æ„ä½“ï¼š 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //å‰é¢æˆ‘ä»¬çš„eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_startå°†loop-&gt;async_io_watcheræ”¾å…¥loop-&gt;watcher_queueã€‚è¿˜æœ‰å¯¹äºloop-&gt;nfdså¤§å°çš„å¤„ç†ã€‚ 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;ç¬¬å››è¡Œä»¥åçš„æ“ä½œæ˜¯ä¸ºäº†åœ¨epollåï¼Œæˆ‘ä»¬å¾—åˆ°struct eventç»“æ„ä½“ï¼Œæˆ‘ä»¬ä»event-&gt;data.fdå¯ä»¥å¾—åˆ°fdï¼Œé‚£æˆ‘ä»¬å¦‚ä½•è·å–åˆ°å¯¹åº”çš„uv__io_tå‘¢ï¼Ÿ å°±æ˜¯é€šè¿‡loop-&gt;watchersè¿™ä¸ªæ•°ç»„ã€‚ uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCEï¼š 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;è¿™é‡Œè°ƒç”¨ä¸€æ¬¡ACCESS_ONCEï¼Œæ˜¯ä¸ºäº†å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œhandle-&gt;pendingå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼Œæ‰€ä»¥åˆ«ç»™æˆ‘ä¹±ä¼˜åŒ–ã€‚&emsp;&emsp;cmpxchgiæ˜¯åŸå­æ“ä½œcompare_and_changeã€‚pendingçš„æœ‰ä¸‰ä¸ªå–å€¼0ï¼Œ1ï¼Œ2ã€‚0ä»£è¡¨é—²ç½®ã€1ä»£è¡¨å¿™ï¼ˆæ¯”å¦‚uv_async_sendè°ƒç”¨é€”ä¸­ï¼‰ã€2ä»£è¡¨å®Œæˆã€‚loop-&gt;async_io_watcherè°ƒç”¨uv__async_ioæ—¶ï¼Œä¼šéå†loop-&gt;async_handlesï¼Œé€šè¿‡pendingæ¥åˆ¤æ–­å“ªäº›å›è°ƒè¯¥è¢«æ‰§è¡Œã€‚&emsp;&emsp;uv__async_sendå°±æ˜¯å‘loop-&gt;async_io_watcher.fdï¼ˆeventfdï¼‰å†™ï¼ˆè¿™é‡Œå…³ç³»åˆ°eventfdçš„æœºåˆ¶ï¼Œä¸æ‡‚å¯ä»¥man eventfdï¼‰ã€‚ æ•´ä½“è°ƒç”¨è¿‡ç¨‹&emsp;&emsp;è¿™é‡Œæ€»ä½“å½’çº³ä¸€ä¸‹asyncçš„è¿‡ç¨‹ã€‚&emsp;&emsp;1.åœ¨loop_uv_initä¸­åˆå§‹åŒ–async_io_watcherï¼Œå®ƒçš„fdä¸ºeventfdï¼Œå€¼ä¸º0ï¼Œä¸å¯è¯»ã€‚&emsp;&emsp;2.ç”¨æˆ·uv_async_initæ³¨å†Œuv_async_tå˜é‡ï¼Œè¢«æ·»åŠ åˆ°loop-&gt;async_handlesï¼Œè®¾ç½®å›è°ƒå‡½æ•°ã€‚&emsp;&emsp;3.å¦‚æœå¯¹uv_async_tå˜é‡è°ƒç”¨uv_async_sendï¼Œé‚£ä¹ˆuv_async_tå˜é‡çš„pendingå˜ä¸º2ï¼ˆdoneï¼‰ï¼Œå¹¶ä¸”å‘eventfdå†™ï¼Œloop-&gt;async_io_watcherå¯è¯»äº†ã€‚&emsp;&emsp;4.åœ¨uv_runçš„uv__io_pollä¸­ï¼Œæ¯æ¬¡éƒ½ä¼šæŠŠloop-&gt;watchersæ³¨å†Œåˆ°epollä¸­ï¼Œç¬¬å››æ­¥è¿™ä¸ªè¿‡ç¨‹åœ¨æ¯æ¬¡äº‹ä»¶å¾ªç¯ä¸­éƒ½åœ¨æ‰§è¡Œã€‚å¦‚æœasync_io_watcherçš„fdä¸å¯è¯»ï¼Œå°±æ²¡å®ƒäº‹å„¿ã€‚å¦‚æœå¯è¯»ï¼Œasync_io_watcherçš„å›è°ƒå‡½æ•°uv__async_ioæ‰§è¡Œï¼Œå®ƒéå†loop-&gt;async_handlesï¼Œå°†å…¶ä¸­pendingä¸º2çš„uv_async_tå˜é‡ç§»é™¤é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œå…¶å›è°ƒå‡½æ•°ã€‚ çœ‹æºç åå†™çš„å°DEMOï¼š https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config ä½ ä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ–‡å­—ï¼š 123456Host github.comUser ä½ çš„ç”¨æˆ·åï¼ˆä¾‹å¦‚97860xx@qq.comï¼‰Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 ç„¶åä¿å­˜é€€å‡ºï¼ˆä»£ç å¦‚ä¸‹ï¼‰ã€‚ 1:wq æ¥ä¸‹æ¥æµ‹è¯•ä¸€ä¸‹ï¼š 1ssh -T git@github.com å‡ºç°ä¸‹é¢çš„ç”»é¢ï¼šåœ¨å›¾ç‰‡å€’æ•°ç¬¬äº”è¡Œçš„åœ°æ–¹ä¼šè¯¢é—®æ˜¯å¦å»ºç«‹è¿æ¥ï¼Œè¾“å…¥yeså³å¯ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuvæºç åˆ†æï¼ˆ3ï¼‰init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"ç”±æ¥&emsp;&emsp;åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡æäº¤ioæ“ä½œæ—¶ï¼Œä¼šæœ‰uv_onceè¢«è°ƒç”¨ï¼Œæ¥æ£€æµ‹æ˜¯å¦åˆå§‹åŒ–è¿‡çº¿ç¨‹æ± ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç«‹åˆ»åˆå§‹åŒ–çº¿ç¨‹æ± ã€‚æ‰€ä»¥è¯´çº¿ç¨‹æ± å¹¶éä¸€å¼€å§‹åœ¨uv_runçš„æ—¶å€™æˆ–è€…åœ¨loopä¸­åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯åœ¨ioæ“ä½œå¼€å§‹å‰ã€‚æˆ‘ä»¥uv_openä¸ºä¾‹å­ç”»ä¸€ä¸‹UMLå›¾å¦‚ä¸‹ï¼šåœ¨uv_openä¸­å…ˆåˆå§‹åŒ–reqï¼Œç„¶åå‡†å¤‡æäº¤workï¼Œæäº¤å‰ä¼šè°ƒç”¨uv_onceæ£€æµ‹æ˜¯å¦åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæ²¡æœ‰åˆ™åˆå§‹åŒ–ã€‚ init_onceuv_onceå®ç°å¦‚ä¸‹ï¼š 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; åœ¨uv__work_submitä¸­uv_onceæ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼š 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚çœ‹TLPI 31.2éƒ¨åˆ†ï¼Œlibuvå¤šåšäº†pthread_atforkçš„å¤„ç†ã€‚&emsp;&emsp;pthread_atforkæ³¨å†Œreset_onceå‡½æ•°ï¼Œåœ¨forkä¹‹åé‡ç½®onceï¼Œä¿è¯åœ¨libuvå¾ªç¯ä¸­å¦‚æœä½ forkäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œå¦‚æœåœ¨é‚£ä¸ªæ–°çš„è¿›ç¨‹ä¸­ä½ ä¹Ÿå¯åŠ¨ä¸€ä¸ªlibuvï¼Œinit_threads()èƒ½è¢«è°ƒç”¨ã€‚ init_threadsğŸ¤æ¡ä»¶å˜é‡&emsp;&emsp;libuvåˆå§‹åŒ–æ¡ä»¶å˜é‡æ—¶ï¼Œè°ƒç”¨è‡ªå·±çš„uv_cond_initï¼Œè¿™ä¸ªå‡½æ•°åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å°†æ¡ä»¶å˜é‡çš„æ—¶é’Ÿè®¾ç½®ä¸ºç›¸å¯¹æ—¶é—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å€¼å¾—æˆ‘ä»¬è‡ªå·±å†™ä»£ç æ—¶å‚è€ƒçš„ï¼Œç›¸å¯¹æ—¶é—´ä¸å—ç³»ç»Ÿæ—¶é—´çš„å½±å“ã€‚ 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; ğŸ¥›äº’æ–¥é”&emsp;&emsp;åˆå§‹åŒ–äº’æ–¥é”æ—¶ï¼Œè°ƒç”¨uv_mutex_initï¼Œåœ¨DEBUGæ—¶ï¼Œlibuvä¼šå°†äº’æ–¥é”è®¾ç½®ä¸ºPTHREAD_MUTEX_ERRORCHECKï¼Œè¿™æ ·èƒ½è‡ªæˆ‘æ£€æµ‹æ˜¯å¦ä¸ºæ­»é”ï¼Œä¸è¿‡è¿™ä¼šæ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚ 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. ğŸ¥¡ä¿¡å·é‡&emsp;&emsp;åˆå§‹åŒ–æ¯ä¸ªçº¿ç¨‹æ—¶ï¼Œlibuvç”¨ä¿¡å·é‡æ¥ä¿è¯init_threadså‡½æ•°åœ¨åˆå§‹åŒ–å®Œæ‰€æœ‰çº¿ç¨‹åé€€å‡ºã€‚ 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); åœ¨linuxä¸‹å¹¶ä¸”glibcç‰ˆæœ¬å¤§äº2.21æ—¶ï¼Œuv_sem_init(&amp;sem, 0)å’Œsem_init(&amp;sem, 0)æ˜¯ä¸€æ ·çš„ï¼Œæ²¡æœ‰é¢å¤–çš„å¤„ç†ã€‚çº¿ç¨‹åˆ›å»ºå¥½åï¼Œåœ¨workerå‡½æ•°ä¸­ä¼šè°ƒç”¨uv_sem_posté‡Šæ”¾ä¿¡å·é‡ã€‚ 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; ğŸ¥šuv_thread_create&emsp;&emsp;uv_thread_createåšçš„äº‹æƒ…å°±æ˜¯è®¾ç½®çº¿ç¨‹çš„stackå¤§å°ï¼Œç„¶ååˆ›å»ºå®ƒã€‚thread_stack_sizeå‡½æ•°è·å–æ ˆå¤§å°ï¼Œæœ‰ä¸€äº›æ˜¯è·¨å¹³å°å…¼å®¹æ€§çš„å¤„ç†ã€‚ 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); å’Œif (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; ä¸Šé¢ä¸¤è¡Œçš„é™åˆ¶æ˜¯æ¥æºäºpthread_attr_setstacksizeå‡½æ•°ï¼Œä¸€ä¸‹æ˜¯pthread_attr_setstacksizeå‡½æ•°manæ‰‹å†Œçš„ä¸€éƒ¨åˆ†ã€‚ ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif ğŸ˜‚æ— è¶£çš„æ˜¯åœ¨linux Ubuntusæˆ‘çš„ç¯å¢ƒä¸‹æµ‹è¯•æ—¶ï¼Œattrçš„é»˜è®¤stacksizeå’Œthread_stack_sizeå‡½æ•°è®¾ç½®åˆ°çš„æ˜¯ä¸€æ ·çš„å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘çš„æµ‹è¯•ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ2ï¼‰uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"å‰è¨€&emsp;&emsp;ä¸Šä¸€ç¯‡è¯´äº†ä¸€ä¸‹æ•´ä½“çš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºUV_RUN_DEFAULTæ¨¡å¼æ¥è°ƒç”¨uv_runæ¥è¯´ï¼Œuv__loop_aliveå°±å†³å®šäº†æ˜¯å¦é€€å‡ºï¼Œè¿™ä¸€ç¯‡çœ‹ä¸€ä¸‹uv__loop_aliveçš„æºç ã€‚ è¯¦æƒ…12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;å¯è§loopçš„çŠ¶æ€å–å†³äºä¸‰ä¸ªæ–¹é¢ï¼šhandlesã€reqsã€closing_handles handles&emsp;&emsp;uv__has_active_handleså°±æ˜¯æ£€æŸ¥loop-&gt;active_handleså€¼æ˜¯å¦å¤§äº0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handlesåˆ—è¡¨å¦‚ä¸Šã€‚handleåœ¨è°ƒç”¨æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ï¼Œå°±æ˜¯uv__handle_startã€‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å“ªäº›å‡½æ•°è°ƒç”¨äº†uv__handle_startã€‚æœ‰ä¸€äº›handleä¸åœ¨å…¶ä¸­ï¼Œå¯èƒ½ä¸å…¶è°ƒç”¨æ–¹å¼æœ‰å…³ï¼Œæˆ‘æš‚æ—¶æ— æ³•è§£é‡Š 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_startå‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨uv__active_handle_addï¼Œuv__active_handle_addå°±æ˜¯å°†loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;ç›¸åº”çš„åœ¨handleç»“æŸæ—¶æœ‰uv__active_handle_rmçš„è°ƒç”¨ï¼Œ(h)-&gt;loop-&gt;active_handleså‡ä¸€ã€‚ 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqså’Œhandleçš„é“ç†ä¸€æ ·ï¼Œæ˜¯æ£€æµ‹(loop)-&gt;active_reqs.count &gt; 0ã€‚active_reqsæ˜¯ä¸ªå…±ç”¨ä½“ï¼Œå®ƒçš„å¦ä¸€ä¸ªç”¨é€”æš‚æ—¶æˆ‘è¿˜ä¸çŸ¥é“ã€‚ 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)ç­‰åŒäºhandleçš„uv__active_handle_addã€‚uv__req_registeråœ¨uv__req_initä¸­è°ƒç”¨ï¼Œå‡ ä¹ï¼ˆæ¼ç½‘çš„æš‚æ—¶æ²¡æ³•è§£é‡Š ï¼‰æ¯ä¸ªreqåœ¨åˆå§‹åŒ–æ—¶éƒ½è°ƒç”¨äº†uv__req_initã€‚ 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;ä¸‹å›¾æ‰€ç¤ºæ˜¯é‚£äº›å‡½æ•°è°ƒç”¨äº†uv__req_initï¼Œç”±åç§°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥å®ƒä»¬æ˜¯å±äºå“ªäº›reqçš„ã€‚&emsp;&emsp;åŒç†ï¼Œè¿˜æœ‰uv__req_unregisterã€‚ 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;è¦å…³é—­çš„handleä¼šä»¥é“¾è¡¨çš„å½¢å¼æŒ‚åœ¨loop-&gt;closing_handlesä¸Šã€‚è¿™ä¸ªæ“ä½œé€šè¿‡è°ƒç”¨uv__make_close_pendingæ¥å®ç°ã€‚ 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; å¦‚æœclosing_handlesä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿˜éœ€è¦è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œå»è°ƒç”¨å…³é—­çš„handleçš„å›è°ƒå‡½æ•°ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ1ï¼‰äº‹ä»¶å¾ªç¯åˆ†æ","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"å‰è¨€ &emsp;&emsp;libuvæ€»æ˜¯æŠ¥å‡ºä¸€äº›è®©äººéš¾ä»¥ç†è§£çš„é”™è¯¯ğŸ˜‚ï¼Œä½œä¸ºä¸€ä¸ªCçš„é¡¹ç›®ï¼Œä¸å…·æœ‰Javaã€JavaScriptã€phpé‚£æ ·çš„äººæ°”ï¼Œå¾ˆéš¾ç™¾åº¦åˆ°ä¸€äº›é—®é¢˜çš„ç­”æ¡ˆï¼Œç”šè‡³googleä¹Ÿä¸è¡Œã€‚ä¸ºäº†ç”¨å¥½libuvï¼Œä¹Ÿä¸ºäº†å­¦ä¹ å§ã€‚æˆ‘å¼€å§‹çœ‹libuvçš„æºç ï¼Œä¸çŸ¥é“è‡ªå·±èƒ½èµ°å¤šè¿œã€‚ã€‚ã€‚ äº‹ä»¶å¾ªç¯ è¿™æ˜¯å®˜æ–¹äº‹ä»¶å¾ªç¯çš„ç¤ºæ„å›¾ã€‚é“¾æ¥-&gt;å®˜æ–¹å›¾ç‰‡ä½ç½® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;æ•´ä¸ªäº‹ä»¶å¾ªç¯å°±æ˜¯åœ¨ä¸»çº¿ç¨‹çš„uv_runï¼ˆï¼‰è°ƒç”¨ä¸­æ‰§è¡Œçš„ã€‚æˆ‘å°±è·Ÿç€å®˜æ–¹çš„ä»‹ç»ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼ˆå®˜æ–¹ä»‹ç»ï¼‰ã€‚ ç¬¬ä¸€æ­¥ The loop concept of â€˜nowâ€™ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;ç¬¬ä¸€æ­¥æ˜¯æ›´æ–°æ—¶é—´ã€‚å¯¹åº”ä»£ç å¦‚ä¸‹ï¼š 1uv__update_time(loop); &emsp;&emsp;æ€»ç»“æ¥è¯´å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ›´æ–°æ—¶é—´ã€‚uv__update_timeå®ç°æˆ‘ä¸‹ä¸€ç¯‡æ¥ä»‹ç» ç¬¬äºŒæ­¥ If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and refâ€™d handles, active requests or closing handles itâ€™s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;ç”¨uv__loop_aliveå‡½æ•°è·å–loopçŠ¶æ€ã€‚&emsp;&emsp;å¦‚æœuv__loop_aliveè¿”å›é›¶æˆ–è€…loop-&gt;stop_flag == 1è¯´æ˜loopç»ˆæ­¢ï¼Œç›´æ¥è·³è¿‡å¾ªç¯ï¼Œåˆ°ä»£ç æœ€ä¸‹é¢ï¼ˆè¿™é‡Œæœ‰ä¸€äº›æ€§èƒ½çš„å¤„ç†æš‚æ—¶ä¸ç®¡ ï¼‰ï¼Œé€€å‡ºï¼š 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0çš„ä¸€ä¸ªæ¥æºæ˜¯è°ƒç”¨äº†uv_stopï¼Œè¿™ä¸ªå‡½æ•°åœ¨æ‰‹å†Œä¸­çœ‹è§ã€‚å®ƒçš„æºä»£ç ä¹Ÿå¾ˆæ¸…æ™°ã€‚ 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;å¦‚æœloopçŠ¶æ€OKï¼Œé‚£ä¹ˆå°±è¿›å…¥å¾ªç¯ä¸­ã€‚ ç¬¬ä¸‰æ­¥ Due timers are run. All active timers scheduled for a time before the loopâ€™s concept of now get their callbacks called. &emsp;&emsp;å¯¹åº”ä»£ç è¿™ä¸€éƒ¨åˆ†ï¼š 1234567891011121314151617181920uv__run_timers(loop);å…¶å®ç°ï¼švoid uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;å°†å †é‡Œé¢å·²ç»è¶…æ—¶çš„æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬å››æ­¥ Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. å¯¹åº”ï¼š 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);å…¶å®ç°ï¼šstatic int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;å°†loop-&gt;pending_queueä¸­çš„ä»»åŠ¡æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬äº”ã€å…­ã€ä¹æ­¥ 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;è¿™ä¸‰éƒ¨ä¸ºä»€ä¹ˆè¦ä¸€èµ·è¯´å‘¢ï¼Ÿå› ä¸ºå®ƒä»¬çš„å®è´¨æ˜¯ä¸€æ ·çš„ã€‚åœ¨æ¯æ¬¡å¾ªç¯å›ºå®šçš„ä½ç½®è°ƒç”¨ã€‚&emsp;&emsp;è¿™ä¸‰ä¸ªå‡½æ•°å®šä¹‰åœ¨loop-watcher.cè¿™ä¸ªæ–‡ä»¶é‡Œé¢ï¼Œå®ƒä»¬æ˜¯ç”¨å®å®šä¹‰å®šä¹‰çš„ã€‚åªæ”¹äº†idleã€prepareã€checkè¿™ä¸‰ä¸ªåå­—çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†å‡½æ•°éƒ½æ˜¯ä¸€æ ·çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) ç¬¬ä¸ƒæ­¥ Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;è¿™éƒ¨åˆ†æ˜¯å–å†³äºuv_runçš„æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼Œæš‚æ—¶ä¸ç»†çœ‹ã€‚ ç¬¬å…«æ­¥ The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯¹äºä¸åŒæ“ä½œç³»ç»Ÿæœ‰æ‰€ä¸åŒï¼Œlinuxæ˜¯pollï¼Œmacæ˜¯kqueueã€‚ ç¬¬åæ­¥ Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;è°ƒç”¨å„ç±»çš„closeå›è°ƒå‡½æ•°ã€‚ ç¬¬åä¸€ã€åäºŒæ­¥ 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. Itâ€™s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if itâ€™s still alive, otherwise it will also end. &emsp;&emsp;å¯¹äºuv_runä¸åŒæ¨¡å¼çš„ä¸€ç‚¹ç‰¹æ®Šå¤„ç†ã€‚ 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; å°ç»“&emsp;&emsp;å®è§‚ä¸Šæ¢³ç†ä¸€ä¸‹æ•´ä¸ªäº‹ä»¶å¾ªç¯çš„è¿‡ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2.5)","slug":"rax3","date":"2019-08-14T10:40:51.000Z","updated":"2019-11-25T19:51:03.317Z","comments":true,"path":"2019/08/14/rax3/","link":"","permalink":"http://yoursite.com/2019/08/14/rax3/","excerpt":"","text":"ç‚¹ç‚¹åºŸè¯&emsp;&emsp;æœ€è¿‘æ²¡æœ‰å†å°†raxçš„æºç å¾€ä¸‹çœ‹ï¼Œraxå¯¹äºä¸€ä¸ªæ–°æ‰‹æ¥è¯´è¿˜æ˜¯ä½“é‡è¿‡å¤§ï¼Œåœ¨å°è¯•è‡ªå·±å†™å†™ï¼Œåœ¨å†™çš„æ—¶å€™é‡åˆ°äº†ä¸€äº›å‘ï¼Œä¹Ÿä½“ä¼šåˆ°äº†raxçš„ä¸€äº›å†™æ³•çš„ç²¾å¦™ä¹‹å¤„ï¼Œè®°å½•ä¸€ä¸‹ã€‚ å®å®šä¹‰å‡½æ•°çš„æ³¨æ„ç‚¹ï¼š&emsp;&emsp;æˆ‘å®šä¹‰äº†è¿™æ ·ä¸€ä¸ªå®å®šä¹‰å‡½æ•°ï¼š 12#define radixNthChild(h, n) \\ (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*)) æˆ‘è¿™æ ·è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š 1radixNthChild(new_cur, new_cur-&gt;size - 1) è¿™æ ·ä¸€ä¸ªè°ƒç”¨å¤§å®¶è§‰å¾—æœ‰é—®é¢˜å—ï¼Ÿå—¯ï¼Œè‚¯å®šæ˜¯æœ‰é—®é¢˜çš„ï¼Œä¸ç„¶æˆ‘è¯´å•¥?ã€‚ è¿™é‡Œï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¸€èˆ¬çš„è°ƒç”¨å‡½æ•°çš„æ€è·¯ï¼Œè¿™æ ·ä¸€ä¸ªè°ƒç”¨çš„è¿è¡Œè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š è®¡ç®—å‡ºnew_cur-&gt;size - 1 å¸¦å…¥radixNthChildå‡½æ•° å®é™…ä¸Šæ°æ°ç›¸åï¼Œå®å®šä¹‰çš„å¤„ç†åœ¨é¢„ç¼–è¯‘æ—¶ï¼ˆg++ -Eï¼‰ï¼Œå®å®šä¹‰æ˜¯å°†å¯¹äºçš„å®šä¹‰æ›¿æ¢æ‰ï¼Œæ‰€ä»¥åœ¨é¢„ç¼–è¯‘åçš„ç»“æœå¦‚ä¸‹ï¼š 12# 363 &quot;radix_tree.c&quot; memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*)); å¯ä»¥çœ‹åˆ°æ˜¯ ï¼š + new_cur-&gt;size - 1 * sizeof(void)è€Œä¸æ˜¯æˆ‘æ‰€æƒ³çš„ï¼š + ï¼ˆnew_cur-&gt;size - 1ï¼‰ * sizeof(void) å¯ä»¥å¾—å‡ºå…¶è¿‡ç¨‹å…¶å®æ˜¯ï¼š å‡½æ•°å®å®šä¹‰æ›¿æ¢ è¿è¡Œæ—¶è®¡ç®— ç»“è®ºï¼š åœ¨å®å®šä¹‰å‡½æ•°è°ƒç”¨æ—¶æ³¨æ„æ‹¬å·çš„é—®é¢˜ï¼Œä¸åŠ æ‹¬å·å¯èƒ½ä¼šç”±äºè¿ç®—ç¬¦ä¼˜å…ˆçº§è€Œ å¯¼è‡´è¡¨è¾¾å¼æ„ä¹‰ä¸æˆ‘ä»¬æƒ³çš„æœ‰å‡ºå…¥? åœ°å€è¿ç®—æ³¨æ„ç‚¹å…ˆç»™å‡ºè¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼š 123struct test &#123; void* a, *b, *c;&#125;; int main(void) { cout &lt;&lt; sizeof(test) &lt;&lt; endl; test* p = new test; fprintf(stdout, &quot;%p:%p:%p:%p\\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1); return 0; }&emsp;&emsp;åœ¨è¿™æ ·ä¸€ä¸ªæµ‹è¯•ä»£ç ä¸­ï¼Œå¤§å®¶è§‰å¾—p + 1, (char)p + 1, (int)p+1è¿™ä¸‰ä¸ªç»“æœï¼Œç›¸å¯¹äºpçš„æ•°å€¼ç›¸å·®å¤šå°‘å‘¢ï¼Ÿ&emsp;&emsp;è¿è¡Œç»“æœæ˜¯è¿™æ ·çš„ã€‚ç±»å‹ä¸åœ°å€çš„è¿ç®—æ˜¯æœ‰ç€å¯†åˆ‡å…³ç³»çš„ã€‚ p + 1æ˜¯ä¸€ä¸ªé»˜è®¤æƒ…å†µï¼Œ è¿™æ—¶1çš„æ„ä¹‰æ˜¯ä¸€ä¸ªpçš„åœ°å€å®½åº¦ (char*)p + 1ï¼Œpè¢«è§£é‡Šä¸ºcharç±»å‹æŒ‡é’ˆï¼ŒæŒ‡å‘çš„åœ°å€è¢«è§£é‡Šä¸ºcharï¼Œäºæ˜¯1å°±æ˜¯ä¸€ä¸ªcharçš„åœ°å€å®½åº¦ã€‚ æ€»ç»“ï¼š åœ¨è®¡ç®—åœ°å€æ—¶ï¼Œè¦æ³¨æ„è¿ç®—ç¬¦å·¦è¾¹å€¼çš„ç±»å‹ã€‚ä½ åŠ ä¸Šçš„1å¯èƒ½å¹¶ä¸æ˜¯ä¸€ä¸ªå­—èŠ‚çš„å¤§å°ã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2)","slug":"rax2","date":"2019-08-12T10:51:18.000Z","updated":"2019-11-25T19:49:43.833Z","comments":true,"path":"2019/08/12/rax2/","link":"","permalink":"http://yoursite.com/2019/08/12/rax2/","excerpt":"","text":"ä»Šå¤©æˆ‘æƒ³è¦è¯´çš„æ˜¯raxä¸­çš„paddingè¿™ä¸ªå‡½æ•°ï¼Œæˆ‘æŸ¥äº†å¾ˆå¤šçš„èµ„æ–™ï¼Œå¤§å®¶çš„åšå®¢éƒ½å‘Šè¯‰æˆ‘ä»¬å†…å­˜å¯¹é½æé«˜æ€§èƒ½ï¼Œå´æ²¡æœ‰å»åˆ†æä¸ºä»€ä¹ˆï¼Œæ˜¯æœ‰æ ¹æ®è®©ä½œè€…é€‰æ‹©è¿™æ ·åšï¼Ÿå¦‚æœåªæ˜¯è¿™æ ·ç®€å•çš„æ”¾è¿‡ï¼Œæ€»æ„Ÿè§‰è®©äººæœ‰ä¸€ä¸çš„é—æ†¾ã€‚ &emsp;&emsp;å…ˆæŠŠä¸»è§’æ‹‰å‡ºæ¥ï¼š 12#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1)) &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯raxPaddingçš„ä½œç”¨æ˜¯ï¼šè®©raxNewNodeç”³è¯·çš„å†…å­˜nodesizeæ˜¯8çš„å€æ•°ã€‚ 123456789101112raxNode *raxNewNode(size_t children, int datafield) &#123; size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+ sizeof(raxNode*)*children; if (datafield) nodesize += sizeof(void*); raxNode *node = rax_malloc(nodesize); if (node == NULL) return NULL; node-&gt;iskey = 0; node-&gt;isnull = 0; node-&gt;iscompr = 0; node-&gt;size = children; return node;&#125; ç¬¬ä¸€ä¸ªé—®é¢˜ï¼šå¯¹é½çš„ä¼˜åŠ¿&emsp;&emsp;è¿™ä¸ªå¹¶ä¸æ˜¯æˆ‘æƒ³è¯´çš„é‡ç‚¹ï¼Œè¿™é‡Œæ˜¯å¤§å®¶éƒ½è°ˆåˆ°çš„ï¼Œä¹Ÿå°±æ˜¯ç»è¿‡å†…å­˜å¯¹é½ä¹‹åï¼ŒCPUçš„å†…å­˜è®¿é—®é€Ÿåº¦å¤§å¤§æå‡ã€‚å¯¹äºæˆ‘æ¥è¯´ï¼Œè¿™ä¸ªç»“è®ºæ„Ÿè§‰è¿˜æ˜¯å¤ªæ¨¡ç³Šï¼Œè¿™æ˜¯ä¸€ä¸ªå®šæ€§çš„ç»“è®ºï¼Œå…·ä½“çš„åº•å±‚ç»†èŠ‚å¯¹äºæˆ‘ä»¬åˆå­¦è€…æ¥è¯´å€’æ˜¯æ²¡å¿…è¦å»æ·±ç©¶ã€‚ ç¬¬äºŒä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå»åšï¼Ÿ&emsp;&emsp;raxçš„ä½œè€…è¿™æ ·çš„åšæ³•å…¶å®æ˜¯å‚è€ƒç»“æ„ä½“çš„åšæ³•ã€‚ä¸¾ä¸ªä¾‹å­ï¼š 123456struct X&#123; char a; int c; double b;&#125;S2; è¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼Œå®ƒçš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿç­”æ¡ˆæ˜¯16ã€‚åœ¨cè¯­è¨€çš„å†…éƒ¨ï¼Œåšäº†è¿™æ ·çš„å†…å­˜å¯¹é½å¤„ç†ï¼š è¿™é‡Œè½¬è½½äº†è¿™ç¯‡æ–‡ç« ä¸­çš„å¾ˆå¤šèµ„æºï¼Œå¤§å®¶ä¹Ÿå¯ä»¥å»çœ‹çœ‹è¿™ç¯‡æ–‡ç« ï¼Œå†™çš„å¾ˆä¸é”™ã€‚ä¹Ÿæœ‰æ›´å¤šä¾‹å­ã€‚ å›åˆ°raxä¸Šæ¥&emsp;&emsp; åœ¨raxçš„raxNodeè¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œå› ä¸ºä½¿ç”¨äº†æŸ”æ€§æ•°ç»„ï¼Œæ‰€ä»¥åœ¨cè¯­è¨€æœ¬èº«æ˜¯æ— æ³•å¸®åŠ©æˆ‘ä»¬å®ç°åƒä¸Šé¢ä¸€æ ·çš„å†…å­˜å¯¹é½çš„ï¼ˆsizeof(raxNode) == 4,æˆ‘ä»¬ç”³è¯·çš„å†…å­˜å¤§å°å†³å®šäº†æŸ”æ€§æ•°ç»„çš„é•¿åº¦ï¼Œè¯¦æƒ…è¯·ç™¾åº¦æŸ”æ€§æ•°ç»„ï¼‰ ï¼Œcè¯­è¨€å¯¹äºç»“æ„ä½“çš„ä¼˜åŒ–æ²¡æœ‰åŒ…å«æŸ”æ€§æ•°ç»„è¿™ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»è‡ªå·±æ¥æ¥ç®¡è¿™ä¸€éƒ¨åˆ†çš„å†…å­˜å¯¹é½ï¼Œä¿è¯ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚ typedef struct raxNode { uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; /* Number of children, or compressed string len. */ unsigned char data[]; } raxNode; è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(1)","slug":"rax1","date":"2019-08-11T16:11:44.000Z","updated":"2019-11-25T19:48:25.184Z","comments":true,"path":"2019/08/12/rax1/","link":"","permalink":"http://yoursite.com/2019/08/12/rax1/","excerpt":"","text":"&emsp;&emsp;æœ€è¿‘æƒ³ç”¨libuvå†™ä¸ªhttpæœåŠ¡å™¨ï¼Œçœ‹åˆ°äº†è¿™ä¸ªå¼€æºé¡¹ç›®haywireï¼Œåœ¨çœ‹åˆ°ç¬¬39æ¬¡æäº¤çš„æ—¶å€™ï¼Œä½œè€…ç”¨åŸºæ•°æ ‘æ¥å­˜å‚¨ä¸åŒè·¯ç”±çš„controllerï¼Œä¸è¿‡åœ¨åç»­ç‰ˆæœ¬ä¸­æ”¹ä¸ºäº†ä½¿ç”¨hashï¼Œä¸è¿‡æƒ³æ¥ä¸å¦‚æ­£å¥½å­¦å­¦åŸºæ•°æ ‘ï¼Œä½œè€…ä½¿ç”¨çš„åŸºæ•°æ ‘æ˜¯è¿™ä¸ªç‰ˆæœ¬radix_treeï¼Œè¿™ä¸ªç‰ˆæœ¬ç¼ºå°‘æ³¨é‡Šï¼Œä¸”å’Œä¸€èˆ¬æ€è·¯ä¸ä¸€æ ·çš„ä½¿ç”¨çš„æ˜¯äºŒå‰æ ‘è€ŒéNå‰æ ‘ï¼Œä¸ºäº†ç†è§£æ–¹ä¾¿ï¼Œæˆ‘é€‰æ‹©äº†æ³¨é‡Šè¾ƒå¤šçš„rax æ•°æ®ç»“æ„&emsp;&emsp;é¦–å…ˆè¦æåˆ°çš„æ˜¯raxçš„æ•°æ®ç»“æ„è®¾è®¡ï¼š 1234567typedef struct raxNode &#123; uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; / unsigned char data[];&#125; raxNode; è¿™é‡Œç¬¬ä¸€ä¸ªè¦è¯´åˆ°çš„ç‚¹æ˜¯ï¼šä½ è§‰å¾—è¿™æ ·ä¸€ä¸ªæ•°æ®ç»“æ„çš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿ24ï¼Ÿ 16ï¼Ÿ è¿˜æ˜¯8ï¼Ÿ&emsp;&emsp;ç¬¬ä¸€ä¸ªåŸå› æ˜¯ä½åŸŸï¼Œä¹Ÿå°±æ˜¯ç»“æ„ä½“ä¸­çš„å†’å·ï¼š ï¼Œå†’å·åœ¨è¿™é‡Œå£°æ˜å®é™…éœ€è¦ä½¿ç”¨çš„ä½æ•°ï¼Œiskeyï¼Œisnullï¼Œiscomprï¼Œsizeå››ä¸ªä¸€å…±åŠ èµ·æ¥32ä½ï¼Œå 4ä¸ªå­—èŠ‚ã€‚&emsp;&emsp;ç¬¬äºŒä¸ªåŸå› æ˜¯data[]å 0ä¸ªå­—èŠ‚ã€‚unsigned char data[];è¿™æ ·ä¸€ä¸ªç»“æ„åœ¨è¿™é‡Œå¹¶ä¸æ˜¯ç†è§£æˆä¸€ä¸ªæŒ‡é’ˆ8ä¸ªå­—èŠ‚ã€‚è€Œæ˜¯ä¸€ä¸ªæŸ”æ€§æ•°ç»„çš„æ¦‚å¿µï¼Œå®ç°ä¸€ä¸ªå¯å˜é•¿åº¦ã€‚data[1]å ç»“æ„ä½“1ä¸ªå­—èŠ‚ï¼Œdata[2]å ç»“æ„ä½“2ä¸ªå­—èŠ‚â€¦â€¦.data[13]å 13ä¸ªå­—èŠ‚ã€‚æ•°ç»„ç±»å‹çš„å†…å­˜æ˜¯ç»“æ„ä½“ä¸­ç›´æ¥åˆ†é…çš„ï¼Œè€Œä¸æ˜¯åƒæŒ‡é’ˆä¸€æ ·éœ€è¦æˆ‘ä»¬åæ¥åˆ†é…ã€‚å¦‚ä¸‹å›¾å¯è§ï¼š 12345678910typedef struct raxNode &#123; unsigned char data[13];&#125; raxNode;int main(int argc, char *argv[])&#123; printf(&quot;%d\\n&quot;, sizeof(raxNode)); return 0;&#125; data[]&emsp;&emsp;æ¥ä¸‹æ¥æˆ‘ä»¬è¿˜æ˜¯è¦è°ˆdataï¼Œåœ¨è¿™é‡Œdataçš„æ„ä¹‰å¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•çš„unsigned charæ•°ç»„ï¼Œå®ƒå­˜å‚¨çš„æ˜¯é”®å€¼keyå’ŒradixNodeæŒ‡é’ˆä¸¤ç§å˜é‡ã€‚å›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132dataçš„å®é™…ä½¿ç”¨æ–¹å¼åœ¨å¤§å¤šæ•°æ—¶å€™æ˜¯ä»¥å†…å­˜åœ°å€çš„æ–¹å¼è¿›è¡Œçš„ã€‚ 123456#define raxNodeLastChildPtr(n) ((raxNode**) ( \\ ((char*)(n)) + \\ raxNodeCurrentLength(n) - \\ sizeof(raxNode*) - \\ (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \\)) &emsp;&emsp;è¿™æ˜¯è®¿é—®æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯è®¿é—®å›¾ä¸­çš„A-ptrï¼‰ã€‚næ˜¯ä¸€ä¸ªraxNode*æŒ‡é’ˆï¼Œå¯¹è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„åœ°å€è¿›è¡Œï¼‹æ“ä½œæ¥å¾—åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚ èŠ‚ç‚¹çš„è¡¨ç¤ºå›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132&emsp;&emsp;å‡è®¾åŸºæ•°æ ‘ä¸­æœ‰â€œabcdâ€è¿™ä¸ªé”®å€¼çš„èŠ‚ç‚¹ã€‚é‚£ä¹ˆå®ƒçš„è¡¨ç¤ºå½¢å¼æ˜¯åƒä¸Šå›¾è¿™æ ·çš„ã€‚â€œabcdâ€è¿™ä¸ªèŠ‚ç‚¹çš„value-dataå­˜å‚¨åœ¨å›¾ç‰‡ä¸‹åŠéƒ¨åˆ†çš„èŠ‚ç‚¹å¤„ï¼Œå¹¶ä¸”ä¸‹é¢ä¸€ä¸ªèŠ‚ç‚¹iskeyè®¾ä¸º1.&emsp;&emsp;ä¸ºä»€ä¹ˆä¸æ˜¯ç›´æ¥åªæœ‰å›¾ç‰‡çš„ä¸ŠåŠéƒ¨åˆ†ï¼Œç”±å›¾ç‰‡ä¸ŠåŠéƒ¨åˆ†é‚£ä¸ªèŠ‚ç‚¹å°†iskeyè®¾ç½®ä¸º1å¹¶ä¸”å°†å€¼å­˜å‚¨åœ¨å…¶valueÂ·dataä¸­å‘¢ï¼Ÿåƒè¿™æ ·ï¼š [iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr] å…ˆç»™å‡ºç»“è®ºï¼š åœ¨raxä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å­˜åœ¨ï¼ˆiskey == 1ï¼‰æ˜¯ç”±dataä¸­å¯¹åº”çš„å­èŠ‚ç‚¹æ¥è¡¨ç¤ºçš„ã€‚åŸå› å¾ˆç®€å•ï¼šåœ¨è¿™ä¸ªä¾‹å­é‡Œé¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰å‹ç¼©çš„èŠ‚ç‚¹ï¼Œè¿™ä¸€å±‚ç”±aå’ŒAä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœåœ¨å½“å‰å±‚æ¬¡è¡¨ç¤ºï¼Œå¦‚ä½•åˆ†è¾¨ä½ æŒ‡å®šçš„æ˜¯aè¿˜æ˜¯Aï¼Ÿæ‰€ä»¥ç”¨å¼•å‡ºå­èŠ‚ç‚¹æ¥è¡¨ç¤ºã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]}]}