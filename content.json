{"meta":{"title":"lurenaaã®blog","subtitle":"","description":"","author":"ä¸¤å¤©å®‡å®™äºº","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨** å¯èƒ½æ˜¯è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«åˆ é™¤"},{"title":"å…³äº","date":"2019-11-21T19:51:46.860Z","updated":"2019-11-21T19:51:46.860Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T20:04:05.184Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2019-11-21T19:32:31.327Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":""},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"å½’æ¡£","date":"2019-11-21T20:12:46.614Z","updated":"2019-11-21T20:12:46.614Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"libuvæºç åˆ†æï¼ˆ4ï¼‰async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-24T19:32:35.007Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuvä¸­asyncçš„å¼€ç«¯åœ¨uv_loop_initå‡½æ•°ä¸­ï¼š 12345678//å‰é¢çœç•¥err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//åé¢çœç•¥ &emsp;&emsp;loop-&gt;wq_asyncæ˜¯ä¸ªuv_async_tç±»å‹ï¼Œå®ƒç”¨äºçº¿ç¨‹workå‡½æ•°è°ƒç”¨æœ€åå¤„ç†loop-&gt;wqä¸­çš„å›è°ƒï¼Œæš‚æ—¶ä¸ç”¨ç®¡ã€‚&emsp;&emsp;æˆ‘ä»¬æ¥çœ‹uv_async_initå†…éƒ¨ï¼š 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;ç¬¬äº”è¡Œä»¥åçš„æ“ä½œå°±æ˜¯åˆå§‹åŒ–åŸºç±»uv_handle_tä»¥åŠå­ç±»uv_async_tï¼Œç„¶åå°†è¿™ä¸ªhandleæ”¾å…¥loop-&gt;queue(æ”¾uv_handle_tçš„é˜Ÿåˆ—)ä»¥åŠæ”¾å…¥loop-&gt;async_handlesï¼ˆæ”¾uv_async_tçš„é˜Ÿåˆ—ï¼‰ä¸­ï¼Œç„¶åuv__handle_startä¸­å°†loop-&gt;active_handlesåŠ ä¸€ã€‚&emsp;&emsp;æ€»è€Œè¨€ä¹‹ï¼Œç¬¬äº”è¡Œä»¥åçš„å†…å®¹å°±æ˜¯åˆå§‹åŒ–uv_async_tï¼Œå¯ä»¥ç†è§£æˆuv_async_tçš„æ„é€ å‡½æ•°ã€‚&emsp;&emsp;uv__async_startåˆ™ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯åˆå§‹åŒ–å‡½æ•°ï¼Œå®ƒåªä¼šè°ƒç”¨ä¸€æ¬¡ï¼ˆä¸€èˆ¬æƒ…å†µæ˜¯åœ¨uv_loop_initä¸­è°ƒç”¨ï¼‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹å®ƒçš„å®ç°ï¼š 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //ä¸­é—´çœç•¥ uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;çœ‹ç¬¬ä¸‰è¡Œloop-&gt;async_io_watcher.fdï¼Œå½“ä½ è°ƒç”¨è¿‡ä¸€æ¬¡è¿™ä¸ªå‡½æ•°åï¼Œloop-&gt;async_io_watcher.fdä¸ä¼šç­‰äº-1ï¼Œä»¥åä½ åˆå§‹åŒ–uv_async_tç±»å‹å˜é‡ï¼Œè°ƒç”¨uv_async_initå‡½æ•°æ—¶ï¼Œuv__async_startéƒ½æ˜¯ç›´æ¥è¿”å›çš„ã€‚&emsp;&emsp;æˆ‘çœç•¥æ‰äº†ä¸­é—´å¦‚æœeventfdæ²¡æœ‰åœ¨å½“å‰ç³»ç»Ÿä¸‹å®ç°æ—¶çš„å…¼å®¹æ€§å¤„ç†ã€‚æ€»çš„æ¥è¯´ï¼Œå°±æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherã€‚uv__io_tæ˜¯ä¸ºepollè®¾è®¡çš„ç»“æ„ä½“ã€‚è¿™é‡Œä½ è‚¯å®šæ„Ÿè§‰å¾ˆæ‡µé€¼ï¼Œè¯·åšæŒä¸€ä¸‹ï¼Œæœ€åæˆ‘ä¼šæ¢³ç†ä¸€ä¸‹æ€»ä½“çš„æ•´ä¸ªè¿‡ç¨‹ã€‚&emsp;&emsp;uv__io_tçš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678uv__io_t&#123; uv__io_cb cb; //å›è°ƒå‡½æ•° void* watcher_queue[2]; //æ”¾å…¥loop-&gt;watcher_queue void* pending_queue[2]; //åŒç† unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºepollæ³¨å†Œ&#125; &emsp;&emsp;è¿™é‡Œuv__io_initå‡½æ•°æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherè¿™ä¸ªç»“æ„ä½“ï¼š 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //å‰é¢æˆ‘ä»¬çš„eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_startå°†loop-&gt;async_io_watcheræ”¾å…¥loop-&gt;watcher_queueã€‚è¿˜æœ‰å¯¹äºloop-&gt;nfdså¤§å°çš„å¤„ç†ã€‚ 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;ç¬¬å››è¡Œä»¥åçš„æ“ä½œæ˜¯ä¸ºäº†åœ¨epollåï¼Œæˆ‘ä»¬å¾—åˆ°struct eventç»“æ„ä½“ï¼Œæˆ‘ä»¬ä»event-&gt;data.fdå¯ä»¥å¾—åˆ°fdï¼Œé‚£æˆ‘ä»¬å¦‚ä½•è·å–åˆ°å¯¹åº”çš„uv__io_tå‘¢ï¼Ÿ å°±æ˜¯é€šè¿‡loop-&gt;watchersè¿™ä¸ªæ•°ç»„ã€‚ uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCEï¼š 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;è¿™é‡Œè°ƒç”¨ä¸€æ¬¡ACCESS_ONCEï¼Œæ˜¯ä¸ºäº†å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œhandle-&gt;pendingå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼Œæ‰€ä»¥åˆ«ç»™æˆ‘ä¹±ä¼˜åŒ–ã€‚&emsp;&emsp;cmpxchgiæ˜¯åŸå­æ“ä½œcompare_and_changeã€‚pendingçš„æœ‰ä¸‰ä¸ªå–å€¼0ï¼Œ1ï¼Œ2ã€‚0ä»£è¡¨é—²ç½®ã€1ä»£è¡¨å¿™ï¼ˆæ¯”å¦‚uv_async_sendè°ƒç”¨é€”ä¸­ï¼‰ã€2ä»£è¡¨å®Œæˆã€‚loop-&gt;async_io_watcherè°ƒç”¨uv__async_ioæ—¶ï¼Œä¼šéå†loop-&gt;async_handlesï¼Œé€šè¿‡pendingæ¥åˆ¤æ–­å“ªäº›å›è°ƒè¯¥è¢«æ‰§è¡Œã€‚&emsp;&emsp;uv__async_sendå°±æ˜¯å‘loop-&gt;async_io_watcher.fdï¼ˆeventfdï¼‰å†™ï¼ˆè¿™é‡Œå…³ç³»åˆ°eventfdçš„æœºåˆ¶ï¼Œä¸æ‡‚å¯ä»¥man eventfdï¼‰ã€‚ æ•´ä½“è°ƒç”¨è¿‡ç¨‹&emsp;&emsp;è¿™é‡Œæ€»ä½“å½’çº³ä¸€ä¸‹asyncçš„è¿‡ç¨‹ã€‚&emsp;&emsp;1.åœ¨loop_uv_initä¸­åˆå§‹åŒ–async_io_watcherï¼Œå®ƒçš„fdä¸ºeventfdï¼Œå€¼ä¸º0ï¼Œä¸å¯è¯»ã€‚&emsp;&emsp;2.ç”¨æˆ·uv_async_initæ³¨å†Œuv_async_tå˜é‡ï¼Œè¢«æ·»åŠ åˆ°loop-&gt;async_handlesï¼Œè®¾ç½®å›è°ƒå‡½æ•°ã€‚&emsp;&emsp;3.å¦‚æœå¯¹uv_async_tå˜é‡è°ƒç”¨uv_async_sendï¼Œé‚£ä¹ˆuv_async_tå˜é‡çš„pendingå˜ä¸º2ï¼ˆdoneï¼‰ï¼Œå¹¶ä¸”å‘eventfdå†™ï¼Œloop-&gt;async_io_watcherå¯è¯»äº†ã€‚&emsp;&emsp;4.åœ¨uv_runçš„uv__io_pollä¸­ï¼Œæ¯æ¬¡éƒ½ä¼šæŠŠloop-&gt;watchersæ³¨å†Œåˆ°epollä¸­ï¼Œç¬¬å››æ­¥è¿™ä¸ªè¿‡ç¨‹åœ¨æ¯æ¬¡äº‹ä»¶å¾ªç¯ä¸­éƒ½åœ¨æ‰§è¡Œã€‚å¦‚æœasync_io_watcherçš„fdä¸å¯è¯»ï¼Œå°±æ²¡å®ƒäº‹å„¿ã€‚å¦‚æœå¯è¯»ï¼Œasync_io_watcherçš„å›è°ƒå‡½æ•°uv__async_ioæ‰§è¡Œï¼Œå®ƒéå†loop-&gt;async_handlesï¼Œå°†å…¶ä¸­pendingä¸º2çš„uv_async_tå˜é‡ç§»é™¤é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œå…¶å›è°ƒå‡½æ•°ã€‚ çœ‹æºç åå†™çš„å°DEMOï¼š https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config ä½ ä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ–‡å­—ï¼š 123456Host github.comUser ä½ çš„ç”¨æˆ·åï¼ˆä¾‹å¦‚97860xx@qq.comï¼‰Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 ç„¶åä¿å­˜é€€å‡ºï¼ˆä»£ç å¦‚ä¸‹ï¼‰ã€‚ 1:wq æ¥ä¸‹æ¥æµ‹è¯•ä¸€ä¸‹ï¼š 1ssh -T git@github.com å‡ºç°ä¸‹é¢çš„ç”»é¢ï¼šåœ¨å›¾ç‰‡å€’æ•°ç¬¬äº”è¡Œçš„åœ°æ–¹ä¼šè¯¢é—®æ˜¯å¦å»ºç«‹è¿æ¥ï¼Œè¾“å…¥yeså³å¯ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuvæºç åˆ†æï¼ˆ3ï¼‰init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"ç”±æ¥&emsp;&emsp;åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡æäº¤ioæ“ä½œæ—¶ï¼Œä¼šæœ‰uv_onceè¢«è°ƒç”¨ï¼Œæ¥æ£€æµ‹æ˜¯å¦åˆå§‹åŒ–è¿‡çº¿ç¨‹æ± ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç«‹åˆ»åˆå§‹åŒ–çº¿ç¨‹æ± ã€‚æ‰€ä»¥è¯´çº¿ç¨‹æ± å¹¶éä¸€å¼€å§‹åœ¨uv_runçš„æ—¶å€™æˆ–è€…åœ¨loopä¸­åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯åœ¨ioæ“ä½œå¼€å§‹å‰ã€‚æˆ‘ä»¥uv_openä¸ºä¾‹å­ç”»ä¸€ä¸‹UMLå›¾å¦‚ä¸‹ï¼šåœ¨uv_openä¸­å…ˆåˆå§‹åŒ–reqï¼Œç„¶åå‡†å¤‡æäº¤workï¼Œæäº¤å‰ä¼šè°ƒç”¨uv_onceæ£€æµ‹æ˜¯å¦åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæ²¡æœ‰åˆ™åˆå§‹åŒ–ã€‚ init_onceuv_onceå®ç°å¦‚ä¸‹ï¼š 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; åœ¨uv__work_submitä¸­uv_onceæ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼š 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚çœ‹TLPI 31.2éƒ¨åˆ†ï¼Œlibuvå¤šåšäº†pthread_atforkçš„å¤„ç†ã€‚&emsp;&emsp;pthread_atforkæ³¨å†Œreset_onceå‡½æ•°ï¼Œåœ¨forkä¹‹åé‡ç½®onceï¼Œä¿è¯åœ¨libuvå¾ªç¯ä¸­å¦‚æœä½ forkäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œå¦‚æœåœ¨é‚£ä¸ªæ–°çš„è¿›ç¨‹ä¸­ä½ ä¹Ÿå¯åŠ¨ä¸€ä¸ªlibuvï¼Œinit_threads()èƒ½è¢«è°ƒç”¨ã€‚ init_threadsğŸ¤æ¡ä»¶å˜é‡&emsp;&emsp;libuvåˆå§‹åŒ–æ¡ä»¶å˜é‡æ—¶ï¼Œè°ƒç”¨è‡ªå·±çš„uv_cond_initï¼Œè¿™ä¸ªå‡½æ•°åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å°†æ¡ä»¶å˜é‡çš„æ—¶é’Ÿè®¾ç½®ä¸ºç›¸å¯¹æ—¶é—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å€¼å¾—æˆ‘ä»¬è‡ªå·±å†™ä»£ç æ—¶å‚è€ƒçš„ï¼Œç›¸å¯¹æ—¶é—´ä¸å—ç³»ç»Ÿæ—¶é—´çš„å½±å“ã€‚ 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; ğŸ¥›äº’æ–¥é”&emsp;&emsp;åˆå§‹åŒ–äº’æ–¥é”æ—¶ï¼Œè°ƒç”¨uv_mutex_initï¼Œåœ¨DEBUGæ—¶ï¼Œlibuvä¼šå°†äº’æ–¥é”è®¾ç½®ä¸ºPTHREAD_MUTEX_ERRORCHECKï¼Œè¿™æ ·èƒ½è‡ªæˆ‘æ£€æµ‹æ˜¯å¦ä¸ºæ­»é”ï¼Œä¸è¿‡è¿™ä¼šæ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚ 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. ğŸ¥¡ä¿¡å·é‡&emsp;&emsp;åˆå§‹åŒ–æ¯ä¸ªçº¿ç¨‹æ—¶ï¼Œlibuvç”¨ä¿¡å·é‡æ¥ä¿è¯init_threadså‡½æ•°åœ¨åˆå§‹åŒ–å®Œæ‰€æœ‰çº¿ç¨‹åé€€å‡ºã€‚ 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); åœ¨linuxä¸‹å¹¶ä¸”glibcç‰ˆæœ¬å¤§äº2.21æ—¶ï¼Œuv_sem_init(&amp;sem, 0)å’Œsem_init(&amp;sem, 0)æ˜¯ä¸€æ ·çš„ï¼Œæ²¡æœ‰é¢å¤–çš„å¤„ç†ã€‚çº¿ç¨‹åˆ›å»ºå¥½åï¼Œåœ¨workerå‡½æ•°ä¸­ä¼šè°ƒç”¨uv_sem_posté‡Šæ”¾ä¿¡å·é‡ã€‚ 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; ğŸ¥šuv_thread_create&emsp;&emsp;uv_thread_createåšçš„äº‹æƒ…å°±æ˜¯è®¾ç½®çº¿ç¨‹çš„stackå¤§å°ï¼Œç„¶ååˆ›å»ºå®ƒã€‚thread_stack_sizeå‡½æ•°è·å–æ ˆå¤§å°ï¼Œæœ‰ä¸€äº›æ˜¯è·¨å¹³å°å…¼å®¹æ€§çš„å¤„ç†ã€‚ 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); å’Œif (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; ä¸Šé¢ä¸¤è¡Œçš„é™åˆ¶æ˜¯æ¥æºäºpthread_attr_setstacksizeå‡½æ•°ï¼Œä¸€ä¸‹æ˜¯pthread_attr_setstacksizeå‡½æ•°manæ‰‹å†Œçš„ä¸€éƒ¨åˆ†ã€‚ ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif ğŸ˜‚æ— è¶£çš„æ˜¯åœ¨linux Ubuntusæˆ‘çš„ç¯å¢ƒä¸‹æµ‹è¯•æ—¶ï¼Œattrçš„é»˜è®¤stacksizeå’Œthread_stack_sizeå‡½æ•°è®¾ç½®åˆ°çš„æ˜¯ä¸€æ ·çš„å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘çš„æµ‹è¯•ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ2ï¼‰uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"å‰è¨€&emsp;&emsp;ä¸Šä¸€ç¯‡è¯´äº†ä¸€ä¸‹æ•´ä½“çš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºUV_RUN_DEFAULTæ¨¡å¼æ¥è°ƒç”¨uv_runæ¥è¯´ï¼Œuv__loop_aliveå°±å†³å®šäº†æ˜¯å¦é€€å‡ºï¼Œè¿™ä¸€ç¯‡çœ‹ä¸€ä¸‹uv__loop_aliveçš„æºç ã€‚ è¯¦æƒ…12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;å¯è§loopçš„çŠ¶æ€å–å†³äºä¸‰ä¸ªæ–¹é¢ï¼šhandlesã€reqsã€closing_handles handles&emsp;&emsp;uv__has_active_handleså°±æ˜¯æ£€æŸ¥loop-&gt;active_handleså€¼æ˜¯å¦å¤§äº0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handlesåˆ—è¡¨å¦‚ä¸Šã€‚handleåœ¨è°ƒç”¨æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ï¼Œå°±æ˜¯uv__handle_startã€‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å“ªäº›å‡½æ•°è°ƒç”¨äº†uv__handle_startã€‚æœ‰ä¸€äº›handleä¸åœ¨å…¶ä¸­ï¼Œå¯èƒ½ä¸å…¶è°ƒç”¨æ–¹å¼æœ‰å…³ï¼Œæˆ‘æš‚æ—¶æ— æ³•è§£é‡Š 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_startå‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨uv__active_handle_addï¼Œuv__active_handle_addå°±æ˜¯å°†loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;ç›¸åº”çš„åœ¨handleç»“æŸæ—¶æœ‰uv__active_handle_rmçš„è°ƒç”¨ï¼Œ(h)-&gt;loop-&gt;active_handleså‡ä¸€ã€‚ 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqså’Œhandleçš„é“ç†ä¸€æ ·ï¼Œæ˜¯æ£€æµ‹(loop)-&gt;active_reqs.count &gt; 0ã€‚active_reqsæ˜¯ä¸ªå…±ç”¨ä½“ï¼Œå®ƒçš„å¦ä¸€ä¸ªç”¨é€”æš‚æ—¶æˆ‘è¿˜ä¸çŸ¥é“ã€‚ 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)ç­‰åŒäºhandleçš„uv__active_handle_addã€‚uv__req_registeråœ¨uv__req_initä¸­è°ƒç”¨ï¼Œå‡ ä¹ï¼ˆæ¼ç½‘çš„æš‚æ—¶æ²¡æ³•è§£é‡Š ï¼‰æ¯ä¸ªreqåœ¨åˆå§‹åŒ–æ—¶éƒ½è°ƒç”¨äº†uv__req_initã€‚ 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;ä¸‹å›¾æ‰€ç¤ºæ˜¯é‚£äº›å‡½æ•°è°ƒç”¨äº†uv__req_initï¼Œç”±åç§°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥å®ƒä»¬æ˜¯å±äºå“ªäº›reqçš„ã€‚&emsp;&emsp;åŒç†ï¼Œè¿˜æœ‰uv__req_unregisterã€‚ 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;è¦å…³é—­çš„handleä¼šä»¥é“¾è¡¨çš„å½¢å¼æŒ‚åœ¨loop-&gt;closing_handlesä¸Šã€‚è¿™ä¸ªæ“ä½œé€šè¿‡è°ƒç”¨uv__make_close_pendingæ¥å®ç°ã€‚ 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; å¦‚æœclosing_handlesä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿˜éœ€è¦è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œå»è°ƒç”¨å…³é—­çš„handleçš„å›è°ƒå‡½æ•°ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ1ï¼‰äº‹ä»¶å¾ªç¯åˆ†æ","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"å‰è¨€ &emsp;&emsp;libuvæ€»æ˜¯æŠ¥å‡ºä¸€äº›è®©äººéš¾ä»¥ç†è§£çš„é”™è¯¯ğŸ˜‚ï¼Œä½œä¸ºä¸€ä¸ªCçš„é¡¹ç›®ï¼Œä¸å…·æœ‰Javaã€JavaScriptã€phpé‚£æ ·çš„äººæ°”ï¼Œå¾ˆéš¾ç™¾åº¦åˆ°ä¸€äº›é—®é¢˜çš„ç­”æ¡ˆï¼Œç”šè‡³googleä¹Ÿä¸è¡Œã€‚ä¸ºäº†ç”¨å¥½libuvï¼Œä¹Ÿä¸ºäº†å­¦ä¹ å§ã€‚æˆ‘å¼€å§‹çœ‹libuvçš„æºç ï¼Œä¸çŸ¥é“è‡ªå·±èƒ½èµ°å¤šè¿œã€‚ã€‚ã€‚ äº‹ä»¶å¾ªç¯ è¿™æ˜¯å®˜æ–¹äº‹ä»¶å¾ªç¯çš„ç¤ºæ„å›¾ã€‚é“¾æ¥-&gt;å®˜æ–¹å›¾ç‰‡ä½ç½® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;æ•´ä¸ªäº‹ä»¶å¾ªç¯å°±æ˜¯åœ¨ä¸»çº¿ç¨‹çš„uv_runï¼ˆï¼‰è°ƒç”¨ä¸­æ‰§è¡Œçš„ã€‚æˆ‘å°±è·Ÿç€å®˜æ–¹çš„ä»‹ç»ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼ˆå®˜æ–¹ä»‹ç»ï¼‰ã€‚ ç¬¬ä¸€æ­¥ The loop concept of â€˜nowâ€™ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;ç¬¬ä¸€æ­¥æ˜¯æ›´æ–°æ—¶é—´ã€‚å¯¹åº”ä»£ç å¦‚ä¸‹ï¼š 1uv__update_time(loop); &emsp;&emsp;æ€»ç»“æ¥è¯´å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ›´æ–°æ—¶é—´ã€‚uv__update_timeå®ç°æˆ‘ä¸‹ä¸€ç¯‡æ¥ä»‹ç» ç¬¬äºŒæ­¥ If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and refâ€™d handles, active requests or closing handles itâ€™s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;ç”¨uv__loop_aliveå‡½æ•°è·å–loopçŠ¶æ€ã€‚&emsp;&emsp;å¦‚æœuv__loop_aliveè¿”å›é›¶æˆ–è€…loop-&gt;stop_flag == 1è¯´æ˜loopç»ˆæ­¢ï¼Œç›´æ¥è·³è¿‡å¾ªç¯ï¼Œåˆ°ä»£ç æœ€ä¸‹é¢ï¼ˆè¿™é‡Œæœ‰ä¸€äº›æ€§èƒ½çš„å¤„ç†æš‚æ—¶ä¸ç®¡ ï¼‰ï¼Œé€€å‡ºï¼š 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0çš„ä¸€ä¸ªæ¥æºæ˜¯è°ƒç”¨äº†uv_stopï¼Œè¿™ä¸ªå‡½æ•°åœ¨æ‰‹å†Œä¸­çœ‹è§ã€‚å®ƒçš„æºä»£ç ä¹Ÿå¾ˆæ¸…æ™°ã€‚ 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;å¦‚æœloopçŠ¶æ€OKï¼Œé‚£ä¹ˆå°±è¿›å…¥å¾ªç¯ä¸­ã€‚ ç¬¬ä¸‰æ­¥ Due timers are run. All active timers scheduled for a time before the loopâ€™s concept of now get their callbacks called. &emsp;&emsp;å¯¹åº”ä»£ç è¿™ä¸€éƒ¨åˆ†ï¼š 1234567891011121314151617181920uv__run_timers(loop);å…¶å®ç°ï¼švoid uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;å°†å †é‡Œé¢å·²ç»è¶…æ—¶çš„æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬å››æ­¥ Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. å¯¹åº”ï¼š 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);å…¶å®ç°ï¼šstatic int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;å°†loop-&gt;pending_queueä¸­çš„ä»»åŠ¡æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬äº”ã€å…­ã€ä¹æ­¥ 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;è¿™ä¸‰éƒ¨ä¸ºä»€ä¹ˆè¦ä¸€èµ·è¯´å‘¢ï¼Ÿå› ä¸ºå®ƒä»¬çš„å®è´¨æ˜¯ä¸€æ ·çš„ã€‚åœ¨æ¯æ¬¡å¾ªç¯å›ºå®šçš„ä½ç½®è°ƒç”¨ã€‚&emsp;&emsp;è¿™ä¸‰ä¸ªå‡½æ•°å®šä¹‰åœ¨loop-watcher.cè¿™ä¸ªæ–‡ä»¶é‡Œé¢ï¼Œå®ƒä»¬æ˜¯ç”¨å®å®šä¹‰å®šä¹‰çš„ã€‚åªæ”¹äº†idleã€prepareã€checkè¿™ä¸‰ä¸ªåå­—çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†å‡½æ•°éƒ½æ˜¯ä¸€æ ·çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) ç¬¬ä¸ƒæ­¥ Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;è¿™éƒ¨åˆ†æ˜¯å–å†³äºuv_runçš„æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼Œæš‚æ—¶ä¸ç»†çœ‹ã€‚ ç¬¬å…«æ­¥ The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯¹äºä¸åŒæ“ä½œç³»ç»Ÿæœ‰æ‰€ä¸åŒï¼Œlinuxæ˜¯pollï¼Œmacæ˜¯kqueueã€‚ ç¬¬åæ­¥ Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;è°ƒç”¨å„ç±»çš„closeå›è°ƒå‡½æ•°ã€‚ ç¬¬åä¸€ã€åäºŒæ­¥ 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. Itâ€™s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if itâ€™s still alive, otherwise it will also end. &emsp;&emsp;å¯¹äºuv_runä¸åŒæ¨¡å¼çš„ä¸€ç‚¹ç‰¹æ®Šå¤„ç†ã€‚ 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; å°ç»“&emsp;&emsp;å®è§‚ä¸Šæ¢³ç†ä¸€ä¸‹æ•´ä¸ªäº‹ä»¶å¾ªç¯çš„è¿‡ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]}]}