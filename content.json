{"meta":{"title":"lurenaaã®blog","subtitle":"","description":"","author":"ä¸¤å¤©å®‡å®™äºº","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-21T19:53:41.634Z","updated":"2019-11-21T19:53:41.634Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 Not Found **å¾ˆæŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„é¡µé¢ä¸å­˜åœ¨** å¯èƒ½æ˜¯è¾“å…¥åœ°å€æœ‰è¯¯æˆ–è¯¥åœ°å€å·²è¢«åˆ é™¤"},{"title":"å…³äº","date":"2020-01-22T12:56:46.590Z","updated":"2020-01-22T12:56:46.590Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"é‡åº†é‚®ç”µå¤§å­¦çš„å’¸é±¼å¤§å­¦ç”Ÿçš„åšå®¢è®°å½•ï¼Œèœåˆ°å¯æ€œï¼ŒçœŸçš„å¯æƒœğŸ”"},{"title":"æ‰€æœ‰åˆ†ç±»","date":"2019-11-21T19:52:14.465Z","updated":"2019-11-21T19:52:14.465Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:51:06.685Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"&emsp;ğŸ…æ—§CSDNåšå®¢"},{"title":"","date":"2019-11-21T19:53:01.465Z","updated":"2019-11-21T19:53:01.465Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"projects","date":"2019-11-21T19:32:31.000Z","updated":"2020-01-22T12:49:21.826Z","comments":true,"path":"projects/index.html","permalink":"http://yoursite.com/projects/index.html","excerpt":"","text":"&emsp;ğŸºsmpHttp ä¸€ä¸ªåŸºäºlibuvçš„C++ httpåº“ &emsp;ğŸ»Algorithms ã€Šç®—æ³•ç¬¬4ç‰ˆã€‹çš„C++ä»£ç å®ç°"},{"title":"æ‰€æœ‰æ ‡ç­¾","date":"2019-11-21T19:52:40.413Z","updated":"2019-11-21T19:52:40.413Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"å½’æ¡£","date":"2020-01-22T13:44:19.251Z","updated":"2020-01-22T13:44:19.251Z","comments":true,"path":"blog/archives/index.html","permalink":"http://yoursite.com/blog/archives/index.html","excerpt":"","text":"æ ‡ç­¾åˆ†ç±»ç›®å½•&emsp;ğŸºç®—æ³•&emsp;ğŸ¶LeetCode&emsp;ğŸ±é‡è§çš„é—®é¢˜&emsp;ğŸ­Libuv&emsp;ğŸ¹raxæºç é˜…è¯»&emsp;ğŸ ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°"}],"posts":[{"title":"å¦‚ä½•è®©äº‘æœåŠ¡ä¸Šçš„ç¨‹åºåœ¨ç”¨æˆ·é€€å‡ºåç»§ç»­è¿è¡Œï¼Ÿ","slug":"problems10","date":"2020-03-04T12:49:40.000Z","updated":"2020-03-07T12:50:14.837Z","comments":true,"path":"2020/03/04/problems10/","link":"","permalink":"http://yoursite.com/2020/03/04/problems10/","excerpt":"","text":"ä»Šå¤©çš„ä¸»è§’ï¼šnohupï¼ˆno hang upï¼‰baseï¼šç®€å•çš„åå°è¿è¡Œï¼š 1nohup command &amp; å°±å¯ä»¥äº†ã€‚ æ·»åŠ æ—¥å¿—ï¼š1nohup command &gt; file 2&gt;&amp;1 &amp; é¦–å…ˆæˆ‘ä»¬è¦çŸ¥é“0ã€1ã€2æ˜¯ä¸‰ä¸ªå›ºå®šçš„filenoã€‚ 1230 â€“ stdin (standard input)1 â€“ stdout (standard output)2 â€“ stderr (standard error) é¦–å…ˆè¿™é‡ŒæŠŠcommandçš„è¾“å‡ºé‡å®šå‘åˆ°fileï¼Œå†æŠŠæ ‡å‡†é”™è¯¯é‡å®šå‘åˆ°æ ‡å‡†è¾“å‡ºï¼Œè¿™æ ·æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯éƒ½é‡å®šå‘åˆ°äº†fileä¸­äº†ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å¦‚ä½•è§£å†³basic_string::_M_createé”™è¯¯ï¼Ÿ","slug":"problems7","date":"2020-03-03T14:08:43.000Z","updated":"2020-03-03T14:26:19.209Z","comments":true,"path":"2020/03/03/problems7/","link":"","permalink":"http://yoursite.com/2020/03/03/problems7/","excerpt":"","text":"ğŸ‘½åŸå› &emsp;&emsp;åŸå› åœ¨äºä½¿ç”¨string(iter1, iter2)è¿™ä¸ªæ„é€ å‡½æ•°æ—¶ï¼Œiter1&gt;iter2ã€‚ å³ï¼š å­—ç¬¦ä¸²æ„é€ å¤±è´¥ã€‚ 12345678910111213141516#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; try&#123; string s(\"abc\"); string::const_iterator ie = s.cbegin() + 1, ia = s.cbegin() ; string as = string(ie, ia); &#125;catch(exception&amp; e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125; ğŸ‘ºç”±æ¥ï¼ˆåºŸè¯ ï¼‰&emsp;&emsp;æœ€è¿‘åœ¨æŒ‚æœåŠ¡å™¨çš„æ—¶å€™ç»å¸¸é‡è§ä¸€ä¸ªè«åçš„å´©æºƒåŸå› ï¼šbasic_string::Mcreateã€‚ä¸ç®¡æ˜¯ç™¾åº¦è¿˜æ˜¯googleæ€»æ˜¯æ‰¾ä¸åˆ°ç›¸å…³çš„é—®é¢˜ï¼Œåœ¨stackflowä¸Šä¹Ÿæ²¡èƒ½æ‰¾åˆ°åˆç†çš„ç­”æ¡ˆï¼Œstackflowä¸Šå”¯ä¸€ä¸€ä¸ªç›¸å…³é—®é¢˜æ˜¯ä¸mysqlç›¸å…³çš„ï¼Œå› ä¸ºæˆ‘ä¹Ÿä½¿ç”¨äº†mysqlçš„æ¥å£ï¼Œè®©æˆ‘ä¸ç¦è§‰å¾—è¿™ä¸ªé—®é¢˜æ¥è‡ªäºmysqlçš„æ’ä»¶ï¼Œæœ€åæˆ‘å‘ç°é—®é¢˜åœ¨äºæˆ‘è‡ªå·±å†™çš„Httpè§£æç»„ä»¶ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"åŠ¨æ€è§„åˆ’","slug":"alg9","date":"2020-03-03T02:24:01.000Z","updated":"2020-03-04T07:25:34.469Z","comments":true,"path":"2020/03/03/alg9/","link":"","permalink":"http://yoursite.com/2020/03/03/alg9/","excerpt":"","text":"ğŸ‘ºåŠ¨æ€è§„åˆ’å®šä¹‰ åŠ¨æ€è§„åˆ’åœ¨å¯»æ‰¾æœ‰å¾ˆå¤šé‡å å­é—®é¢˜çš„æƒ…å†µçš„æœ€ä½³è§£æ—¶æœ‰æ•ˆã€‚å®ƒå°†é—®é¢˜é‡æ–°ç»„åˆæˆå­é—®é¢˜ã€‚ä¸ºäº†é¿å…å¤šæ¬¡è§£å†³è¿™äº›å­é—®é¢˜ï¼Œå®ƒä»¬çš„ç»“æœéƒ½é€æ¸è¢«è®¡ç®—å¹¶è¢«å‚¨å­˜ï¼Œä»ç®€å•çš„é—®é¢˜ç›´åˆ°æ•´ä¸ªé—®é¢˜éƒ½è¢«è§£å†³ã€‚å› æ­¤ï¼ŒåŠ¨æ€è§„åˆ’å‚¨å­˜é€’è¿´æ—¶çš„ç»“æœï¼Œå› è€Œä¸ä¼šåœ¨è§£å†³åŒæ ·çš„é—®é¢˜æ—¶èŠ±è´¹æ—¶é—´ã€‚ ğŸ¤¡åŠ¨æ€è§„åˆ’æ­ªè§£æˆ‘ä»¬å…ˆè®¡ç®—1+1+1+1+1+1+1+1+1+1ç­‰äºå¤šå°‘ã€‚é€šè¿‡è®¡ç®—ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ä¸Šé¢é‚£ä¸ªå¼å­ç­‰äº10ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ä¸Šé¢é‚£ä¸ªå¼å­çš„å·¦è¾¹å†åŠ ä¸Šä¸€ä¸ª1+å‘¢ï¼Ÿæˆ‘ä»¬ä¸ç”¨ç”¨æ‰‹è®¡ç®—å°±å¯ä»¥ç›´æ¥çŸ¥é“ç­‰äº11.å› ä¸ºæˆ‘ä»¬çŸ¥é“äº†&emsp;&emsp;1+ä¸Šé¢é‚£ä¸ªå¼å­&emsp;&emsp;è€Œè¿™ä¸ªç»“æ„ä¸­ï¼Œé‚£ä¸ªå¼å­ç»“æœç­‰äº10ï¼Œæˆ‘ä»¬è®°å¿†ä½äº†ï¼Œé¿å…äº†é‡å¤è®¡ç®—ã€‚è¿™å°±æ˜¯åŠ¨æ€è§„åˆ’ã€‚ ğŸ§‘â€åŠ¨æ€è§„åˆ’æ­¥éª¤ å»ºç«‹çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼ˆæœ€éš¾ä¹Ÿæ˜¯æœ€é‡è¦çš„ä¸€æ­¥ï¼‰ ç¼“å­˜å¹¶å¤ç”¨ä»¥å¾€ç»“æœ æŒ‰é¡ºåºä»å°å¾€å¤§ç®—ï¼ˆè‡ªåº•å‘ä¸Šï¼‰ ğŸ¥¶ä¸ªäººç†è§£æ€»ç»“æ¥è¯´ï¼ŒåŠ¨æ€è§„åˆ’å…·æœ‰æœ€ä¼˜å­ç»“æ„å’Œé‡å å­é—®é¢˜çš„ç‰¹ç‚¹ï¼Œ åŠ¨æ€è§„åˆ’çš„é—®é¢˜ä¸€èˆ¬éƒ½å’Œé€’å½’æœ‰ç›¸å…³æ€§ï¼Œå¹¶ä¸”åŠ¨æ€è§„åˆ’èƒ½å¤Ÿä¼˜åŒ–é€’å½’ï¼Œå‡å°‘é‡å¤çš„è®¡ç®—é‡ã€‚ä¹Ÿå°±æ˜¯é€’å½’+å¤‡å¿˜å½•è®°å½•å€¼çš„æ•ˆæœã€‚ ä»å¦ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œå…¶å®å¯ä»¥è¯´æ¯ä¸€ä¸ªåŠ¨æ€è§„åˆ’é—®é¢˜éƒ½å¯ä»¥ç”¨é€’å½’æ¥è§£å†³ï¼Œå› ä¸ºåŠ¨æ€è§„åˆ’æ˜¯é€’å½’çš„ä¸€ç§ä¼˜åŒ–ï¼Œå‰Šå‡äº†å¯¹äºåŒä¸€ä¸ªå­é—®é¢˜çš„é‡å¤è®¡ç®—æ‰€æµªè´¹çš„æ—¶é—´ã€‚ ã€Šå‰‘æŒ‡offerã€‹ä¸­æœ‰å¥è¯æ€»ç»“çš„å¥½ï¼šé€šå¸¸åº”ç”¨åŠ¨æ€è§„åˆ’è§£å†³é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬éƒ½æ˜¯ç”¨é€’å½’çš„æ€è·¯æ¥åˆ†æé—®é¢˜çš„ã€‚ ğŸ¶è´ªå¿ƒç®—æ³•ä¸åŠ¨æ€è§„åˆ’è´ªå¿ƒç®—æ³•ç€çœ¼äºå½“å‰é˜¶æ®µçš„æœ€ä¼˜è§£ï¼Œå¹¶ä¸”æœŸæœ›è¿™æ ·ä¸‹æ¥å¾—åˆ°çš„ç»“æœæ˜¯å…¨å±€çš„æœ€ä¼˜è§£ï¼ˆå®é™…ä¸Šæœªå¿…æ˜¯ï¼‰ã€‚ç›¸æ¯”äºåŠ¨æ€è§„åˆ’æœ‰ä¸€å®šçš„å›ºå®šæ¨¡å¼æ¥è¯´ï¼Œè´ªå¿ƒæ›´åå‘æ˜¯ä¸€ç§æ€æƒ³ã€‚ åŠ¨æ€è§„åˆ’æ˜¯è®¡ç®—äº†æ‰€æœ‰å­é—®é¢˜çš„æœ€ä¼˜è§£ï¼Œåœ¨æœ€åé€šè¿‡ä¸Šå±‚æ¥ç›´æ¥è·å–å…¨å±€æœ€ä¼˜è§£ã€‚å³åŠ¨æ€è§„åˆ’åœ¨è®¡ç®—å­é—®é¢˜æ—¶æ˜¯æ²¡æœ‰åå¥½çš„ï¼Œå®ƒä¼šè®¡ç®—æ‰€æœ‰çš„å­é—®é¢˜ã€‚è€Œè´ªå¿ƒç®—æ³•ï¼Œå› ä¸ºè´ªå¿ƒï¼ŒåŒæ ·çš„å­é—®é¢˜ä»–åªä¼šè®¡ç®—æœ€å¤§ï¼ˆä¼˜ï¼‰çš„ä¸€ä¸ªã€‚ è´ªå¿ƒç®—æ³•æ˜¯æ¯ä¸€æ­¥åªé€‰æœ€ä¼˜çš„ï¼Œå¹¶ä¸”æœŸæœ›æ¯ä¸€æ­¥é€‰æ‹©çš„æœ€ä¼˜è§£èƒ½è¾¾æˆå…¨å±€çš„æœ€ä¼˜è§£ï¼Œè¯´å®è¯è¿™å¤ªéš¾äº†ï¼Œå› ä¸ºä¸€èˆ¬ä¸€ä¸ªé—®é¢˜çš„é€‰æ‹©éƒ½ä¼šå½±å“ä¸‹ä¸€ä¸ªé—®é¢˜çš„é€‰æ‹©ï¼Œé™¤éå­é—®é¢˜ä¹‹é—´å®Œå…¨ç‹¬ç«‹ï¼Œæ²¡æœ‰å…³è”ï¼Œæ¯”å¦‚å‡‘é›¶é’±çš„ä¾‹å­ï¼Œ å¦‚æœä¸€ä¸ªå›½å®¶çš„é’ç¥¨æ¯”è¾ƒå¥‡è‘©ï¼Œåªæœ‰ 1ï¼Œ5ï¼Œ11 è¿™ä¸‰ç§é¢å€¼çš„é’ç¥¨ï¼Œå¦‚ä½•ç”¨æœ€å°‘çš„é’ç¥¨å‡‘å‡º 15 å‘¢ï¼Œå¦‚æœç”¨è´ªå¿ƒç¬¬ä¸€æ¬¡é€‰ 11ï¼Œ é‚£ä¹‹ååªèƒ½é€‰ 4 å¼  1 äº†ï¼Œå³ 15 = 1 x 11 + 4 x1ã€‚å…¶å®æœ€ä¼˜è§£åº”è¯¥æ˜¯ 3 å¼  5 å…ƒçš„é’ç¥¨ï¼Œä¸ºå•¥è¿™ç§æƒ…å†µä¸‹ç”¨è´ªå¿ƒä¸é€‚ç”¨å‘¢ï¼Œå› ä¸ºç¬¬ä¸€æ¬¡é€‰äº† 11ï¼Œå½±å“äº†åé¢é’ç¥¨çš„é€‰æ‹©ï¼Œä¹Ÿå°±æ˜¯è¯´å­é—®é¢˜ä¹‹é—´å¹¶ä¸æ˜¯ç‹¬ç«‹çš„ï¼Œè€Œæ˜¯äº’ç›¸åˆ¶çº¦ï¼Œäº’æœ‰å½±å“çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰è´ªå¿ƒçš„æ—¶å€™ä¸€å®šè¦æ³¨æ„å®ƒçš„é€‚ç”¨åœºæ™¯ã€‚","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"æ’åºç®—æ³•æ¢³ç†","slug":"alg8","date":"2020-02-25T12:02:33.000Z","updated":"2020-03-03T14:47:08.729Z","comments":true,"path":"2020/02/25/alg8/","link":"","permalink":"http://yoursite.com/2020/02/25/alg8/","excerpt":"","text":"ğŸ¶å†’æ³¡æ’åº1234567891011121314151617181920212223/** * &lt;å†’æ³¡æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n) æœ€åO(n^2) å¹³å‡O(n^2) ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(1) (5) 2 3 4 2 1 0 2 (5) 3 4 2 1 0 2 3 (5) 4 2 1 0 2 3 4 (5) 2 1 0 2 2 3 4 (5) 1 0 1 2 2 3 4 (5) 0 0 1 2 2 3 4 (5) */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; for(int i = 0; i &lt; nums.size(); ++i) for(int j = i + 1; j &lt; nums.size(); ++j) &#123; if(nums[i] &gt; nums[j]) swap(nums[i], nums[j]); &#125; return nums; &#125;&#125;; ğŸ™ˆé€‰æ‹©æ’åº1234567891011121314151617/** * &lt;é€‰æ‹©æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n^2) æœ€åO(n^2) å¹³å‡O(n^2) ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(1) */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; for(int i = 0; i &lt; nums.size(); ++i) &#123; int _min = i; for(int j = i + 1; j &lt; nums.size(); ++j) if(nums[j] &lt; nums[_min]) _min = j; swap(nums[_min], nums[i]); &#125; return nums; &#125;&#125;; ğŸ‘ºæ’å…¥æ’åº1234567891011121314/** * &lt;æ’å…¥æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n) æœ€åO(n^2) å¹³å‡O(n^2) ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(1) */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; for(int i = 1; i &lt; nums.size(); ++i) for(int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) swap(nums[j-1], nums[j]); return nums; &#125;&#125;; ğŸƒå¸Œå°”æ’åº123456789101112131415161718192021/** * &lt;å¸Œå°”æ’åº&gt; / &lt;ç¼©å°å¢é‡æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: å¹³å‡O(n^1.3) ä¸ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(1) * ç‰¹ç‚¹: ç¼©å°å¢é‡çš„æ’å…¥æ’åº */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int h = 1; while(h &lt; nums.size() / 3) h = h * 3 + 1; while(h &gt;= 1) &#123; for(int i = h; i &lt; nums.size(); i+= h) &#123; for(int j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h) swap(nums[j], nums[j - h]); &#125; h = h / 3; &#125; return nums; &#125;&#125;; ğŸ‘©â€ğŸš’å½’å¹¶æ’åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * &lt;å½’å¹¶æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n*log(n)) æœ€åO(n*log(n)) å¹³å‡O(n*log(n)) ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(n) */class Solution &#123;public: vector&lt;int&gt; aux; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; aux.resize(nums.size()); _sortArray(nums, 0, nums.size() - 1); return nums; &#125; void _sortArray(vector&lt;int&gt;&amp; nums, int lo, int hi) &#123; if(hi &lt;= lo) return ; int mid = lo + (hi - lo) / 2; _sortArray(nums,lo ,mid); _sortArray(nums, mid + 1, hi); merge(nums, lo, mid, hi); &#125; void merge(vector&lt;int&gt;&amp; nums, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for(int k = lo; k &lt;= hi; ++k) aux[k] = nums[k]; for(int k = lo; k &lt;= hi; ++k) &#123; if(i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; else if (aux[i] &lt; aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; &#125; &#125;&#125;;//è‡ªåº•å‘ä¸Šclass Solution &#123;public: vector&lt;int&gt; aux; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; aux.resize(nums.size()); for(int sz = 1; sz &lt; nums.size(); sz = 2 * sz) for(int lo = 0; lo &lt; nums.size(); lo += sz + sz) merge(nums, lo, lo + sz - 1, min(lo + sz + sz - 1, (int)nums.size() - 1)); return nums; &#125; void merge(vector&lt;int&gt;&amp; nums, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for(int k = lo; k &lt;= hi; ++k) aux[k] = nums[k]; for(int k = lo; k &lt;= hi; ++k) &#123; if(i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; else if (aux[i] &lt; aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; &#125; &#125;&#125;; ğŸ§‘â€å¿«é€Ÿæ’åº123456789101112131415161718192021222324252627282930313233/** * &lt;å¿«é€Ÿæ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n*log(n)) æœ€åO(n^2) å¹³å‡O(n*log(n)) ä¸ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(log(n)) * ç‰¹ç‚¹: æœ¬è´¨æ˜¯ç»™åŸºå‡†æ•°æ‰¾å…¶æ­£ç¡®ä½ç½®çš„è¿‡ç¨‹. */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; sort(nums, 0, nums.size() - 1); return nums; &#125; void sort(vector&lt;int&gt;&amp; nums, int lo, int hi) &#123; if(lo &gt;= hi) return ; int k = parti(nums, lo, hi); sort(nums, lo, k - 1); sort(nums, k + 1, hi); &#125; int parti(vector&lt;int&gt;&amp; nums, int lo, int hi) &#123; int lf = lo, rt = hi + 1; int v = nums[lo]; while(true) &#123; while(nums[++lf] &lt;= v) if(lf == hi) break; while(nums[--rt] &gt;= v) if(rt == lo) break; if(lf &gt;= rt) break; swap(nums[lf], nums[rt]); &#125; swap(nums[lo], nums[rt]); return rt; &#125;&#125;; ğŸ¸å †æ’åº12345678910111213141516171819202122232425262728293031323334353637/** * &lt;å †æ’åº&gt; * æ—¶é—´å¤æ‚åº¦: æœ€å¥½O(n*log(n)) æœ€åO(n*log(n)) å¹³å‡O(n*log(n)) ä¸ç¨³å®š * ç©ºé—´å¤æ‚åº¦: O(1) */class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int N = nums.size(); nums.insert(nums.begin(), 0); // for(int i = N / 2; i &gt;= 1; --i) // sink(nums, i, N); for(int i = 1; i &lt;= N; ++i) swim(nums, i ,N); while(N &gt; 1) &#123; swap(nums[1], nums[N--]); sink(nums, 1, N); &#125; nums.erase(nums.begin()); return nums; &#125; void sink(vector&lt;int&gt;&amp; nums, int i, int N) &#123; while(i &lt;= N / 2) &#123; int k = i * 2; if(k + 1 &lt;= N &amp;&amp; nums[k] &lt; nums[k + 1]) k = k + 1; if(nums[i] &gt;= nums[k]) break; swap(nums[k], nums[i]); i = k; &#125; &#125; void swim(vector&lt;int&gt;&amp; nums, int i, int N) &#123; while(i &gt; 1 &amp;&amp; nums[i] &gt;= nums[i / 2]) &#123; swap(nums[i], nums[i / 2]); i /= 2; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"äºŒåˆ†æŸ¥æ‰¾çš„ç»†èŠ‚æ€»ç»“","slug":"alg7","date":"2020-02-18T09:04:51.000Z","updated":"2020-02-20T14:31:46.062Z","comments":true,"path":"2020/02/18/alg7/","link":"","permalink":"http://yoursite.com/2020/02/18/alg7/","excerpt":"","text":"ğŸ¶ç»“æ„1è¾¨æ&emsp;&emsp;è¿™é‡Œä»‹ç»ç¬¬ä¸€ç§ç»“æ„ 123456789101112function binary_search(A, n, T) is L := 0 R := n âˆ’ 1 while L â‰¤ R do m := floor((L + R) / 2) if A[m] &lt; T then L := m + 1 else if A[m] &gt; T then R := m - 1 else: return m return unsuccessful &emsp;&emsp;è¿™é‡Œm := floor((L + R) / 2)æœ‰æ—¶ä¼šæ›¿æ¢æˆm := ceiling((L + R) / 2)ï¼Œç®€å•æ¥è¯´å°±æ˜¯(L + R) / 2æ›¿æ¢æˆ(L + R + 1) / 2ã€‚ &emsp;&emsp;åœ¨ä»¥ä¸Šç»“æ„ä¸­è¿™ä¸ªè¯­å¥çš„æ›¿æ¢ä¸ä¼šå½±å“ç®—æ³•çš„æ­£ç¡®æ€§ã€‚ä¸è¿‡åœ¨ç›®æ ‡Tåœ¨æ•°ç»„Aä¸­æœ‰å¤šä¸ªçš„æ—¶å€™ï¼Œå¯èƒ½ä¼šå½±å“åˆ°åº•è¿”å›å¤šä¸ªTä¸­çš„å“ªä¸€ä¸ªã€‚ &emsp;&emsp;æ¯”å¦‚[1 2 2 2 3 4]ï¼Œåœ¨flooræ—¶è¿”å›çš„ä¸‹æ ‡æ˜¯2ï¼Œåœ¨ceilingæ—¶è¿”å›çš„ä¸‹æ ‡æ˜¯3. ğŸ¦Šä¼˜åŒ–1&emsp;&emsp;è¿™é‡Œæœ‰ä¸€ä¸ªå¯ä»¥å°ä¼˜åŒ–çš„åœ°æ–¹ï¼ŒL+Rå­˜åœ¨æ•´å½¢æº¢å‡ºçš„æƒ…å†µï¼Œå¯ä»¥æ”¹ä¸ºL + ï¼ˆR - L) / 2é¿å…æº¢å‡ºé—®é¢˜ã€‚ ğŸ¹ç»“æ„2è¾¨æ&emsp;&emsp;è¿™å…¶å®ä¹Ÿæ˜¯ä¸€ç§ä¼˜åŒ–ï¼Œå› ä¸ºä»¥ä¸Šç»“æ„ä¸­åœ¨æ¯ä¸ªå¾ªç¯ä¸­æ¯”è¾ƒæ¬¡æ•°å¤ªå¤šï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹ç»“æ„æ¥ä»£æ›¿ã€‚ 123456789101112function binary_search_alternative(A, n, T) is L := 0 R := n âˆ’ 1 while L != R do m := ceil((L + R) / 2) if A[m] &gt; T then R := m - 1 else: L := m if A[L] = T then return L return unsuccessful æˆ–è€… 123456789101112function binary_search_alternative(A, n, T) is L := 0 R := n âˆ’ 1 while L != R do m := floor((L + R) / 2) if A[m] &lt; T then L := m + 1 else: R := m if A[L] = T then return L return unsuccessful &emsp;&emsp;ä»¥ä¸Šä¸¤ç§ç»“æ„å¯ä»¥åœ¨æ¯æ¬¡å¾ªç¯ä¸­å‡å°‘ä¸€æ¬¡çš„æ¯”è¾ƒã€‚ &emsp;&emsp;å¹¶ä¸”å€¼çš„æ³¨æ„çš„æ˜¯ä»¥ä¸‹ä¸¤ç§ç»“æ„æ˜¯é”™è¯¯çš„ï¼š 123456789101112ğŸ‘¿function binary_search_alternative(A, n, T) is L := 0 R := n âˆ’ 1 while L != R do m := ceil((L + R) / 2) if A[m] &lt; T then L := m + 1 else: R := m if A[L] = T then return L return unsuccessful å‡è®¾åœ¨[2 3 4]ä¸­æŸ¥æ‰¾2ï¼Œ ç¬¬ä¸€è¶Ÿï¼š L = 0 R = 5 m = 1 A[m] &gt; T ç¬¬äºŒè¶Ÿ: L = 0 R = 1 m = 1 A[m] &gt; T ç¬¬ä¸‰è¶Ÿï¼šL = 0 R = 1 m = 1 A[m] &gt; T â€¦ ç¬¬Nè¶Ÿï¼šL = 0 R = 1 m = 1 A[m] &gt; T è¿™é‡Œä¼šå¯¼è‡´æ— çº¿å¾ªç¯ï¼Œå› ä¸ºceilingå–ä¸Šé™ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†må–åœ¨å³è¾¹ï¼Œå¯¼è‡´åŒºé—´åœ¨å·¦è¾¹æ²¡æ³•æ”¶æ•›ã€‚ åŒç†ï¼Œä¸‹é¢ç»“æ„ä¹Ÿæ˜¯é”™è¯¯çš„ï¼š 123456789101112ğŸ‘¿function binary_search_alternative(A, n, T) is L := 0 R := n âˆ’ 1 while L != R do m := floor((L + R) / 2) if A[m] &gt; T then R := m - 1 else: L := m if A[L] = T then return L return unsuccessful å¯ä»¥[2 3 4]ä¸­æŸ¥æ‰¾4æ¥è¯•è¯•ã€‚ ğŸ™ˆç»“æ„3è¾¨æ&emsp;&emsp;åœ¨å­˜åœ¨é‡å¤å…ƒç´ çš„æ—¶å€™ï¼Œç©¶ç«Ÿè¯¥è¿”å›å“ªä¸€ä¸ªå‘¢ï¼Ÿæ¯”å¦‚[1,2,4,4,4,5,6,7]æŸ¥æ‰¾4ï¼Œæ˜¯è¿”å›2è¿˜æ˜¯3ï¼Œæˆ–è€…4ï¼Ÿ &emsp;&emsp;ä¸‹é¢è¿™æ ·ä¸€ä¸ªç»“æ„å¯ä»¥è¿”å›æœ€å·¦è¾¹çš„å…ƒç´ ï¼š 12345678910function binary_search_leftmost(A, n, T): L := 0 R := n while L &lt; R: m := floor((L + R) / 2) if A[m] &lt; T: L := m + 1 else: R := m return L åœ¨æ‰¾åˆ°å…ƒç´ åï¼Œä¾æ—§ä¼šé€šè¿‡R = må‘å·¦è¾¹æ”¶ç¼©ã€‚ &emsp;&emsp;ä¸‹é¢è¿™æ ·ä¸€ä¸ªç»“æ„å¯ä»¥è¿”å›æœ€å³è¾¹çš„å…ƒç´ ï¼š 12345678910function binary_search_rightmost(A, n, T): L := 0 R := n while L &lt; R: m := floor((L + R) / 2) if A[m] &lt;= T: L := m + 1 else: R := m return R - 1 åœ¨æ‰¾åˆ°å…ƒç´ åï¼Œä¾æ—§ä¼šé€šè¿‡left = m + 1å‘å³è¾¹æ”¶ç¼©ã€‚","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"å¦‚æœè§£å†³â€œcorrupted size vs. prev_sizeâ€é—®é¢˜ï¼Ÿ","slug":"problems5","date":"2020-02-13T06:36:11.000Z","updated":"2020-02-13T06:41:04.618Z","comments":true,"path":"2020/02/13/problems5/","link":"","permalink":"http://yoursite.com/2020/02/13/problems5/","excerpt":"","text":"ğŸ“£ åœ¨C++ä¸­æˆ‘ä»¬æ—¶å¸¸ä¼šé‡è§â€œcorrupted size vs. prev_sizeâ€çš„æŠ¥é”™ï¼Œå®ƒçš„åŸå› åœ¨äºå†…å­˜è¶Šç•Œï¼Œå…¶å®è§£å†³è¿™ä¸ªé—®é¢˜çš„åŠæ³•åœ¨äºä½¿ç”¨vectoræ¥ä»£æ›¿è‡ªå·±ç”³è¯·å†…å­˜ï¼Œå¹¶ä¸”ä½¿ç”¨ä»¥ä¸‹ä¸¤ç§æ–¹æ³•æ¥è®¿é—®å…ƒç´ ï¼š ä½¿ç”¨è¿­ä»£å™¨ ä½¿ç”¨at å°½é‡è¦é¿å…ä½¿ç”¨[]æ¥è®¿é—®vectorï¼Œè¶Šç•Œçš„æ—¶å€™å¾ˆéš¾æ‰¾åˆ°é”™è¯¯çš„åœ°æ–¹ï¼Œä½¿ç”¨atå¸¦æœ‰è¶Šç•Œçš„æ£€æŸ¥ï¼Œæ›´ä¸ºå®‰å…¨ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å¦‚ä½•å¼€å¯ubuntusçš„core_dumpï¼Ÿ","slug":"problems6","date":"2020-02-03T14:07:29.000Z","updated":"2020-03-03T14:09:12.960Z","comments":true,"path":"2020/02/03/problems6/","link":"","permalink":"http://yoursite.com/2020/02/03/problems6/","excerpt":"","text":"1vim /etc/profile ç„¶åï¼Œåœ¨å…¶ä¸­ä¸­æ·»åŠ ï¼š 1ulimit -c unlimited ç„¶åé‡å¯æœºå™¨æˆ–è€…ä½¿ç”¨sourceå‘½ä»¤ï¼š 1source /etc/profile","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"ç¬¬äº”ç«  Internetåè®®","slug":"TIV5","date":"2020-01-23T05:47:50.000Z","updated":"2020-01-23T06:30:00.700Z","comments":true,"path":"2020/01/23/TIV5/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV5/","excerpt":"","text":"IPv4å¤´éƒ¨é•¿åº¦åŒ…å«20ä¸ªå­—èŠ‚ï¼ˆæ²¡æœ‰é€‰é¡¹ï¼‰ï¼ŒIPv6å¤´éƒ¨é•¿åº¦å›ºå®šï¼ˆ40å­—èŠ‚ï¼‰ã€‚ç½‘ç»œå­—èŠ‚åºï¼šé«˜ä½ä¼˜å…ˆå­—èŠ‚åºã€‚Internetå¤´éƒ¨è¢«é™åˆ¶ä¸º60ä¸ªå­—èŠ‚ï¼Œå› ä¸ºIHLå­—æ®µé•¿åº¦ä¸º4ä½ï¼Œä¿å­˜IPv4å¤´éƒ¨ä¸­32ä½å­—çš„æ•°é‡ã€‚ä¸»æœºä¸éœ€è¦æ¥æ”¶å¤§äº576å­—èŠ‚çš„IPv4æ•°æ®æŠ¥ã€‚å¤´éƒ¨æ ¡éªŒå’Œå­—æ®µä»…è®¡ç®—IPv4å¤´éƒ¨ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬ä¸‰ç«  é“¾è·¯å±‚","slug":"TIV3","date":"2020-01-23T04:48:35.000Z","updated":"2020-01-23T05:47:43.940Z","comments":true,"path":"2020/01/23/TIV3/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV3/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡æœ€å¤§ä¼ è¾“å•å…ƒï¼š MTUä»¥å¤ªç½‘ï¼šé€šå¸¸æŒ‡ä¸€å¥—æ ‡å‡†ã€‚10Mbit/sä»¥å¤ªç½‘ï¼Œåˆç§°802.3æ ‡å‡†ã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;äº¤æ¢æœºä»¥åŒå·¥æ–¹å¼è¿è¡Œï¼Œå¹¶ä¸”ä¸éœ€è¦ä½¿ç”¨CSMA/CDç®—æ³•.&emsp;ä¼ ç»Ÿä»¥å¤ªç½‘æœ€å°çš„å¸§æ˜¯64å­—èŠ‚ï¼Œè¦æ±‚æ•°æ®åŒºé•¿åº¦æœ€å°ä¸º48å­—èŠ‚ï¼Œæœ€å¤§å¸§é•¿åº¦ä¸º1518å­—èŠ‚ï¼ŒMTUå¤§å°é™åˆ¶ä¸º1500å­—èŠ‚ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬äºŒç«  Internetåœ°å€ç»“æ„","slug":"TIV2","date":"2020-01-23T01:42:40.000Z","updated":"2020-01-23T04:48:25.660Z","comments":true,"path":"2020/01/23/TIV2/","link":"","permalink":"http://yoursite.com/2020/01/23/TIV2/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡å­ç½‘å¯»å€ï¼šä¸€ä¸ªç«™ç‚¹è¢«åˆ†é…ä¸€ä¸ªAç±»ã€Bç±»å’ŒCç±»çš„ç½‘ç»œå·ï¼Œä¿ç•™ä¸€äº›å‰©ä½™ä¸»æœºå·è¿›ä¸€æ­¥ç”¨ç«™ç‚¹åˆ†é…ã€‚è¯¥ç«™ç‚¹å¯èƒ½å°†åŸºç¡€åœ°å€ä¸­çš„ä¸»æœºéƒ¨åˆ†è¿›ä¸€æ­¥åˆ’åˆ†ä¸ºä¸€ä¸ªå­ç½‘å·å’Œä¸€ä¸ªä¸»æœºå·ã€‚Aç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·8ä½ï¼Œ0 + 7ä½è‡ªç”±;ä¸»æœºå·24ä½ Bç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·16ä½ï¼Œ10 + 14ä½è‡ªç”±ï¼›ä¸»æœº16ä½ Cç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·24ä½ï¼Œ110 + 21ä½è‡ªç”± ï¼›ä¸»æœº8ä½Dç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·32ä½ï¼Œ1110 + 28ä½è‡ªç”± Eç±»ç½‘ç»œåœ°å€ï¼šç½‘ç»œå·32ä½ï¼Œ1111 + 28ä½è‡ªç”± å­ç½‘æ©ç ï¼šç”±ä¸»æœºæˆ–è·¯ç”±å™¨ä½¿ç”¨çš„åˆ†é…ä½ï¼Œä»¥ç¡®å®šå¦‚ä½•ä»ä¸€å°ä¸»æœºå¯¹åº”IPåœ°å€ä¸­è·å¾—ç½‘ç»œå’Œå­ç½‘ä¿¡æ¯ã€‚å­ç½‘æ©ç çº¯ç²¹æ˜¯ç«™ç‚¹å†…éƒ¨çš„å±€éƒ¨é—®é¢˜ã€‚å®šå‘å¹¿æ’­ï¼š ä½¿ç”¨å­ç½‘å¹¿æ’­åœ°å€ä½œä¸ºç›®çš„åœ°çš„æ•°æ®æŠ¥ã€‚æœ‰é™å¹¿æ’­ï¼š255.255.255.255è¢«ä¿ç•™ä¸ºæœ¬åœ°ç½‘ç»œå¹¿æ’­ï¼Œå®ƒæ ¹æœ¬ä¸ä¼šè¢«è·¯ç”±å™¨è½¬å‘ã€‚ä»»æ„æºç»„æ’­ï¼šASM,ä»»ä½•å‘é€æ–¹å¯ä»¥å‘é€ç»™ä»»ä½•ç»„ã€‚ç‰¹ç‚¹ç»„æ’­ï¼šSSMï¼Œåœ¨æ¯ä¸ªç»„ä¸­åªä½¿ç”¨ä¸€ä¸ªå‘é€æ–¹ã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;IPv6åœ°å€é•¿åº¦128ä½ï¼ˆ16* 8ï¼‰ï¼ŒIPv4åœ°å€é•¿åº¦32ä½ï¼ˆ8* 4ï¼‰ &emsp;IPv6å—çš„å‰å¯¼çš„é›¶ä¸å¿…ä¹¦å†™ã€‚å…¨é›¶çš„å—å¯ä»¥çœç•¥ï¼Œå¹¶ç”¨ç¬¦å·::ä»£æ›¿ï¼Œä¸ºäº†é¿å…æ­§ä¹‰ï¼Œä¸€ä¸ªIPv6åœ°å€ä¸­çš„ç¬¦å·::åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚åœ¨IPv6æ ¼å¼ä¸­åµŒå…¥IPv4åœ°å€å¯ä»¥ä½¿ç”¨æ··åˆç¬¦å·å½¢å¼ï¼Œç´§æ¥ç€IPv4éƒ¨åˆ†çš„åœ°å€å—çš„å€¼ä¸ºffffï¼Œåœ°å€çš„å…¶ä»–éƒ¨åˆ†ä½¿ç”¨ç‚¹åˆ†å››ç»„æ ¼å¼ï¼ˆ::ffff:10.0.0.1ï¼‰ &emsp;åªæœ‰åˆ’åˆ†å­ç½‘çš„ç½‘ç»œä¸­çš„ä¸»æœºå’Œè·¯ç”±å™¨çŸ¥é“å­ç½‘ç»“æ„ï¼ŒInternetå…¶ä»–éƒ¨åˆ†ä»ç„¶å°†å®ƒä½œä¸ºç«™ç‚¹ç›¸å…³çš„åœ°å€æ¥çœ‹å¾….&emsp;128.32.1.255/24è¿™ä¸ªåœ°å€ç§°ä¸ºå­ç½‘å¹¿æ’­åœ°å€ã€‚&emsp;CIDRç¼“è§£IPv4åœ°å€çš„å‹åŠ›ï¼Œå¤„ç†å¤§äº255å°äº65536çš„ä¸»æœºæ•°ã€‚","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ç¬¬ä¸€ç«  æ¦‚è¿°","slug":"TIV1","date":"2020-01-22T13:10:37.000Z","updated":"2020-01-22T15:58:16.318Z","comments":true,"path":"2020/01/22/TIV1/","link":"","permalink":"http://yoursite.com/2020/01/22/TIV1/","excerpt":"","text":"ğŸ˜å…³é”®è¯æ±‡åè®®æ—ï¼š ä¸€ç³»åˆ—ç›¸å…³åè®®çš„é›†åˆã€‚ ç½‘å…³ï¼šåˆç§°è·¯ç”±å™¨ã€‚ è™šç”µè·¯ï¼šè¡¨ç°å‡ºå¾ˆå¤šç”µè·¯è¡Œä¸ºï¼Œä½†æ˜¯ä¸ä¾èµ–äºç‰©ç†çš„äº¤æ¢æœºï¼Œè€Œé€šè¿‡é¡¶å±‚çš„é¢å‘è¿æ¥çš„åˆ†ç»„æ¥å®ç° æ•°æ®æŠ¥ï¼šä¸€ä¸ªç‰¹å®šç±»å‹çš„åˆ†ç»„ï¼ŒåŒ…å«æ‰€æœ‰æ¥æºåœ°å’Œç›®çš„åœ°çš„æ‰€æœ‰è¯†åˆ«ä¿¡æ¯ã€‚ æ¶ˆæ¯è¾¹ç•Œï¼šå‡è®¾å‘é€3ä¸ªæ•°æ®æŠ¥ï¼Œæ¥æ”¶æ—¶å¿…é¡»æ˜¯3ä¸ªæ•°æ®æŠ¥ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯æœ‰æ¶ˆæ¯è¾¹ç•Œçš„ï¼›å¦‚æœå¯ä»¥è‡ªå·±é€‰æ‹©æ¥æ”¶æ¬¡æ•°ï¼Œä¸€æ¬¡æ¥æ”¶3ä¸ªæ•°æ®æŠ¥ï¼Œæˆ–è€…2æ¬¡ï¼Œè¿™å°±æ˜¯æ²¡æœ‰æ¶ˆæ¯è¾¹ç•Œã€‚ä¼šè¯å±‚ï¼šè¡¨ç¤ºè¿è¡Œä¸­çš„åº”ç”¨ä¹‹é—´çš„äº¤äº’ï¼Œä¼šè¯å±‚åè®®å¯æä¾›ä¾‹å¦‚è¿æ¥åˆå§‹åŒ–å’Œé‡æ–°å¯åŠ¨ã€å¢åŠ æ£€æŸ¥ç‚¹ç­‰åŠŸèƒ½ã€‚è¡¨ç¤ºå±‚ï¼šè´Ÿè´£ä¿¡æ¯æ ¼å¼è½¬æ¢å’Œæ ‡å‡†åŒ–ç¼–ç ã€‚PDUï¼šåè®®æ•°æ®å•å…ƒ è½¬å‘ï¼šæ¯ä¸ªæ•°æ®æŠ¥çš„ç›®çš„åœ°å€ç”¨äºå†³å®šå°†è¯¥æ•°æ®æŠ¥å‘é€åˆ°å“ªé‡Œï¼Œè€Œåšå‡ºæ­¤å†³å®šå’Œå‘é€æ•°æ®æŠ¥åˆ°ä¸‹ä¸€è·³çš„è¿‡ç¨‹ã€‚å•æ’­ï¼šç›®çš„åœ°æ˜¯ä¸€å°ä¸»æœºã€‚å¹¿æ’­ï¼šç›®çš„åœ°æ˜¯ä¸€ä¸ªæŒ‡å®šç½‘ç»œä¸­çš„æ‰€æœ‰ä¸»æœºã€‚ ç»„æ’­ï¼šç›®çš„åœ°æ˜¯å±äºä¸€ä¸ªç»„æ’­ç»„çš„ä¸€ç»„ä¸»æœºã€‚ ICMP: Internetæ§åˆ¶æ¶ˆæ¯åè®®æ˜¯IPçš„ä¸€ä¸ªè¾…åŠ©åè®®ã€‚IPå±‚ä½¿ç”¨å®ƒä¸å…¶ä»–ä¸»æœºæˆ–è·¯ç”±å™¨çš„IPå±‚ä¹‹é—´äº¤æ¢å·®é”™æ¶ˆæ¯å’Œå…¶ä»–é‡è¦æ¶ˆæ¯ã€‚ åº”ç”¨ï¼špingã€tracerouteã€‚IGMPï¼šInternetç»„ç®¡ç†åè®®æ˜¯IPv4çš„å¦ä¸€ä¸ªè¾…åŠ©åè®®ã€‚å®ƒé‡‡ç”¨ç»„æ’­å¯»å€å’Œäº¤ä»˜æ¥ç®¡ç†ä½œä¸ºç»„æ’­æˆå‘˜çš„ä¸»æœºã€‚SCTP: æµæ§åˆ¶ä¼ è¾“åè®®. ç«¯å£å·ï¼š16ä½éè´Ÿæ•´æ•°ï¼ˆ0~65535ï¼‰ï¼Œç†ŸçŸ¥ç«¯å£å·ï¼ˆ0 ~ 1023ï¼‰ï¼Œæ³¨å†Œç«¯å£å·ï¼ˆ1024 ~ 49151ï¼‰ï¼ŒåŠ¨æ€/ç§æœ‰ç«¯å£å·ï¼ˆ49152 ~ 65535ï¼‰internetï¼šå¸¸è§åè®®æ—äº’è”çš„å¤šä¸ªç½‘ç»œã€‚Internet: TCP/IPé€šä¿¡çš„ä¸–ç•ŒèŒƒå›´çš„ä¸»æœºé›†åˆã€‚ ğŸ³å…³é”®æ¦‚å¿µ&emsp;TCP/IPæ˜¯ä¸€ä¸ªå®ç°Internetä½“ç³»ç»“æ„çš„åè®®æ—ã€‚ &emsp;åœ¨å°½åŠ›è€Œä¸ºçš„äº¤ä»˜ä¸­ï¼Œç½‘ç»œä¸ä¼šèŠ±è´¹å¾ˆå¤§åŠªåŠ›æ¥ç¡®ä¿æ•°æ®åœ¨æ²¡æœ‰å·®é”™æˆ–ç¼ºé™·çš„æƒ…å†µä¸‹äº¤ä»˜ã€‚&emsp;åœ¨å°½åŠ›è€Œä¸ºçš„IPç½‘ç»œä¸­ï¼Œé™ä½å‘é€æ–¹çš„å‘é€é€Ÿåº¦å¯é€šè¿‡æµé‡æ§åˆ¶æœºåˆ¶å®ç°ã€‚&emsp;é€šå¸¸è®¤ä¸ºTCP/IPä½“ç³»ç»“æ„åŒ…å«5å±‚ã€‚&emsp;ç«¯ä¸»æœºå®ç°æ‰€æœ‰å±‚ï¼Œäº¤æ¢æœºå®ç°åˆ°ç¬¬äºŒå±‚ï¼Œè·¯ç”±å™¨å®ç°åˆ°ç¬¬ä¸‰å±‚ã€‚ &emsp;é€šå¸¸ä¸è®¤ä¸ºäº¤æ¢æœºæˆ–æ¡¥æ¥æ˜¯ä¸€ä¸ªä¸­é—´ç³»ç»Ÿï¼Œè¿™æ—¶ç”±äºå®ƒä»¬æ²¡æœ‰ä½¿ç”¨äº’è”ç½‘ç»œåè®®çš„åœ°å€æ ¼å¼æ¥ç¼–å€ï¼Œå¹¶åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šä»¥é€æ˜äºç½‘ç»œå±‚åè®®çš„æ–¹å¼è¿è¡Œã€‚&emsp;æœ‰å¤šä¸ªæ¥å£çš„ç³»ç»Ÿç§°ä¸ºå¤šå®¿ä¸». &emsp;IPå‘é€ç»™é“¾è·¯å±‚åè®®çš„PDUç§°ä¸ºIPæ•°æ®æŠ¥ï¼Œå®ƒçš„å¤§å°æ˜¯64KBï¼ˆIPv6æ˜¯4GBï¼‰,æˆ‘ä»¬ç®€åŒ–ç§°ä¸ºåˆ†ç»„&emsp;å¤§çš„åˆ†ç»„æ”¾å…¥é“¾è·¯å±‚PDUï¼ˆç§°ä¸ºå¸§ï¼‰æ—¶éœ€è¦è¿›è¡Œç¼©å°å¤„ç†ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºåˆ†ç‰‡ã€‚ &emsp;TCPå‘é€åˆ°IPçš„PDUç§°ä¸ºTCPæ®µã€‚ &emsp;ç”¨æˆ·å¯ä»¥é€šè¿‡è™šæ‹Ÿä¸“ç”¨ç½‘VPNè¿æ¥åˆ°å†…è”ç½‘ã€‚&emsp;","categories":[],"tags":[{"name":"ã€ŠTCP/IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","slug":"ã€ŠTCP-IPè¯¦è§£ã€‹è¯»ä¹¦ç¬”è®°","permalink":"http://yoursite.com/tags/%E3%80%8ATCP-IP%E8%AF%A6%E8%A7%A3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"æ•£åˆ—è¡¨","slug":"alg6","date":"2020-01-22T12:22:09.000Z","updated":"2020-01-22T12:29:28.412Z","comments":true,"path":"2020/01/22/alg6/","link":"","permalink":"http://yoursite.com/2020/01/22/alg6/","excerpt":"","text":"ğŸ¥£æ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨&emsp;&emsp;åŸºäºé“¾è¡¨å®ç°çš„å­—å…¸å®ç°è€Œæ¥ æ•£åˆ—è¡¨çš„é‡ç‚¹åœ¨äºè§£å†³å†²çªï¼Œæ‹‰é“¾æ³•è§£å†³å†²çªçš„æ–¹æ³•æ˜¯é€šè¿‡æ•°ç»„ï¼‹é“¾è¡¨çš„å½¢å¼æ¥å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &quot;BinarySearchST.hpp&quot;using namespace std;/** * æ‹‰é“¾æ³•æ•£åˆ—è¡¨ * å› ä¸ºæ²¡æœ‰Javaçš„hasCodeæ–¹æ³•ï¼Œ * æ‰€ä»¥è¿™é‡Œçš„ä»£ç ç›´æ¥ä½¿ç”¨intç±»å‹ **/ template&lt;typename Value&gt;class SeparateChainingHashST&#123; public: SeparateChainingHashST(int M); ~SeparateChainingHashST(); Value get(int key); void put(int key, Value val); int size() const &#123;return this-&gt;N;&#125; private: int N; //é”®å€¼å¯¹æ€»æ•° int M; //æ•£åˆ—è¡¨çš„å¤§å° BinarySearchST&lt;int, Value&gt; *st; int hash(int key) const;&#125;;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::SeparateChainingHashST(int M) : N(0), M(M)&#123; st = new BinarySearchST&lt;int, Value&gt;[M]();&#125;template&lt;typename Value&gt;SeparateChainingHashST&lt;Value&gt;::~SeparateChainingHashST()&#123; delete [] st;&#125;template&lt;typename Value&gt;int SeparateChainingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;Value SeparateChainingHashST&lt;Value&gt;::get(int key)&#123; return st[hash(key)].get(key);&#125;template&lt;typename Value&gt;void SeparateChainingHashST&lt;Value&gt;::put(int key, Value val)&#123; st[hash(key)].put(key, val); N++;&#125; ğŸ˜¤çº¿æ€§æ¢æµ‹æ³•çš„æ•£åˆ—è¡¨&emsp;&emsp;çº¿æ€§æ¢æµ‹æ³•çš„é‡ç‚¹åœ¨äºhashå€¼ç›¸åŒæ—¶ï¼Œå°†é”®å€¼å¾€åç§»ï¼Œè¿™æ ·å°±å…±ç”¨ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹äºæ‹‰é“¾æ³•çš„æ•£åˆ—è¡¨ï¼Œè¿™ç§æ–¹æ³•æ˜¯ç”¨æ—¶é—´å¤æ‚åº¦æ¥æ¢å–ç©ºé—´å¤æ‚åº¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * çº¿æ€§æ¢æµ‹æ³•çš„æ•£åˆ—è¡¨ **/ template&lt;typename Value&gt;class LinearProbingHashST&#123; public: LinearProbingHashST(int M); int size() const &#123;return N;&#125; void put(int key, Value val); Value get(int key); void delet(int key); bool contain(int key) const; private: int M; //é•¿åº¦ int N; //é”®å€¼å¯¹æ•°é‡ int* keys; Value* vals; void resize(int sz); int hash(int key) const;&#125;;template&lt;typename Value&gt;int LinearProbingHashST&lt;Value&gt;::hash(int key) const&#123; return (key &amp; 0x7fffffff) % M;&#125;template&lt;typename Value&gt;LinearProbingHashST&lt;Value&gt;::LinearProbingHashST(int M) :M(M), N(0)&#123; keys = new int [M](); vals = new Value [M](); for(int i = 0; i &lt; M; ++i) keys[i] = -1;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::put(int key, Value val)&#123; if(N &gt; M / 2) &#123; resize(2 * M); &#125; int i; for(i = hash(key); keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; vals[i] = val; return ; &#125; &#125; keys[i] = key; vals[i] = val; N++;&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::resize(int sz)&#123; int * keys1 = keys; Value* vals1 = vals; int M1 = M; keys = new int [sz](); vals = new Value [sz] (); for(int i = 0; i &lt; sz; ++i) &#123; keys[i] = -1; &#125; N = 0; M = sz; for(int i = 0; i &lt; M1; ++i) &#123; if(keys1[i] != -1) &#123; put(keys1[i], vals1[i]); &#125; &#125; delete [] keys1; delete [] vals1;&#125;template&lt;typename Value&gt;Value LinearProbingHashST&lt;Value&gt;::get(int key)&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) &#123; return vals[i]; &#125; &#125; return Value();&#125;template&lt;typename Value&gt;void LinearProbingHashST&lt;Value&gt;::delet(int key)&#123; if(!contain(key)) return ; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) if(keys[i] == key) break; keys[i] = -1; vals[i] = Value(); i = (i + 1) % M; int k; Value v; while(keys[i] != -1) &#123; k = keys[i]; v = vals[i]; N--; keys[i] = -1; vals[i] = Value(); put(k, v); i = (i + 1) % M; &#125; N--; if(N &gt; 0 &amp;&amp; N == M/8) resize(M / 2);&#125;template&lt;typename Value&gt;bool LinearProbingHashST&lt;Value&gt;::contain(int key) const&#123; int i = hash(key); for(; keys[i] != -1; i = (i + 1) % M) &#123; if(keys[i] == key) return true; &#125; return false;&#125;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"åœ¨C++ä¸­æ˜¯å¦æœ‰æ›¿ä»£INT_MINè¿™äº›å®å®šä¹‰çš„åŠŸèƒ½ï¼Ÿ","slug":"problems4","date":"2020-01-12T17:04:54.000Z","updated":"2020-01-12T17:13:48.000Z","comments":true,"path":"2020/01/13/problems4/","link":"","permalink":"http://yoursite.com/2020/01/13/problems4/","excerpt":"","text":"ğŸ“£åœ¨C++ä¸­æˆ‘ä»¬ä¾ç„¶å¯ä»¥åŒ…å« å¤´æ–‡ä»¶ï¼Œç„¶åå»ä½¿ç”¨INT_MINè¿™äº›å®å®šä¹‰,ä½†æ˜¯å…¶å®åœ¨C++ä¸­æ˜¯å­˜åœ¨æ›´åŠ ä¼˜é›…çš„æ–¹å¼çš„ 123#include &lt;limits&gt;std::numeric_limits&lt;int&gt;::min() //INT_MINstd::numeric_limits&lt;int&gt;::max() //INT_MAX","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å¦‚ä½•åˆ›å»ºæ•°ç»„çš„å…±äº«æŒ‡é’ˆ","slug":"problems3","date":"2020-01-12T02:56:38.000Z","updated":"2020-01-12T02:58:59.555Z","comments":true,"path":"2020/01/12/problems3/","link":"","permalink":"http://yoursite.com/2020/01/12/problems3/","excerpt":"","text":"C++11åœ¨shared_ptræ˜¯æ²¡æœ‰shared_ptr&lt;int []&gt;è¿™æ ·çš„ä¸œè¥¿çš„ï¼Œä½†æ˜¯std::unique_ptr&lt;int[]&gt;æ˜¯æœ‰çš„ 12345std::shared_ptr&lt;int[]&gt; a(new int[10]()); // é”™è¯¯ï¼Œc++17å‰ä¸èƒ½ä¼ é€’æ•°ç»„ç±»å‹ä½œä¸ºshared_ptrçš„æ¨¡æ¿å‚æ•°std::unique_ptr&lt;int[]&gt; b(new int[10]()); // ok, unique_ptrå¯¹æ­¤åšäº†ç‰¹åŒ–std::shared_ptr&lt;int&gt; c(new int[10]()); // é”™è¯¯ï¼Œå¯ä»¥ç¼–è¯‘ï¼Œä½†ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼Œè¯·ä¸è¦è¿™ä¹ˆåšstd::shared_ptr&lt;int&gt; sp3(new int[10](), std::default_delete&lt;int[]&gt;()); //æ­£ç¡®åšæ³•","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"å­—å…¸","slug":"alg5","date":"2020-01-12T02:39:59.000Z","updated":"2020-01-21T08:14:22.906Z","comments":true,"path":"2020/01/12/alg5/","link":"","permalink":"http://yoursite.com/2020/01/12/alg5/","excerpt":"","text":"ğŸ¥£é“¾è¡¨å®ç°é“¾è¡¨å®ç°æ’å…¥ã€æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯Nï¼Œå¹¶éä¸€ä¸ªé«˜æ•ˆçš„å®ç°æ–¹å¼ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;using namespace std;/** * é“¾è¡¨å®ç° **/template&lt;typename S, typename T&gt;class SequentialSearchST &#123; public: struct Node &#123; Node(const S&amp; key, const T&amp; val, shared_ptr&lt;Node&gt; next = nullptr) :key(key), val(val), next(next) &#123;&#125; const S key; T val; shared_ptr&lt;Node&gt; next; &#125;; void show() const; void put(S key, T val); const T get(const S&amp; key) const; bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; private: shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;const T SequentialSearchST&lt;S,T&gt;::get(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return T(); return sk-&gt;val;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::put(S key, T val) &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(sk) sk-&gt;val = val; else &#123; shared_ptr&lt;Node&gt; newOne(make_shared&lt;Node&gt;(key, val, head)); head = newOne; &#125;&#125;template&lt;typename S, typename T&gt;void SequentialSearchST&lt;S,T&gt;::show() const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; cout &lt;&lt; sk-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; sk-&gt;val &lt;&lt; endl; sk = sk-&gt;next; &#125;&#125;template&lt;typename S, typename T&gt;bool SequentialSearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; sk(head); while(sk &amp;&amp; sk-&gt;key != key) &#123; sk = sk-&gt;next; &#125; if(!sk) return false; return true;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; SequentialSearchST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; shared_ptr&lt;Node&gt; sk(head); while(sk) &#123; res.push_back(sk-&gt;key); sk = sk-&gt;next; &#125; return res;&#125; ğŸš†æ”¹è¿›1ï¼šæ”¹ç”¨æ•°ç»„å®ç°ï¼ŒäºŒåˆ†æŸ¥æ‰¾æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦é™ä½ä¸ºlgNï¼Œä½†æ˜¯å› ä¸ºæ•°ç»„ç§»ä½çš„åŸå› ï¼Œæ’å…¥çš„æ—¶é—´å¤æ‚åº¦è¿˜æ˜¯N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * æ•°ç»„å®ç° **/template&lt;typename S, typename T&gt;class BinarySearchST &#123; public: BinarySearchST(int size = 10000); ~BinarySearchST(); void put(const S&amp;, const T&amp;); const T get(const S&amp;); bool contain(const S&amp; key) const; const vector&lt;S&gt; keys() const; void show() const; private: const int rank(const S&amp;) const; S* _keys; T* vals; int _capacity; int n;&#125;;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::BinarySearchST(int size) : _keys(new S[size]), vals(new T[size]), _capacity(size), n(0)&#123;&#125;template&lt;typename S, typename T&gt;BinarySearchST&lt;S,T&gt;::~BinarySearchST()&#123; delete []_keys; delete []vals;&#125;template&lt;typename S, typename T&gt;const int BinarySearchST&lt;S,T&gt;::rank(const S&amp; key) const&#123; if(n == 0) return 0; int lo = 0, hi = n - 1, mid; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if(_keys[mid] &lt; key) lo = mid + 1; else hi = mid; &#125; if(_keys[lo] &lt; key) return lo + 1; else return lo;&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val)&#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; vals[pos] = val; return ; &#125; //æš‚æ—¶ä¸è€ƒè™‘è¶…å‡ºå®¹é‡çš„æƒ…å†µ for(int i = n; i &gt; pos; --i) &#123; _keys[i] = _keys[i - 1]; vals[i] = vals[i - 1]; &#125; _keys[pos] = key; vals[pos] = val; ++n;&#125;template&lt;typename S, typename T&gt;const T BinarySearchST&lt;S,T&gt;::get(const S&amp; key) &#123; int pos = rank(key); if(pos &lt; n &amp;&amp; _keys[pos] == key) &#123; return vals[pos]; &#125; return T();&#125;template&lt;typename S, typename T&gt;bool BinarySearchST&lt;S,T&gt;::contain(const S&amp; key) const &#123; if(!n) return false; int pos = rank(key); return _keys[pos] == key;&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BinarySearchST&lt;S,T&gt;::keys() const &#123; return vector&lt;S&gt;(_keys, _keys + n);&#125;template&lt;typename S, typename T&gt;void BinarySearchST&lt;S,T&gt;::show() const &#123; for(int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; _keys[i] &lt;&lt; &quot; &quot; &lt;&lt; vals[i] &lt;&lt; endl; &#125;&#125; ğŸš†æ”¹è¿›2ï¼šæ”¹ç”¨äºŒå‰æŸ¥æ‰¾æ ‘æŸ¥æ‰¾ã€ä¿®æ”¹çš„å¹³å‡æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯lgNï¼Œä½†æ˜¯æœ€åæƒ…å†µä¸¤è€…éƒ½é€€å›åˆ°N 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * äºŒå‰æŸ¥æ‰¾æ ‘çš„å®ç° **/#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * äºŒå‰æŸ¥æ‰¾æ ‘çš„å®ç° **/template&lt;typename S, typename T&gt;class BST&#123; public: struct Node &#123; const S key; T val; shared_ptr&lt;Node&gt; left, right; int N; Node(const S&amp;key, const T&amp; val, int N) : key(key), val(val), left(), right(), N(N) &#123;&#125; int compareTo(shared_ptr&lt;Node&gt; node) const; int compareTo(const S&amp;) const; static int Nsize(shared_ptr&lt;Node&gt; x); &#125;; const S min() const; const S max() const; bool contain(const S&amp;) const; const T get(const S&amp;) const; void put(const S&amp; key, const T&amp; val); void show() const; //è°ƒè¯• const vector&lt;S&gt; keys() const; const S floor(const S&amp; key) const; const S ceiling(const S&amp;key) const; const S select(int x) const; const int rank(const T&amp;) const; void deleteMin(); void delet(const T&amp; key); private: shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt; nd, const T&amp; key); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); const int _rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const; shared_ptr&lt;Node&gt; _select(shared_ptr&lt;Node&gt; nd, int x) const; shared_ptr&lt;Node&gt; _floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const; shared_ptr&lt;Node&gt; _ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const; shared_ptr&lt;Node&gt; _min(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _max(shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; _put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val); const T _get(shared_ptr&lt;Node&gt; x,const S&amp;) const; void _show(shared_ptr&lt;Node&gt; x) const; void _keys(vector&lt;S&gt;&amp;, shared_ptr&lt;Node&gt; x) const; shared_ptr&lt;Node&gt; head;&#125;;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::put(const S&amp; key, const T&amp; val) &#123; head = _put(head, key, val);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_put(shared_ptr&lt;Node&gt; x, const S&amp; key, const T&amp; val) &#123; if(!x) return make_shared&lt;Node&gt;(key, val, 1); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) x-&gt;left = _put(x-&gt;left, key, val); else if(cmp &lt; 0) x-&gt;right = _put(x-&gt;right, key, val); else x-&gt;val = val; x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;/** * &gt; 1 * = 0 * &lt; -1 **/ template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(shared_ptr&lt;Node&gt; node) const &#123; return compareTo(node-&gt;key);&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::compareTo(const S&amp; key2) const &#123; return key &gt; key2 ? 1 : key &lt; key2 ? -1 : 0;&#125;template&lt;typename S, typename T&gt;int BST&lt;S,T&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x) &#123; if(!x) return 0; else return x-&gt;N;&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::get(const S&amp; key) const &#123; return _get(head, key);&#125;template&lt;typename S, typename T&gt;const T BST&lt;S,T&gt;::_get(shared_ptr&lt;Node&gt; x,const S&amp; key) const &#123; if(!x) return T(); int cmp = x-&gt;compareTo(key); if(cmp &gt; 0) return _get(x-&gt;right, key); else if(cmp &lt; 0) return _get(x-&gt;left, key); else return x-&gt;val;&#125;template&lt;typename S, typename T&gt;bool BST&lt;S,T&gt;::contain(const S&amp; key) const &#123; return get(key) != T();&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::show() const &#123; _show(head);&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_show(shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; if(x-&gt;left) _show(x-&gt;left); cout &lt;&lt; x-&gt;key &lt;&lt; &quot; &quot; &lt;&lt; x-&gt;val &lt;&lt; endl; if(x-&gt;right) _show(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const vector&lt;S&gt; BST&lt;S,T&gt;::keys() const &#123; vector&lt;S&gt; res; _keys(res, head); return res;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::_keys(vector&lt;S&gt;&amp; res, shared_ptr&lt;Node&gt; x) const &#123; if(!x) return ; res.push_back(x-&gt;key); _keys(res,x-&gt;left); _keys(res, x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::min() const &#123; if(!head) return S(); return _min(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_min(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;left) return x; else return _min(x-&gt;left);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::max() const &#123; if(!head) return S(); return _max(head)-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_max(shared_ptr&lt;Node&gt; x) const &#123; if(!x || !x-&gt;right) return x; else return _max(x-&gt;right);&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::floor(const S&amp; key) const &#123; shared_ptr&lt;Node&gt; nd = _floor(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::ceiling(const S&amp;key) const &#123; shared_ptr&lt;Node&gt; nd = _ceiling(head, key); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_floor(shared_ptr&lt;Node&gt; x, const S&amp; key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(cmp == 0) return x; else if (cmp &gt; 0) return _floor(x-&gt;left, key); shared_ptr&lt;Node&gt; y = _floor(x-&gt;right, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_ceiling(shared_ptr&lt;Node&gt; x, const S&amp;key) const &#123; if(!x) return x; int cmp = x-&gt;compareTo(key); if(!cmp) return x; else if(cmp &lt; 0) return _ceiling(x-&gt;right, key); shared_ptr&lt;Node&gt; y = _ceiling(x-&gt;left, key); if(!y) return x; return y;&#125;template&lt;typename S, typename T&gt;const S BST&lt;S,T&gt;::select(int x) const &#123; if(x &lt; 0 || x &gt;= head-&gt;N) return S(); auto nd = _select(head, x); if(!nd) return S(); return nd-&gt;key;&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::_select(shared_ptr&lt;Node&gt; nd, int x) const &#123; if(!nd) return nd; int nd_rank = Node::Nsize(nd-&gt;left); if(nd_rank &gt; x) return _select(nd-&gt;left, x); else if (nd_rank &lt; x) return _select(nd-&gt;right, x - nd_rank - 1); return nd;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::rank(const T&amp; key) const &#123; int rk = _rank(head, key); // if(select(rk) != key) // return -1; return rk;&#125;template&lt;typename S, typename T&gt;const int BST&lt;S,T&gt;::_rank(shared_ptr&lt;Node&gt; nd, const T&amp; key) const &#123; if(!nd) return 0; int nd_rank = Node::Nsize(nd-&gt;left); if(nd-&gt;key &lt; key) return nd_rank + 1 + _rank(nd-&gt;right, key); else if(nd-&gt;key &gt; key) return _rank(nd-&gt;left, key); return nd_rank;&#125;/** * è¿™ä¸ªå‡½æ•°åªèƒ½åˆ é™¤æ ¹èŠ‚ç‚¹å·¦è¾¹çš„ **/ template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::deleteMin() &#123; deleteMin(head);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::deleteMin(shared_ptr&lt;Node&gt; x) &#123; if(!x-&gt;left) return x-&gt;right; x-&gt;left = deleteMin(x-&gt;left); x-&gt;N = Node::Nsize(x-&gt;left) + Node::Nsize(x-&gt;right) + 1; return x;&#125;template&lt;typename S, typename T&gt;void BST&lt;S,T&gt;::delet(const T&amp; key) &#123; head = delet(head, key);&#125;template&lt;typename S, typename T&gt;shared_ptr&lt;typename BST&lt;S,T&gt;::Node&gt; BST&lt;S,T&gt;::delet(shared_ptr&lt;Node&gt; nd, const T&amp; key)&#123; if(!nd) &#123; return nd; &#125; int cmp = nd-&gt;compareTo(key); if(cmp &lt; 0) &#123; nd-&gt;right = delet(nd-&gt;right, key); &#125; else if(cmp &gt; 0) &#123; nd -&gt;left = delet(nd-&gt;left, key); &#125; else &#123; if(!nd-&gt;left) return nd-&gt;right; if(!nd-&gt;right) return nd-&gt;left; auto minO = _min(nd-&gt;right); minO-&gt;right = deleteMin(nd-&gt;right); minO-&gt;left = nd-&gt;left; nd = minO; &#125; nd-&gt;N = Node::Nsize(nd-&gt;left) + Node::Nsize(nd-&gt;right) + 1; return nd;&#125; ğŸš†æ”¹è¿›3ï¼šçº¢é»‘æ ‘æŸ¥æ‰¾ã€æ’å…¥çš„æ—¶é—´å¤æ‚åº¦æ’å®šä¸ºlogN 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394/* * @Author: XiaoGongBai * @Date: 2020-01-19 10:21:20 * @Last Modified by: XiaoGongBai * @Last Modified time: 2020-01-19 11:31:04 */#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;#include &lt;iterator&gt;using namespace std;/** * çº¢é»‘æ ‘ **/enum class Color&#123; Red , Black &#125;;template&lt;typename Key, typename Val&gt;class RedBlackBST&#123; public: struct Node&#123; Key key; Val val; shared_ptr&lt;Node&gt; left,right; int N; Color color; Node(const Key&amp; key, const Val&amp; val, int N, Color color) :key(key), val(val), left(), right(), N(N), color(color) &#123;&#125; static int Nsize(shared_ptr&lt;Node&gt; x); int compareTo(const Key&amp; key) const; &#125;; void put(const Key&amp; key, const Val&amp; val); shared_ptr&lt;Node&gt; get(const Key&amp; key) const; void deleteMin(); void deleteMax(); void delet(const Key&amp;); Key min() const; Key max() const; vector&lt;Key&gt; keys(const Key&amp; m, const Key&amp; e) const; vector&lt;Key&gt; keys() const; const int size() const &#123;return root ? root-&gt;N : 0;&#125; private: shared_ptr&lt;Node&gt; root; void keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const; shared_ptr&lt;Node&gt; max(shared_ptr&lt;Node&gt; h) const; shared_ptr&lt;Node&gt; min(shared_ptr&lt;Node&gt;) const; shared_ptr&lt;Node&gt; get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const; shared_ptr&lt;Node&gt; delet(shared_ptr&lt;Node&gt;, const Key&amp;); shared_ptr&lt;Node&gt; balance(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedLeft(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; removeRedRight(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMax(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; deleteMin(shared_ptr&lt;Node&gt;); shared_ptr&lt;Node&gt; put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val); void flipColor(shared_ptr&lt;Node&gt; h); shared_ptr&lt;Node&gt; rotateLeft(shared_ptr&lt;Node&gt; node); shared_ptr&lt;Node&gt; rotateRight(shared_ptr&lt;Node&gt; h); bool isRed(shared_ptr&lt;Node&gt; node) const; &#125;;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::Nsize(shared_ptr&lt;Node&gt; x)&#123; return x ? x-&gt;N : 0; &#125;template&lt;typename Key, typename Val&gt;int RedBlackBST&lt;Key,Val&gt;::Node::compareTo(const Key&amp; key) const&#123; if(key &gt; this-&gt;key) &#123; return -1; &#125; else if(key &lt; this-&gt;key) &#123; return 1; &#125; return 0;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateLeft(shared_ptr&lt;Node&gt; h)&#123; if(!h) return nullptr; auto rh = h-&gt;right; if(!rh) return h; h-&gt;right = rh-&gt;left; rh-&gt;left = h; rh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, rh-&gt;color); return rh;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::rotateRight(shared_ptr&lt;Node&gt; h)&#123; if(!h) &#123; return nullptr; &#125; auto lh = h-&gt;left; if(!lh) return h; h-&gt;left = lh-&gt;right;; lh-&gt;right = h; lh-&gt;N = h-&gt;N; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; swap(h-&gt;color, lh-&gt;color); return lh;&#125;template&lt;typename Key, typename Val&gt;bool RedBlackBST&lt;Key,Val&gt;::isRed(shared_ptr&lt;Node&gt; h) const&#123; if(!h || h-&gt;color == Color::Black) return false; return true;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::put(const Key&amp; key, const Val&amp; val)&#123; root = put(root, key, val); root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::put(shared_ptr&lt;Node&gt; h, const Key&amp; key, const Val&amp; val)&#123; if(!h) return make_shared&lt;Node&gt;(key, val, 1, Color::Red); int cmp = h-&gt;compareTo(key); if(cmp &lt; 0) &#123; h-&gt;right = put(h-&gt;right, key, val); &#125; else if (cmp &gt; 0) &#123; h-&gt;left = put(h-&gt;left, key, val); &#125; else &#123; h-&gt;val =val; &#125; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::flipColor(shared_ptr&lt;Node&gt; h)&#123; h-&gt;color = h-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;right-&gt;color = h-&gt;right-&gt;color == Color::Black ? Color::Red : Color::Black; h-&gt;left-&gt;color = h-&gt;left-&gt;color == Color::Black ? Color::Red : Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(const Key&amp; key) const&#123; return get(root, key);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::get(shared_ptr&lt;Node&gt; h,const Key&amp; key) const&#123; if(!h) return nullptr; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; return get(h-&gt;left, key); &#125; else if (cmp &lt; 0) &#123; return get(h-&gt;right, key); &#125; else return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMin()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMin(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMin(shared_ptr&lt;Node&gt; h) &#123; if(!h-&gt;left) return h-&gt;right; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) &#123; h = removeRedLeft(h); &#125; h-&gt;left = deleteMin(h-&gt;left); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedLeft(shared_ptr&lt;Node&gt; h) &#123; flipColor(h); if(isRed(h-&gt;right) &amp;&amp; isRed(h-&gt;right-&gt;left)) &#123; h-&gt;right = rotateRight(h-&gt;right); h = rotateLeft(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::balance(shared_ptr&lt;Node&gt; h)&#123; if(!isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) h = rotateLeft(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;left-&gt;left)) h = rotateRight(h); if(isRed(h-&gt;left) &amp;&amp; isRed(h-&gt;right)) &#123; flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;KeyRedBlackBST&lt;Key,Val&gt;::min() const&#123; if(!root) return Val(); return min(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::min(shared_ptr&lt;Node&gt; h) const &#123; if(!h-&gt;left) return h; return min(h-&gt;left);&#125;template&lt;typename Key, typename Val&gt;Key RedBlackBST&lt;Key,Val&gt;::max() const&#123; if(!root) return Val(); return max(root)-&gt;key;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::max(shared_ptr&lt;Node&gt; h) const&#123; if(!h-&gt;right) return h; return max(h-&gt;right);&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::deleteMax()&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = deleteMax(root); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::deleteMax(shared_ptr&lt;Node&gt; h)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!h-&gt;right) return h-&gt;left; if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) h = removeRedRight(h); h-&gt;right = deleteMax(h-&gt;right); h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::removeRedRight(shared_ptr&lt;Node&gt; h)&#123; flipColor(h); if(isRed(h-&gt;left-&gt;left)) &#123; h = rotateRight(h); flipColor(h); &#125; return h;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::delet(const Key&amp; key)&#123; if(!isRed(root-&gt;left) &amp;&amp; !isRed(root-&gt;right)) root-&gt;color = Color::Red; root = delet(root, key); if(root) root-&gt;color = Color::Black;&#125;template&lt;typename Key, typename Val&gt;shared_ptr&lt;typename RedBlackBST&lt;Key,Val&gt;::Node&gt; RedBlackBST&lt;Key,Val&gt;::delet(shared_ptr&lt;Node&gt; h, const Key&amp; key) &#123; int cmp = h-&gt;compareTo(key); if(cmp &gt; 0) &#123; if(!isRed(h-&gt;left) &amp;&amp; !isRed(h-&gt;left-&gt;left)) h = removeRedLeft(h); h-&gt;left = delet(h-&gt;left, key); &#125; else if(cmp &lt; 0)&#123; if(isRed(h-&gt;left)) h = rotateRight(h); if(!isRed(h-&gt;right) &amp;&amp; !isRed(h-&gt;right-&gt;left)) &#123; h = removeRedRight(h); &#125; h-&gt;right = delet(h-&gt;right, key); &#125; else &#123; if(!h-&gt;right) return h-&gt;left; h-&gt;val = get(h-&gt;right, min(h-&gt;right)-&gt;key)-&gt;val; h-&gt;key = min(h-&gt;right)-&gt;key; h-&gt;right = deleteMin(h-&gt;right); &#125; h-&gt;N = Node::Nsize(h-&gt;left) + Node::Nsize(h-&gt;right) + 1; return balance(h);&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys(const Key&amp; m, const Key&amp; e) const&#123; vector&lt;Key&gt; res; keys(root, res, m, e); return res;&#125;template&lt;typename Key, typename Val&gt;void RedBlackBST&lt;Key,Val&gt;::keys(shared_ptr&lt;Node&gt; h, vector&lt;Key&gt;&amp; res, const Key&amp; m, const Key&amp; e) const&#123; if(!h) return ; int cmp1 = h-&gt;compareTo(m), cmp2 = h-&gt;compareTo(e); if(cmp1 &gt;= 0 &amp;&amp; cmp2 &lt;= 0) &#123; res.push_back(h-&gt;key); &#125; if(cmp1 &gt; 0) &#123; keys(h-&gt;left, res, m, e); &#125; if(cmp2 &lt; 0) &#123; keys(h-&gt;right, res, m, e); &#125;&#125;template&lt;typename Key, typename Val&gt;vector&lt;Key&gt; RedBlackBST&lt;Key,Val&gt;::keys() const&#123; return keys(min(), max());&#125;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"å †æ’åº","slug":"alg4","date":"2020-01-10T14:59:59.000Z","updated":"2020-01-10T15:32:32.295Z","comments":true,"path":"2020/01/10/alg4/","link":"","permalink":"http://yoursite.com/2020/01/10/alg4/","excerpt":"","text":"ğŸ˜˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * å †æ’åº **/template&lt;typename T&gt;class HeapSort &#123; public: static void sort(vector&lt;T&gt;&amp;); private: static void sink(vector&lt;T&gt;&amp; a, int k, int N);&#125;;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sort(vector&lt;T&gt;&amp; a) &#123; int N = a.size() - 1; for(int i = N / 2; i &gt;= 1; --i) sink(a, i, N); while(N &gt; 1) &#123; swap(a[1], a[N--]); sink(a, 1, N); &#125;&#125;template&lt;typename T&gt;void HeapSort&lt;T&gt;::sink(vector&lt;T&gt;&amp; a, int k, int N) &#123; int j; while(k &lt;= N / 2) &#123; j = 2 * k; if(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j; if(a[k] &gt;= a[j]) break; swap(a[k], a[j]); k = j; &#125;&#125; ğŸ‘¿æ³¨æ„ è¦æ³¨æ„çˆ¶èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹æ—¶çš„æƒ…å†µï¼Œåœ¨sinkå‡½æ•°ä¸­ï¼ˆif(j &lt; N &amp;&amp; a[j] &lt; a[j + 1]) ++j;ï¼‰ä¸€å®šè¦æ³¨æ„j&lt;Nï¼Œä¸èƒ½è¶…å‡ºèŒƒå›´ æ„é€ æœ€å¤§å †æ—¶ï¼Œforå¾ªç¯ä»i = N / 2å¼€å§‹çš„åŸå› æ˜¯ï¼šsinkä¸­æœ‰é™åˆ¶æ¡ä»¶while(k &lt;= N / 2)ï¼Œæ‰€ä»¥N/2&lt;i&lt;Néƒ¨åˆ†æ— æ³•è¿›å…¥sinkçš„whileå¾ªç¯ï¼Œæ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå¾’å¢N/2æ¬¡æ¯”è¾ƒ é€’å¢æ’åºä½¿ç”¨æœ€å¤§å †ï¼Œé€’å‡æ’åºä½¿ç”¨æœ€å°å † vectorçš„ç¬¬ä¸€ä¸ªå€¼ï¼ˆä¸‹æ ‡ä¸º0ï¼‰ä¸ä½¿ç”¨","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ç´¢å¼•ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg3","date":"2020-01-10T08:36:33.000Z","updated":"2020-01-10T14:28:54.460Z","comments":true,"path":"2020/01/10/alg3/","link":"","permalink":"http://yoursite.com/2020/01/10/alg3/","excerpt":"","text":"ğŸ¥›åˆ†æ12345678910111213141516public class IndexMaxPQ...&#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ private int[] pq; // binary heap using 1-based indexing private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i private Key[] keys; // keys[i] = priority of i//ä¸­é—´çœç•¥...public void insert(int i, Key key) &#123; ... n++; qp[i] = n; pq[n] = i; keys[i] = key; swim(n);&#125; &emsp;&emsp;æ ¹æ®ã€Šç®—æ³•4ã€‹ç»™å‡ºçš„ä»£ç ï¼Œåˆ†æè¿™ä¸¤æ®µä»£ç æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼š åœ¨å®šä¹‰å¤„å¯çŸ¥pqæ˜¯äºŒå‰å †çš„æ•°ç»„ ç”±qp[i] = n;pq[n] = i;å¯ä»¥çœ‹å‡ºæ¥ï¼Œqpè¿™ä¸ªæ•°ç»„çš„ç”¨å¤„å°±æ˜¯ä¸ºäº†è®°å½•**pqä¸­å€¼ä¸ºiçš„ä¸‹æ ‡æ˜¯å¤šå°‘**ï¼Œè¿™æ ·å½“æˆ‘ä»¬è¦æ”¹ä¸‹æ ‡ä¸ºiçš„å…ƒç´ çš„å€¼æ—¶ï¼Œæˆ‘ä»¬å°±ä¸ç”¨éå†pqæ¥è·å¾—ä½ç½®äº†ï¼Œ**ç”¨ç©ºé—´æ¥æ¢å–æ—¶é—´** å¹¶ä¸”è¿™ä¸ªç´¢å¼•iä»…ä»…ä¸ºäº†æ‰¾åˆ°å…ƒç´ å¯¹è±¡keyï¼Œå¹¶æ²¡å®é™…çš„æ„ä¹‰ã€‚næ‰æ˜¯å¯¹åº”äºŒå‰å †çš„ä½ç½®ã€‚ ğŸ˜ä»£ç å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ç´¢å¼•æœ€å°ä¼˜å…ˆé˜Ÿåˆ— **/ template&lt;typename T&gt;class IndexMinPQ &#123; public: IndexMinPQ(int max); void show() const; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125; void insert(int k, T item); void change(int k, T item); bool contain(int k) const &#123;return qp[k] != -1;&#125;; int delMin(); private: void sink(int i); void swim(int i); T* element; //å…ƒç´  int* pq; //äºŒå‰å † int *qp; //index int N; int _capacity;&#125;;template&lt;typename T&gt;IndexMinPQ&lt;T&gt;::IndexMinPQ(int max) : element(new T[max + 1]), pq(new int[max + 1]) , qp(new int[max + 1]), N(0), _capacity(max) &#123; for(int i = 0; i &lt; max + 1; ++i) qp[i] = -1;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::sink(int n)&#123; while(n &lt; N) &#123; int m = n * 2; if(element[pq[m]] &gt; element[pq[m + 1]]) ++m; if(element[pq[m]] &lt; element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::swim(int n) &#123; while(n &gt; 1) &#123; int m = n / 2; if(element[pq[m]] &lt;= element[pq[n]]) break; swap(pq[m], pq[n]); swap(qp[pq[m]], qp[pq[n]]); n = m; &#125;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::insert(int k, T item) &#123; // cout &lt;&lt; &quot;insert &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; if(capacity() == size())&#123; cout &lt;&lt; &quot;out of size&quot; &lt;&lt; endl; return ; &#125; pq[++N] = k; element[k] = item; qp[k] = N; swim(N); // show();&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::show() const&#123; cout &lt;&lt; &quot;pq: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; pq[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;qp: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; qp[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; &quot;element: &quot;; for(int i = 1; i &lt;= capacity(); ++i) cout &lt;&lt; element[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void IndexMinPQ&lt;T&gt;::change(int k, T item) &#123; if(!contain(k)) &#123; cout &lt;&lt; &quot;change not contain&quot; &lt;&lt; endl; return ; &#125; T old_one = element[k]; element[k] = item; if(item &gt; old_one) sink(qp[k]); else if(item &lt; old_one) swim(qp[k]);&#125;template&lt;typename T&gt;int IndexMinPQ&lt;T&gt;::delMin() &#123; int max = pq[1]; swap(pq[1], pq[N]); swap(qp[pq[1]], qp[pq[N]]); --N; show(); sink(1); show(); qp[max] = -1; element[max] = -1; pq[N + 1] = -1; return max;&#125;int main(int argc, char** argv) &#123; IndexMinPQ&lt;int&gt; pq(6); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(6); for(size_t i = 0; i &lt; v.size(); ++i) &#123; pq.insert(i + 1, v[i]); &#125; pq.show(); pq.delMin(); pq.show(); return 0;&#125; ğŸ å‚è€ƒèµ„æ–™ï¼šé“¾æ¥","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¼˜å…ˆé˜Ÿåˆ—","slug":"alg2","date":"2020-01-10T07:57:40.000Z","updated":"2020-01-10T08:36:50.374Z","comments":true,"path":"2020/01/10/alg2/","link":"","permalink":"http://yoursite.com/2020/01/10/alg2/","excerpt":"","text":"ğŸ ä¼˜å…ˆé˜Ÿåˆ—çš„å®ç°æœ‰ä¸‰ç§ï¼š æœ‰åºæ•°ç»„ æ— åºæ•°ç»„ å † ğŸ…æœ‰åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æœ‰åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class OrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit OrderArrayMaxPQ(int max); ~OrderArrayMaxPQ() &#123;delete [] arr;&#125; // explicit OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;// template&lt;typename T&gt;// OrderArrayMaxPQ&lt;T&gt;::OrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) // : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())// &#123;// copy(l.begin(), l.end(), arr);// &#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x; for(int i = N - 1; i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]; --i) swap(arr[i], arr[i - 1]); &#125;template&lt;typename T&gt;pair&lt;int, T&gt; OrderArrayMaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; res = arr[N - 1]; arr[--N] = pair&lt;int , T&gt;(); return res;&#125;template&lt;typename T&gt;void OrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; OrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¦æ— åºæ•°ç»„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * 2.4.3 æ— åºæ•°ç»„å®ç° **/ template&lt;typename T&gt;class UnOrderArrayMaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; public: void show() const ; explicit UnOrderArrayMaxPQ(int max); ~UnOrderArrayMaxPQ() &#123;delete [] arr;&#125; explicit UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt;); void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(int max) : arr(new pair&lt;int, T&gt;[max]()), N(0), _capacity(max)&#123;&#125;template&lt;typename T&gt;UnOrderArrayMaxPQ&lt;T&gt;::UnOrderArrayMaxPQ(std::initializer_list&lt;pair&lt;int, T&gt;&gt; l) : arr(new pair&lt;int, T&gt;[l.size()]()), N(l.size()), _capacity(l.size())&#123; copy(l.begin(), l.end(), arr);&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[N++] = x;&#125;template&lt;typename T&gt;pair&lt;int, T&gt; UnOrderArrayMaxPQ&lt;T&gt;::delMax() &#123; if(isEmpty()) return pair&lt;int, T&gt;(); int max_one = 0; for(int i = 0; i &lt; N; ++i) if(arr[max_one].first &lt; arr[i].first) &#123; max_one = i; &#125; swap(arr[max_one], arr[--N]); pair&lt;int,T&gt; res = arr[N]; arr[N] = pair&lt;int,T&gt;(); return res;&#125;template&lt;typename T&gt;void UnOrderArrayMaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 0; i &lt; N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main(int argc, char** argv) &#123; UnOrderArrayMaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥§å †1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &quot;Common.hpp&quot;#include &lt;limits&gt;using namespace std;/** * ä¼˜å…ˆé˜Ÿåˆ— * äºŒå‰å †å®ç° **/ template&lt;typename T&gt;class MaxPQ &#123; private: pair&lt;int, T&gt;* arr; int N; int _capacity; void swim(int i); void sink(int i); public: void show() const ; explicit MaxPQ(int max); ~MaxPQ() &#123;delete [] arr;&#125; void insert(pair&lt;int, T&gt;); pair&lt;int, T&gt; delMax(); bool isEmpty() const &#123; return N == 0;&#125; int size() const &#123;return N;&#125; int capacity() const &#123;return _capacity;&#125;&#125;;template&lt;typename T&gt;MaxPQ&lt;T&gt;::MaxPQ(int max) : arr(new pair&lt;int, T&gt;[max + 1]()), N(0), _capacity(max + 1)&#123; arr[0] = pair&lt;int, T&gt;(INT8_MIN, T());&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::insert(pair&lt;int, T&gt; x) &#123; if(capacity() == size()) return ; arr[++N] = x; swim(N);&#125;template&lt;typename T&gt;pair&lt;int, T&gt; MaxPQ&lt;T&gt;::delMax() &#123; pair&lt;int ,T&gt; res; if(isEmpty()) return res; swap(arr[N--], arr[1]); res = arr[N + 1]; arr[N + 1] = pair&lt;int ,T&gt;(); sink(1); return res;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::show() const &#123; cout &lt;&lt; &quot;N: &quot; &lt;&lt; size() &lt;&lt; &quot; arr: &quot;; for(int i = 1; i &lt;= N; ++i) cout &lt;&lt; arr[i].first &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::swim(int i) &#123; while(i &gt; 1) &#123; if(arr[i].first &gt; arr[i / 2].first) swap(arr[i], arr[i / 2]); i /= 2; &#125;&#125;template&lt;typename T&gt;void MaxPQ&lt;T&gt;::sink(int i) &#123; int k; while(i &lt; N) &#123; k = 2 * i; if(arr[k].first &lt; arr[k + 1].first) ++k; if(arr[k].first &lt;= arr[i].first) break; swap(arr[k], arr[i]); i = k; &#125;&#125;int main(int argc, char** argv) &#123; MaxPQ&lt;int&gt; pq(20); vector&lt;int&gt; v = Common::getInstance()-&gt;getRandomVector(12); for(auto x: v) &#123; pq.insert(&#123;x, x&#125;); // pq.show(); &#125; while(pq.size()) &#123; pq.show(); pq.delMax(); &#125;&#125; ğŸ¥¨æ—¶é—´å¤æ‚åº¦å¯¹æ¯” æœ‰åºæ•°ç»„ï¼š æ’å…¥ï¼šNï¼Œåˆ é™¤ï¼š1 æ— åºæ•°ç»„ï¼š æ’å…¥ï¼š1ï¼Œåˆ é™¤ï¼šN å †ï¼šæ’å…¥ã€åˆ é™¤ï¼šlgN ç†æƒ³æƒ…å†µï¼šéƒ½æ˜¯1","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ä¸ºç”šä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ","slug":"problems2","date":"2020-01-08T14:28:49.000Z","updated":"2020-01-08T15:06:10.423Z","comments":true,"path":"2020/01/08/problems2/","link":"","permalink":"http://yoursite.com/2020/01/08/problems2/","excerpt":"","text":"12unsigned int a = -1;printf(&quot;%d,%u,%x&quot;,a,a,a); -1,4294967295,ffffffffä»ç»“æœä¸Šæ¥è¯´,éªŒè¯äº†C++ä¸­ä½¿ç”¨çš„æ˜¯è¡¥ç ã€‚ ğŸ ç°åœ¨è¯´ä¸€è¯´ä¸ºä»€ä¹ˆå¼‚æˆ–èƒ½å¤Ÿç¡®å®šä¸¤ä¸ªæ•°çš„ç¬¦å·æ˜¯å¦ç›¸åŒï¼Ÿ&emsp;&emsp;è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå‰æï¼Œä¸¤ä¸ªæ•°éƒ½æ˜¯intç±»å‹ï¼Œå› ä¸ºè¡¥ç çš„åŸå› ï¼Œå¦‚æœä¸¤ä¸ªæ•°çš„æ­£è´Ÿä¸åŒï¼Œé‚£ä¹ˆå®ƒä»¬çš„ç¬¬ä¸€ä½å°±ä¸åŒï¼Œå› ä¸ºintçš„ç¬¬ä¸€ä½æ˜¯æ­£è´Ÿçš„æ ‡å¿—ä½ã€‚é€šè¿‡å¼‚æˆ–ï¼Œé‚£ä¹ˆæ­£æ•°çš„ç¬¬ä¸€ä½ä¸º0ï¼Œè´Ÿæ•°çš„ç¬¬ä¸€ä½ä¸º1ï¼Œå¼‚æˆ–åç¬¬ä¸€ä½å°±ä¸º1ï¼Œæ‰€ä»¥å¯ä»¥å¾—åˆ°è®¡ç®—å‡ºçš„å€¼ä¸ºè´Ÿå€¼ã€‚ç›¸åå¦‚æœä¸¤è€…ç¬¦å·ç›¸åŒï¼Œé‚£ä¹ˆé€šè¿‡å¼‚æˆ–åï¼Œç¬¬ä¸€ä½å°±ä¸º0ï¼Œæ‰€ä»¥ä¸ºæ­£æ•°ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"äºŒåˆ†æŸ¥æ‰¾","slug":"alg1","date":"2020-01-07T14:24:36.000Z","updated":"2020-01-08T13:56:04.220Z","comments":true,"path":"2020/01/07/alg1/","link":"","permalink":"http://yoursite.com/2020/01/07/alg1/","excerpt":"","text":"æ—¶é—´å¤æ‚åº¦logN äºŒåˆ†æŸ¥æ‰¾çš„å®ç°å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯é€’å½’å¼çš„ã€å¦ä¸€ç§æ˜¯å¾ªç¯å¼çš„ğŸ˜œé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a,int lo,int ho, int key) &#123; // if(lo &gt; ho) return -1; // int mid = (lo + ho) / 2; // if(a[mid] &gt; key) return BinarySearch(a, lo, mid - 1, key); // else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); // else return mid; if(lo &gt;= ho) return -1; int mid = (lo + ho) / 2; if(a[mid] &gt; key) return BinarySearch(a, lo, mid, key); else if(a[mid] &lt; key) BinarySearch(a, mid + 1, ho, key); else return mid;&#125; &emsp;&emsp;åŒºé—´çš„å¼€é—­è‡ªç”±é€‰å–ï¼Œä¸»è¦æ˜¯è¦ç»Ÿä¸€ï¼Œå¦‚æœè¦æ±‚ä¼ å…¥å·¦é—­å³å¼€åŒºé—´ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°å†…éƒ¨çš„å¤„ç†ä¹Ÿè¦ä¿æŒå·¦é—­å³å¼€ã€‚ä¸€èˆ¬çš„é€‰æ‹©åº”è¯¥æ—¶å·¦å³éƒ½æ˜¯é—­åŒºé—´ï¼Œè€Œåœ¨ç‰¹æ®Šæƒ…å†µæ—¶ï¼ˆæ•°ç»„ä¸­æœ‰å¤šä¸ªç›¸åŒçš„ç›®æ ‡æ—¶ï¼‰ï¼Œè¿™æ—¶é€‰æ‹©å·¦é—­å³å¼€ã€‚ğŸ¥›å‚è€ƒï¼šwikié“¾æ¥&emsp;&emsp;ä¸ºäº†é¿å…ho + lo å¤§äºINT_MAXæœ€å¥½æ”¹ç”¨lo + (ho - lo) / 2 ğŸˆ¶éé€’å½’å¼ 123456789101112int BinarySearch(vector&lt;int&gt;&amp; a, int key) &#123; int lo = 0, ho = a.size(), mid; while(lo &lt; ho) &#123; mid = (lo + ho) / 2; if(a[mid] &gt; key) ho = mid; else if(a[mid] &lt; key) lo = mid + 1; else return mid; &#125; return -1;&#125; é€’å½’è¦æ»¡è¶³ä¸‰ä¸ªåŸåˆ™ï¼š é€’å½’æ€»æœ‰ä¸€ä¸ªæœ€ç®€å•çš„æƒ…å†µâ€”æ–¹æ³•çš„ç¬¬ä¸€å¥æ€»æ˜¯ä¸€ä¸ªåŒ…å«returnçš„æ¡ä»¶è¯­å¥ã€‚ é€’å½’è°ƒç”¨æ€»è¦å°è¯•å–è§£å†³ä¸€ä¸ªè§„æ¨¡æ›´å°çš„å­é—®é¢˜ã€‚ é€’å½’è°ƒç”¨çš„çˆ¶é—®é¢˜å’Œå­é—®é¢˜ä¹‹é—´ä¸åº”è¯¥æœ‰äº¤é›†ã€‚ ğŸ¥˜æ¨èç›¸å…³èµ„æ–™ï¼šè®²è§£ ğŸ‘ç»ƒä¹ é¢˜ç›®1ï¼š4. å¯»æ‰¾ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //é¦–å…ˆè¦åˆ¤å®šæ‹¿ä¸ªåºåˆ—æ›´åŠ é•¿ if(nums1.size() &gt; nums2.size()) swap(nums1, nums2); //å·¦é—­å³å¼€ int imin = 0, imax = nums1.size(), j, i, m = nums1.size(), n = nums2.size(), halflen = (m + n + 1) / 2; while(imin &lt;= imax) &#123; i = (imax + imin ) / 2; j = halflen - i; // cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; if (j &lt;= n &amp;&amp; i &lt; imax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; imin = i + 1; &#125; else if (i &gt; imin &amp;&amp; j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; imax = i; &#125; else &#123; // cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; int leftMax, rightMin; if(i == 0 ) leftMax = nums2[j - 1]; else if(j == 0) leftMax = nums1[i - 1]; else leftMax = max(nums1[i - 1], nums2[j - 1]); if((m + n) % 2) return leftMax; if(i == m) rightMin = nums2[j ]; else if (j == n) rightMin = nums1[ i ]; else rightMin = min(nums1[i], nums2[j]) ; // cout &lt;&lt; leftMax &lt;&lt; rightMin &lt;&lt; endl; return static_cast&lt;double&gt;(leftMax + rightMin) / 2; &#125; &#125; return -1; &#125;&#125;; ğŸ‘ç»ƒä¹ é¢˜ç›®2ï¼š35. æœç´¢æ’å…¥ä½ç½®12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, ho = nums.size() - 1, mid; while(lo &lt; ho) &#123; mid = (lo + ho + 1) / 2; if(nums[mid] &gt; target) &#123; ho = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; if(nums[lo] &lt; target) return lo + 1; else return lo; &#125;&#125;;","categories":[],"tags":[{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"libuvæºç åˆ†æï¼ˆ6ï¼‰uv_queue_work","slug":"libuv6","date":"2019-11-26T12:06:58.000Z","updated":"2019-11-26T12:56:52.025Z","comments":true,"path":"2019/11/26/libuv6/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv6/","excerpt":"","text":"ğŸ¤é—®é¢˜æ¥ç”±&emsp;&emsp;åœ¨ä½¿ç”¨libuvçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éš¾å…é‡è§çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œæœ‰ä¸€äº›åº“æ²¡æœ‰å¼‚æ­¥ã€åªèƒ½åŒæ­¥è¿è¡Œï¼Œè¿™ç§æƒ…å†µè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿæ¯”å¦‚mysql-connector-cppã€‚ &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysql-connector-cppè¿™ç§ä¼šé˜»å¡çš„æ“ä½œæ˜¯ä¸ç¬¦åˆLibuvçš„reactoræ¨¡å¼çš„ã€‚ 123456void handle_json_lab(std::shared_ptr&lt;smpHttp::HttpRequest&gt; req,std::shared_ptr&lt;smpHttp::HttpResponse&gt; res) &#123; try&#123; Session mq = cli.getSession(); auto sqlres = mq.sql(\"Select content FROM labimformation where type = 'labIntroduction'\").execute(); ... &emsp;&emsp;ä¸Šé¢è¿™æ ·ä¾¿æ˜¯é”™è¯¯çš„æ¡ˆä¾‹ã€‚æˆ‘åœ¨å†™è¿™ä¸ªé¡¹ç›®æ—¶ï¼Œä¹‹å‰å°±é‡‡ç”¨äº†è¿™æ ·çš„é”™è¯¯åšæ³•ã€‚&emsp;&emsp;æˆ‘çš„è¿™ä¸ªé¡¹ç›®æ˜¯ä¸ªhttpåå°ï¼Œæˆ‘åœ¨æ¥å—åˆ°POSTè¯·æ±‚ï¼Œç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‰§è¡Œmysqlæ“ä½œï¼Œè¿™æ—¶æ•´ä¸ªä¸»çº¿ç¨‹å°±é˜»å¡ä½äº†1ï¼Œè€Œè¿™å°±æ„å‘³ç€æˆ‘çš„httpåå°ä¸å†èƒ½æ¥å—ä»»ä½•è¯·æ±‚ï¼Œåªèƒ½ç­‰å¾…mysqlæ“ä½œå®Œæˆåï¼Œå›è°ƒå‡½æ•°è¿”å›ã€‚è€Œè¿™ä¸ªmysqlçš„æ“ä½œè€—æ—¶ä¸€èˆ¬åœ¨3sä»¥ä¸Šï¼Œè¿™å¯¹æˆ‘è¿™ä¸ªHttpåå°æ¥è¯´æ˜¯æ¯ç­æ€§çš„æ‰“å‡»ã€‚ã€‚ã€‚ã€‚ 1ï¼šç”¨æˆ·çš„å›è°ƒå‡½æ•°æ˜¯åœ¨work->doneå‡½æ•°çš„æœ€åæ‰§è¡Œçš„ï¼Œè€Œwork->doneæ˜¯åœ¨ä¸»çº¿ç¨‹uv_runä¸­çš„is_pollä¸­å”¤é†’loop->wq_asyncåæ‰§è¡Œçš„,åœ¨work->doneå‡½æ•°ä¸­é˜»å¡æ„å‘³ç€åœ¨ä¸»çº¿ç¨‹é˜»å¡ä½äº†ï¼Œuv_runä¸­çš„äº‹ä»¶å¾ªç¯å¡ä½ï¼Œä¸å†èƒ½æ¥å—requestï¼ˆè¿™éƒ¨åˆ†ä¸æ¸…æ¥šå¯ä»¥å»çœ‹æˆ‘çš„libuvæºç åˆ†ææ–‡ç« ï¼‰ ğŸŒ†è§£å†³åŠæ³•&emsp;&emsp;åœ¨æ‰‹å†ŒThread pool work schedulingä¸­ä¸ºæˆ‘ä»¬è¿™æ ·çš„éœ€æ±‚æä¾›äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼šuv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb)ã€‚ &emsp;&emsp;è¿™ä¸ªå‡½æ•°å°±æ˜¯ä¸Šé¢æˆ‘ä»¬é—®é¢˜çš„è§£å†³åŠæ³•ã€‚ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯uv_async_tä¸å¯ä»¥æ›¿ä»£è¿™ä¸ªã€‚è™½ç„¶éƒ½æ˜¯æ‰§è¡Œç”¨æˆ·çš„å‡½æ•°ã€‚asyncæ˜¯è®©ç”¨æˆ·å‡½æ•°ç›´æ¥è¢«ä¸»çº¿ç¨‹åœ¨uv_runä¸­è¿è¡Œï¼Œè€Œuv_queue_workæ˜¯å°†work_cbæäº¤ç»™å­çº¿ç¨‹æ‰§è¡Œï¼Œå®Œæˆåé€šçŸ¥ä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹åœ¨uv_runä¸­æ‰§è¡Œafter_work_cbã€‚ &emsp;&emsp;æ€»ç»“ä¸‹æ¥å°±æ˜¯ï¼šuv_async_tç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼Œuv_queue_workæ‰§è¡Œè¦é˜»å¡çš„ä»»åŠ¡ï¼ˆè€ƒè™‘åˆ°çº¿ç¨‹åˆ‡æ¢çš„æ¶ˆè€—ä¸€èˆ¬ä¸ç”¨æ¥æ‰§è¡Œä¸é˜»å¡çš„ä»»åŠ¡ï¼‰ ğŸ‰çœ‹çœ‹æºç &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥ç»“åˆè¿™æˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*æ¥çœ‹ã€‚å¯ä»¥ä½œä¸ºä½è¯ï¼Œlibuvä¸­å¯¹ç€è¿™ç±»æ²¡æœ‰è‡ªå¸¦å¼‚æ­¥ç‰ˆæœ¬çš„é˜»å¡æ“ä½œçš„å¤„ç†æ˜¯ä¸€æ ·çš„ï¼šè®©å­çº¿ç¨‹å»æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯ï¼Œå®Œæˆåå­çº¿ç¨‹é€šçŸ¥ä¸»çº¿ç¨‹ã€‚uv_queue_workæºç ï¼š 123456789101112131415161718int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) &#123; if (work_cb == NULL) return UV_EINVAL; uv__req_init(loop, req, UV_WORK); req-&gt;loop = loop; req-&gt;work_cb = work_cb; req-&gt;after_work_cb = after_work_cb; uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, uv__queue_work, uv__queue_done); return 0;&#125; å†ç»“åˆæˆ‘çš„è¿™ç¯‡æ–‡ç« -libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*ä¸­uv_fs_*å‡½æ•°çš„æºç ï¼Œè¿™äº›æ“ä½œå¯ä»¥æ€»ç»“æˆä»¥ä¸‹ä»£ç ï¼š 12345678UV_REQ_INIT(req, typ); //åˆå§‹åŒ–åŸºç±»uv_req_t uv__req_register(loop, req); //æ·»åŠ loopä¸­requestçš„è®¡æ•°ï¼Œé¿å…uv_runä¸­uv__loop_aliveè¿”å›0ï¼Œä½¿å¾—ä¸»çº¿ç¨‹uv_runé€€å‡º...//è¿™é‡Œæ˜¯é’ˆå¯¹ä¸åŒç±»å‹çš„æ“ä½œç‰¹æœ‰çš„åˆå§‹åŒ–éƒ¨åˆ†uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_CPU, //æ“ä½œç±»å‹ uv__queue_work, //è¦é˜»å¡çš„æ“ä½œï¼Œåœ¨fsä¸­æ˜¯uv__fs_work uv__queue_done); //å®Œæˆåçš„å›è°ƒï¼Œåœ¨fsä¸­æ˜¯uv__fs_done","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ5ï¼‰uv_fs_*","slug":"libuv5","date":"2019-11-25T18:57:15.000Z","updated":"2019-11-25T19:41:02.563Z","comments":true,"path":"2019/11/26/libuv5/","link":"","permalink":"http://yoursite.com/2019/11/26/libuv5/","excerpt":"","text":"uv_fs_*&emsp;&emsp;uv_fs_*è¿™ä¸€ç³»åˆ—çš„å‡½æ•°åŸºæœ¬æ˜¯ä¸€è‡´çš„ï¼Œå®ƒä»¬çš„é€»è¾‘å¤§æ¦‚æ˜¯å¦‚ä¸‹ï¼š 123456//xä»£è¡¨ä¸€ç§æ“ä½œopenã€writeç­‰int uv_fs_x(...uv_fs_t* req...) &#123; INIT(x); //uv_fs_tå’Œå…¶åŸºç±»uv_req_tçš„åŸºæœ¬åˆå§‹åŒ– ... //è¿™é‡Œæ˜¯æ¯ä¸ªæ“ä½œå„è‡ªä¸åŒå¯¹äºreqçš„åˆå§‹åŒ– POST; //æäº¤è¿™ä¸ªä»»åŠ¡&#125; INIT&emsp;&emsp;INITè¿™ä¸ªå®å®šä¹‰å‡½æ•°æ²¡æœ‰ç‰¹åˆ«çš„åœ°æ–¹ï¼Œå°±æ˜¯æŠŠreqåˆå§‹åŒ–ï¼Œè¯¥ç½®0çš„ç½®0ã€‚ POST&emsp;&emsp;å…¶å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617#define POST do &#123; //dowhileåŒ…è£¹ä½œç”¨åŸŸ if (cb != NULL) &#123; uv__req_register(loop, req); uv__work_submit(loop, &amp;req-&gt;work_req, UV__WORK_FAST_IO, uv__fs_work, uv__fs_done); return 0; &#125; else &#123; uv__fs_work(&amp;req-&gt;work_req); return req-&gt;result; &#125; &#125; while (0) &emsp;&emsp;è¿™é‡Œé€šè¿‡æœ‰æ— å›è°ƒå‡½æ•°æ¥å†³å®šè°ƒç”¨åŒæ­¥ç‰ˆæœ¬è¿˜æ˜¯å¼‚æ­¥ç‰ˆæœ¬ã€‚ http://docs.libuv.org/en/v1.x/fs.htmllibuv provides a wide variety of cross-platform sync and async file system operations. All functions defined in this document take a callback, which is allowed to be NULL. If the callback is NULL the request is completed synchronously, otherwise it will be performed asynchronously. &emsp;&emsp;uv__fs_workè¿™ä¸ªå‡½æ•°å°±æ˜¯æ–‡ä»¶æ“ä½œçš„å°è£…ï¼Œæ‰€æœ‰çš„æ–‡ä»¶æ“ä½œéƒ½é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥å®Œæˆï¼Œå³ä½¿æ˜¯å¼‚æ­¥ï¼Œæœ€ç»ˆä¹Ÿè¦åœ¨åˆ«çš„çº¿ç¨‹ä¸­åŒæ­¥æ‰§è¡Œè¿™ä¸ªå‡½æ•°ã€‚ &emsp;&emsp;uv__fs_doneè¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨ç”¨æˆ·ç»™çš„å›è°ƒå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨uv_runä¸­çš„is_pollå‡½æ•°ä¸­å¾—åˆ°æ‰§è¡Œã€‚ &emsp;&emsp;uv__work_submitå‡½æ•°çš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678910void uv__work_submit(uv_loop_t* loop,struct uv__work* w,enum uv__work_kind kind, void (*work)(struct uv__work* w),void (*done)(struct uv__work* w, int status)) &#123; uv_once(&amp;once, init_once); w-&gt;loop = loop; w-&gt;work = work; w-&gt;done = done; post(&amp;w-&gt;wq, kind);&#125; &emsp;&emsp;uv_once(&amp;once, init_once);æ˜¯åˆå§‹åŒ–å¤šä¸ªçº¿ç¨‹ï¼Œæˆ‘åœ¨æˆ‘çš„ç¬¬ä¸‰ç¯‡æ–‡ç« ä¸­æœ‰ä»‹ç»ã€‚ä¸è¿‡å½“æ—¶å¯¹äºå­çº¿ç¨‹è¿è¡Œçš„workerå‡½æ•°æ²¡æœ‰æåŠï¼Œworkå‡½æ•°å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š 123456789101112131415161718192021222324252627282930static void worker(void* arg) &#123; ... uv_mutex_lock(&amp;mutex); for (;;) &#123; while (QUEUE_EMPTY(&amp;wq)...) &#123; idle_threads += 1; uv_cond_wait(&amp;cond, &amp;mutex); idle_threads -= 1; &#125; q = QUEUE_HEAD(&amp;wq); ... QUEUE_REMOVE(q); QUEUE_INIT(q); ... w = QUEUE_DATA(q, struct uv__work, wq); w-&gt;work(w); uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex); w-&gt;work = NULL; QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); uv_async_send(&amp;w-&gt;loop-&gt;wq_async); uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); uv_mutex_lock(&amp;mutex); ... &#125;&#125; &emsp;&emsp;æˆ‘å»æ‰äº†å¯¹äºslow_ioçš„å¤„ç†ï¼Œå¤§è‡´æ˜¯è¿™æ ·ä¸€ä¸ªè¿‡ç¨‹ã€‚ &emsp;&emsp;ä¸€å¼€å§‹çº¿ç¨‹ä¼šå¡åœ¨uv_cond_waitè¿™é‡Œï¼Œç›´åˆ°è¢«uv_cond_signalå”¤é†’ï¼Œå¦‚æœå”¤é†’æ—¶wqé˜Ÿåˆ—ä¸­æœ‰ä»»åŠ¡ï¼Œå®ƒå°±ä¼šæ‰§è¡Œä»»åŠ¡ï¼Œw-&gt;work(w)ä¹Ÿå°±æ˜¯è°ƒç”¨uv__fs_workã€‚ç„¶åæŠŠwæ”¾å…¥loop-&gt;wqï¼ˆä¸ºäº†uv__fs_doneçš„æ‰§è¡Œï¼‰ã€‚ &emsp;&emsp;uv_async_sendè°ƒç”¨è®©loop-&gt;wq_asyncå¯è¯»ï¼Œä¸»çº¿ç¨‹å°±ä»uv_runä¸­çš„uv__io_pollçš„epoll_pwaitä¸­é†’æ¥ï¼Œwq_asyncçš„å›è°ƒå‡½æ•°ä¼šéå†loop-&gt;wqæ‰§è¡Œw-&gt;doneã€‚ï¼ˆæˆ‘çš„ç¬¬å››ç¯‡æ–‡ç« æœ‰è®²è¿™ä¸€éƒ¨åˆ†çš„è¯¦ç»†å†…å®¹ï¼‰ è°æ¥è§¦å‘uv_cond_signalå”¤é†’å­çº¿ç¨‹å‘¢ï¼ŸğŸ¥£uv__work_submitä¸­çš„postå‡½æ•°ï¼š 123456uv_mutex_lock(&amp;mutex);...QUEUE_INSERT_TAIL(&amp;wq, q);if (idle_threads &gt; 0) uv_cond_signal(&amp;cond);uv_mutex_unlock(&amp;mutex); &emsp;&emsp;æˆ‘å†æ¬¡çœç•¥äº†slow_ioçš„éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒä»¬åªæ˜¯ç‰¹æ®Šå¤„ç†ã€‚ &emsp;&emsp;è¯¥å‡½æ•°æœ‰ç©ºé—²çš„çº¿ç¨‹å°±å”¤é†’ï¼Œä¸ç„¶å°±é˜»å¡è¯¥çº¿ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ4ï¼‰async","slug":"libuv4","date":"2019-11-24T18:19:34.000Z","updated":"2019-11-25T19:24:48.508Z","comments":true,"path":"2019/11/25/libuv4/","link":"","permalink":"http://yoursite.com/2019/11/25/libuv4/","excerpt":"","text":"uv_async_init&emsp;&emsp;libuvä¸­asyncçš„å¼€ç«¯åœ¨uv_loop_initå‡½æ•°ä¸­ï¼š 12345678//å‰é¢çœç•¥err = uv_async_init(loop, &amp;loop-&gt;wq_async, uv__work_done);if (err) goto fail_async_init;uv__handle_unref(&amp;loop-&gt;wq_async);loop-&gt;wq_async.flags |= UV_HANDLE_INTERNAL;//åé¢çœç•¥ &emsp;&emsp;loop-&gt;wq_asyncæ˜¯ä¸ªuv_async_tç±»å‹ï¼Œå®ƒç”¨äºçº¿ç¨‹workå‡½æ•°è°ƒç”¨æœ€åå¤„ç†loop-&gt;wqä¸­çš„å›è°ƒï¼Œæš‚æ—¶ä¸ç”¨ç®¡,æˆ‘åœ¨æˆ‘çš„ç¬¬äº”ç¯‡æ–‡ç« ä¼šè®²åˆ°å®ƒçš„ç”¨é€”ã€‚&emsp;&emsp;æˆ‘ä»¬æ¥çœ‹uv_async_initå†…éƒ¨ï¼š 12345678910111213int err;err = uv__async_start(loop);if (err) return err;uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);handle-&gt;async_cb = async_cb;handle-&gt;pending = 0;QUEUE_INSERT_TAIL(&amp;loop-&gt;async_handles, &amp;handle-&gt;queue);uv__handle_start(handle);return 0; &emsp;&emsp;ç¬¬äº”è¡Œä»¥åçš„æ“ä½œå°±æ˜¯åˆå§‹åŒ–åŸºç±»uv_handle_tä»¥åŠå­ç±»uv_async_tï¼Œç„¶åå°†è¿™ä¸ªhandleæ”¾å…¥loop-&gt;queue(æ”¾uv_handle_tçš„é˜Ÿåˆ—)ä»¥åŠæ”¾å…¥loop-&gt;async_handlesï¼ˆæ”¾uv_async_tçš„é˜Ÿåˆ—ï¼‰ä¸­ï¼Œç„¶åuv__handle_startä¸­å°†loop-&gt;active_handlesåŠ ä¸€ã€‚&emsp;&emsp;æ€»è€Œè¨€ä¹‹ï¼Œç¬¬äº”è¡Œä»¥åçš„å†…å®¹å°±æ˜¯åˆå§‹åŒ–uv_async_tï¼Œå¯ä»¥ç†è§£æˆuv_async_tçš„æ„é€ å‡½æ•°ã€‚&emsp;&emsp;uv__async_startåˆ™ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯åˆå§‹åŒ–å‡½æ•°ï¼Œå®ƒåªä¼šè°ƒç”¨ä¸€æ¬¡ï¼ˆä¸€èˆ¬æƒ…å†µæ˜¯åœ¨uv_loop_initä¸­è°ƒç”¨ï¼‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹å®ƒçš„å®ç°ï¼š 1234567891011121314151617181920static int uv__async_start(uv_loop_t* loop) &#123; int pipefd[2]; int err; if (loop-&gt;async_io_watcher.fd != -1) return 0; err = uv__async_eventfd(); if (err &gt;= 0) &#123; pipefd[0] = err; pipefd[1] = -1; &#125; //ä¸­é—´çœç•¥ uv__io_init(&amp;loop-&gt;async_io_watcher, uv__async_io, pipefd[0]); uv__io_start(loop, &amp;loop-&gt;async_io_watcher, POLLIN); loop-&gt;async_wfd = pipefd[1]; return 0;&#125; &emsp;&emsp;çœ‹ç¬¬ä¸‰è¡Œloop-&gt;async_io_watcher.fdï¼Œå½“ä½ è°ƒç”¨è¿‡ä¸€æ¬¡è¿™ä¸ªå‡½æ•°åï¼Œloop-&gt;async_io_watcher.fdä¸ä¼šç­‰äº-1ï¼Œä»¥åä½ åˆå§‹åŒ–uv_async_tç±»å‹å˜é‡ï¼Œè°ƒç”¨uv_async_initå‡½æ•°æ—¶ï¼Œuv__async_startéƒ½æ˜¯ç›´æ¥è¿”å›çš„ã€‚&emsp;&emsp;æˆ‘çœç•¥æ‰äº†ä¸­é—´å¦‚æœeventfdæ²¡æœ‰åœ¨å½“å‰ç³»ç»Ÿä¸‹å®ç°æ—¶çš„å…¼å®¹æ€§å¤„ç†ã€‚æ€»çš„æ¥è¯´ï¼Œå°±æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherã€‚uv__io_tæ˜¯ä¸ºepollè®¾è®¡çš„ç»“æ„ä½“ã€‚è¿™é‡Œä½ è‚¯å®šæ„Ÿè§‰å¾ˆæ‡µé€¼ï¼Œè¯·åšæŒä¸€ä¸‹ï¼Œæœ€åæˆ‘ä¼šæ¢³ç†ä¸€ä¸‹æ€»ä½“çš„æ•´ä¸ªè¿‡ç¨‹ã€‚&emsp;&emsp;uv__io_tçš„å®ç°æ˜¯è¿™æ ·çš„ï¼š 12345678uv__io_t&#123; uv__io_cb cb; //å›è°ƒå‡½æ•° void* watcher_queue[2]; //æ”¾å…¥loop-&gt;watcher_queue void* pending_queue[2]; //åŒç† unsigned int pevents; /* Pending event mask i.e. mask at next tick. */ unsigned int events; /* Current event mask. */ int fd; //æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºepollæ³¨å†Œ&#125; &emsp;&emsp;è¿™é‡Œuv__io_initå‡½æ•°æ˜¯åˆå§‹åŒ–loop-&gt;async_io_watcherè¿™ä¸ªç»“æ„ä½“ï¼š 123456QUEUE_INIT(&amp;w-&gt;pending_queue);QUEUE_INIT(&amp;w-&gt;watcher_queue);w-&gt;cb = cb;w-&gt;fd = fd; //å‰é¢æˆ‘ä»¬çš„eventfdw-&gt;events = 0;w-&gt;pevents = 0; &emsp;&emsp;uv__io_startå°†loop-&gt;async_io_watcheræ”¾å…¥loop-&gt;watcher_queueã€‚è¿˜æœ‰å¯¹äºloop-&gt;nfdså¤§å°çš„å¤„ç†ã€‚ 1234567if (QUEUE_EMPTY(&amp;w-&gt;watcher_queue)) QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);if (loop-&gt;watchers[w-&gt;fd] == NULL) &#123; loop-&gt;watchers[w-&gt;fd] = w; loop-&gt;nfds++;&#125; &emsp;&emsp;ç¬¬å››è¡Œä»¥åçš„æ“ä½œæ˜¯ä¸ºäº†åœ¨epollåï¼Œæˆ‘ä»¬å¾—åˆ°struct eventç»“æ„ä½“ï¼Œæˆ‘ä»¬ä»event-&gt;data.fdå¯ä»¥å¾—åˆ°fdï¼Œé‚£æˆ‘ä»¬å¦‚ä½•è·å–åˆ°å¯¹åº”çš„uv__io_tå‘¢ï¼Ÿ å°±æ˜¯é€šè¿‡loop-&gt;watchersè¿™ä¸ªæ•°ç»„ã€‚ uv_async_send123456789101112131415161718int uv_async_send(uv_async_t* handle) &#123; /* Do a cheap read first. */ if (ACCESS_ONCE(int, handle-&gt;pending) != 0) return 0; /* Tell the other thread we're busy with the handle. */ if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) != 0) return 0; /* Wake up the other thread's event loop. */ uv__async_send(handle-&gt;loop); /* Tell the other thread we're done. */ if (cmpxchgi(&amp;handle-&gt;pending, 1, 2) != 1) abort(); return 0;&#125; &emsp;&emsp;ACCESS_ONCEï¼š 12#define ACCESS_ONCE(type, var) \\ (*(volatile type*) &amp;(var)) &emsp;&emsp;è¿™é‡Œè°ƒç”¨ä¸€æ¬¡ACCESS_ONCEï¼Œæ˜¯ä¸ºäº†å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œhandle-&gt;pendingå¯èƒ½è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼Œæ‰€ä»¥åˆ«ç»™æˆ‘ä¹±ä¼˜åŒ–ã€‚&emsp;&emsp;cmpxchgiæ˜¯åŸå­æ“ä½œcompare_and_changeã€‚pendingçš„æœ‰ä¸‰ä¸ªå–å€¼0ï¼Œ1ï¼Œ2ã€‚0ä»£è¡¨é—²ç½®ã€1ä»£è¡¨å¿™ï¼ˆæ¯”å¦‚uv_async_sendè°ƒç”¨é€”ä¸­ï¼‰ã€2ä»£è¡¨å®Œæˆã€‚loop-&gt;async_io_watcherè°ƒç”¨uv__async_ioæ—¶ï¼Œä¼šéå†loop-&gt;async_handlesï¼Œé€šè¿‡pendingæ¥åˆ¤æ–­å“ªäº›å›è°ƒè¯¥è¢«æ‰§è¡Œã€‚&emsp;&emsp;uv__async_sendå°±æ˜¯å‘loop-&gt;async_io_watcher.fdï¼ˆeventfdï¼‰å†™ï¼ˆè¿™é‡Œå…³ç³»åˆ°eventfdçš„æœºåˆ¶ï¼Œä¸æ‡‚å¯ä»¥man eventfdï¼‰ã€‚ æ•´ä½“è°ƒç”¨è¿‡ç¨‹&emsp;&emsp;è¿™é‡Œæ€»ä½“å½’çº³ä¸€ä¸‹asyncçš„è¿‡ç¨‹ã€‚&emsp;&emsp;1.åœ¨loop_uv_initä¸­åˆå§‹åŒ–async_io_watcherï¼Œå®ƒçš„fdä¸ºeventfdï¼Œå€¼ä¸º0ï¼Œä¸å¯è¯»ã€‚&emsp;&emsp;2.ç”¨æˆ·uv_async_initæ³¨å†Œuv_async_tå˜é‡ï¼Œè¢«æ·»åŠ åˆ°loop-&gt;async_handlesï¼Œè®¾ç½®å›è°ƒå‡½æ•°ã€‚&emsp;&emsp;3.å¦‚æœå¯¹uv_async_tå˜é‡è°ƒç”¨uv_async_sendï¼Œé‚£ä¹ˆuv_async_tå˜é‡çš„pendingå˜ä¸º2ï¼ˆdoneï¼‰ï¼Œå¹¶ä¸”å‘eventfdå†™ï¼Œloop-&gt;async_io_watcherå¯è¯»äº†ã€‚&emsp;&emsp;4.åœ¨uv_runçš„uv__io_pollä¸­ï¼Œæ¯æ¬¡éƒ½ä¼šæŠŠloop-&gt;watchersæ³¨å†Œåˆ°epollä¸­ï¼Œç¬¬å››æ­¥è¿™ä¸ªè¿‡ç¨‹åœ¨æ¯æ¬¡äº‹ä»¶å¾ªç¯ä¸­éƒ½åœ¨æ‰§è¡Œã€‚å¦‚æœasync_io_watcherçš„fdä¸å¯è¯»ï¼Œå°±æ²¡å®ƒäº‹å„¿ã€‚å¦‚æœå¯è¯»ï¼Œasync_io_watcherçš„å›è°ƒå‡½æ•°uv__async_ioæ‰§è¡Œï¼Œå®ƒéå†loop-&gt;async_handlesï¼Œå°†å…¶ä¸­pendingä¸º2çš„uv_async_tå˜é‡ç§»é™¤é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œå…¶å›è°ƒå‡½æ•°ã€‚ çœ‹æºç åå†™çš„å°DEMOï¼š https://github.com/LurenAA/simple_imitation_of_libuv","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"ssh: connect to host github.com port 22: Connection refused","slug":"problems1","date":"2019-11-24T09:25:01.000Z","updated":"2019-11-24T15:54:24.892Z","comments":true,"path":"2019/11/24/problems1/","link":"","permalink":"http://yoursite.com/2019/11/24/problems1/","excerpt":"","text":"12cd vim .ssh/config ä½ ä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­æ·»åŠ ä»¥ä¸‹æ–‡å­—ï¼š 123456Host github.comUser ä½ çš„ç”¨æˆ·åï¼ˆä¾‹å¦‚97860xx@qq.comï¼‰Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 ç„¶åä¿å­˜é€€å‡ºï¼ˆä»£ç å¦‚ä¸‹ï¼‰ã€‚ 1:wq æ¥ä¸‹æ¥æµ‹è¯•ä¸€ä¸‹ï¼š 1ssh -T git@github.com å‡ºç°ä¸‹é¢çš„ç”»é¢ï¼šåœ¨å›¾ç‰‡å€’æ•°ç¬¬äº”è¡Œçš„åœ°æ–¹ä¼šè¯¢é—®æ˜¯å¦å»ºç«‹è¿æ¥ï¼Œè¾“å…¥yeså³å¯ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"libuvæºç åˆ†æï¼ˆ3ï¼‰init_threads","slug":"libuv3","date":"2019-11-17T18:14:58.000Z","updated":"2019-11-24T15:54:16.931Z","comments":true,"path":"2019/11/18/libuv3/","link":"","permalink":"http://yoursite.com/2019/11/18/libuv3/","excerpt":"","text":"ç”±æ¥&emsp;&emsp;åœ¨æˆ‘ä»¬ç¬¬ä¸€æ¬¡æäº¤ioæ“ä½œæ—¶ï¼Œä¼šæœ‰uv_onceè¢«è°ƒç”¨ï¼Œæ¥æ£€æµ‹æ˜¯å¦åˆå§‹åŒ–è¿‡çº¿ç¨‹æ± ï¼Œå¦‚æœæ²¡æœ‰åˆ™ç«‹åˆ»åˆå§‹åŒ–çº¿ç¨‹æ± ã€‚æ‰€ä»¥è¯´çº¿ç¨‹æ± å¹¶éä¸€å¼€å§‹åœ¨uv_runçš„æ—¶å€™æˆ–è€…åœ¨loopä¸­åˆå§‹åŒ–çš„ï¼Œè€Œæ˜¯åœ¨ioæ“ä½œå¼€å§‹å‰ã€‚æˆ‘ä»¥uv_openä¸ºä¾‹å­ç”»ä¸€ä¸‹UMLå›¾å¦‚ä¸‹ï¼šåœ¨uv_openä¸­å…ˆåˆå§‹åŒ–reqï¼Œç„¶åå‡†å¤‡æäº¤workï¼Œæäº¤å‰ä¼šè°ƒç”¨uv_onceæ£€æµ‹æ˜¯å¦åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œæ²¡æœ‰åˆ™åˆå§‹åŒ–ã€‚ init_onceuv_onceå®ç°å¦‚ä¸‹ï¼š 1234567891011121314#define UV_ONCE_INIT PTHREAD_ONCE_INITstatic uv_once_t once = UV_ONCE_INIT;static void init_once(void) &#123;#ifndef _WIN32 /* Re-initialize the threadpool after fork. * Note that this discards the global mutex and condition as well * as the work queue. */ if (pthread_atfork(NULL, NULL, &amp;reset_once)) abort();#endif init_threads();&#125; åœ¨uv__work_submitä¸­uv_onceæ˜¯è¿™æ ·è¢«è°ƒç”¨çš„ï¼š 1234void uv__work_submit(...) &#123; uv_once(&amp;once, init_once); ...&#125; &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯ä»¥å‚çœ‹TLPI 31.2éƒ¨åˆ†ï¼Œlibuvå¤šåšäº†pthread_atforkçš„å¤„ç†ã€‚&emsp;&emsp;pthread_atforkæ³¨å†Œreset_onceå‡½æ•°ï¼Œåœ¨forkä¹‹åé‡ç½®onceï¼Œä¿è¯åœ¨libuvå¾ªç¯ä¸­å¦‚æœä½ forkäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œå¦‚æœåœ¨é‚£ä¸ªæ–°çš„è¿›ç¨‹ä¸­ä½ ä¹Ÿå¯åŠ¨ä¸€ä¸ªlibuvï¼Œinit_threads()èƒ½è¢«è°ƒç”¨ã€‚ init_threadsğŸ¤æ¡ä»¶å˜é‡&emsp;&emsp;libuvåˆå§‹åŒ–æ¡ä»¶å˜é‡æ—¶ï¼Œè°ƒç”¨è‡ªå·±çš„uv_cond_initï¼Œè¿™ä¸ªå‡½æ•°åªåšäº†ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å°†æ¡ä»¶å˜é‡çš„æ—¶é’Ÿè®¾ç½®ä¸ºç›¸å¯¹æ—¶é—´ï¼Œè¿™ä¸€ç‚¹æ˜¯å€¼å¾—æˆ‘ä»¬è‡ªå·±å†™ä»£ç æ—¶å‚è€ƒçš„ï¼Œç›¸å¯¹æ—¶é—´ä¸å—ç³»ç»Ÿæ—¶é—´çš„å½±å“ã€‚ 12345int uv_cond_init(uv_cond_t* cond) &#123; ... err = pthread_condattr_setclock(&amp;attr, CLOCK_MONOTONIC); ...&#125; ğŸ¥›äº’æ–¥é”&emsp;&emsp;åˆå§‹åŒ–äº’æ–¥é”æ—¶ï¼Œè°ƒç”¨uv_mutex_initï¼Œåœ¨DEBUGæ—¶ï¼Œlibuvä¼šå°†äº’æ–¥é”è®¾ç½®ä¸ºPTHREAD_MUTEX_ERRORCHECKï¼Œè¿™æ ·èƒ½è‡ªæˆ‘æ£€æµ‹æ˜¯å¦ä¸ºæ­»é”ï¼Œä¸è¿‡è¿™ä¼šæ¶ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ä¸ºé»˜è®¤å€¼ã€‚ 123456789int uv_mutex_init(uv_mutex_t* mutex) &#123;#if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK) return UV__ERR(pthread_mutex_init(mutex, NULL));#else ... if (pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK)) abort(); ...&#125; PTHREAD_MUTEX_ERRORCHECKThis type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error. A thread attempting to unlock a mutex which another thread has locked shall return with an error. A thread attempting to unlock an unlocked mutex shall return with an error. ğŸ¥¡ä¿¡å·é‡&emsp;&emsp;åˆå§‹åŒ–æ¯ä¸ªçº¿ç¨‹æ—¶ï¼Œlibuvç”¨ä¿¡å·é‡æ¥ä¿è¯init_threadså‡½æ•°åœ¨åˆå§‹åŒ–å®Œæ‰€æœ‰çº¿ç¨‹åé€€å‡ºã€‚ 1234567891011if (uv_sem_init(&amp;sem, 0)) abort(); for (i = 0; i &lt; nthreads; i++) if (uv_thread_create(threads + i, worker, &amp;sem)) abort(); for (i = 0; i &lt; nthreads; i++) uv_sem_wait(&amp;sem); uv_sem_destroy(&amp;sem); åœ¨linuxä¸‹å¹¶ä¸”glibcç‰ˆæœ¬å¤§äº2.21æ—¶ï¼Œuv_sem_init(&amp;sem, 0)å’Œsem_init(&amp;sem, 0)æ˜¯ä¸€æ ·çš„ï¼Œæ²¡æœ‰é¢å¤–çš„å¤„ç†ã€‚çº¿ç¨‹åˆ›å»ºå¥½åï¼Œåœ¨workerå‡½æ•°ä¸­ä¼šè°ƒç”¨uv_sem_posté‡Šæ”¾ä¿¡å·é‡ã€‚ 12345static void worker(void* arg) &#123; ... uv_sem_post((uv_sem_t*) arg); ... &#125; ğŸ¥šuv_thread_create&emsp;&emsp;uv_thread_createåšçš„äº‹æƒ…å°±æ˜¯è®¾ç½®çº¿ç¨‹çš„stackå¤§å°ï¼Œç„¶ååˆ›å»ºå®ƒã€‚thread_stack_sizeå‡½æ•°è·å–æ ˆå¤§å°ï¼Œæœ‰ä¸€äº›æ˜¯è·¨å¹³å°å…¼å®¹æ€§çš„å¤„ç†ã€‚ 123lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); å’Œif (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; ä¸Šé¢ä¸¤è¡Œçš„é™åˆ¶æ˜¯æ¥æºäºpthread_attr_setstacksizeå‡½æ•°ï¼Œä¸€ä¸‹æ˜¯pthread_attr_setstacksizeå‡½æ•°manæ‰‹å†Œçš„ä¸€éƒ¨åˆ†ã€‚ ERRORS pthread_attr_setstacksize() can fail with the following error:EINVAL The stack size is less than PTHREAD_STACK_MIN (16384) bytes. On some systems, pthread_attr_setstacksize() can fail with the error EINVAL if stacksize is not a multiple of the system page size. 1234567891011121314151617181920212223242526272829static size_t thread_stack_size(void) &#123;#if defined(__APPLE__) || defined(__linux__) struct rlimit lim; if (getrlimit(RLIMIT_STACK, &amp;lim)) abort(); if (lim.rlim_cur != RLIM_INFINITY) &#123; /* pthread_attr_setstacksize() expects page-aligned values. */ lim.rlim_cur -= lim.rlim_cur % (rlim_t) getpagesize(); /* Musl's PTHREAD_STACK_MIN is 2 KB on all architectures, which is * too small to safely receive signals on. * * Musl's PTHREAD_STACK_MIN + MINSIGSTKSZ == 8192 on arm64 (which has * the largest MINSIGSTKSZ of the architectures that musl supports) so * let's use that as a lower bound. * * We use a hardcoded value because PTHREAD_STACK_MIN + MINSIGSTKSZ * is between 28 and 133 KB when compiling against glibc, depending * on the architecture. */ if (lim.rlim_cur &gt;= 8192) if (lim.rlim_cur &gt;= PTHREAD_STACK_MIN) return lim.rlim_cur; &#125; ... return 2 &lt;&lt; 20; /* glibc default. */#endif ğŸ˜‚æ— è¶£çš„æ˜¯åœ¨linux Ubuntusæˆ‘çš„ç¯å¢ƒä¸‹æµ‹è¯•æ—¶ï¼Œattrçš„é»˜è®¤stacksizeå’Œthread_stack_sizeå‡½æ•°è®¾ç½®åˆ°çš„æ˜¯ä¸€æ ·çš„å€¼ã€‚ä¸‹é¢æ˜¯æˆ‘çš„æµ‹è¯•ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;uv.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;malloc.h&gt;#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;using namespace std;void a(void *) &#123; cout &lt;&lt; 123 &lt;&lt; endl;&#125;size_t stack_page() &#123; rlimit x; assert(getrlimit(RLIMIT_STACK, &amp;x) == 0); size_t stack_size = x.rlim_cur - x.rlim_cur % getpagesize(); cout &lt;&lt; stack_size &lt;&lt; endl; if(stack_size &gt; PTHREAD_STACK_MIN) return stack_size;&#125;int main() &#123; pthread_attr_t attr; assert(pthread_attr_init(&amp;attr) == 0); size_t stack_size; pthread_attr_getstacksize(&amp;attr, &amp;stack_size); cout &lt;&lt; stack_size &lt;&lt; endl; stack_size = stack_page(); pthread_attr_setstacksize(&amp;attr, stack_size); pthread_t p1; pthread_create(&amp;p1, &amp;attr, (void* (*)(void*))a, nullptr); pthread_attr_destroy(&amp;attr); return 0;&#125;","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ2ï¼‰uv__loop_alive","slug":"libuv2","date":"2019-11-16T09:58:11.000Z","updated":"2019-11-24T15:54:12.877Z","comments":true,"path":"2019/11/16/libuv2/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv2/","excerpt":"","text":"å‰è¨€&emsp;&emsp;ä¸Šä¸€ç¯‡è¯´äº†ä¸€ä¸‹æ•´ä½“çš„äº‹ä»¶å¾ªç¯ï¼Œå¯¹äºUV_RUN_DEFAULTæ¨¡å¼æ¥è°ƒç”¨uv_runæ¥è¯´ï¼Œuv__loop_aliveå°±å†³å®šäº†æ˜¯å¦é€€å‡ºï¼Œè¿™ä¸€ç¯‡çœ‹ä¸€ä¸‹uv__loop_aliveçš„æºç ã€‚ è¯¦æƒ…12345static int uv__loop_alive(const uv_loop_t* loop) &#123; return uv__has_active_handles(loop) || uv__has_active_reqs(loop) || loop-&gt;closing_handles != NULL;&#125; &emsp;&emsp;å¯è§loopçš„çŠ¶æ€å–å†³äºä¸‰ä¸ªæ–¹é¢ï¼šhandlesã€reqsã€closing_handles handles&emsp;&emsp;uv__has_active_handleså°±æ˜¯æ£€æŸ¥loop-&gt;active_handleså€¼æ˜¯å¦å¤§äº0. 12#define uv__has_active_handles(loop) \\ ((loop)-&gt;active_handles &gt; 0) 12345678910111213141516171819/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t; &emsp;&emsp;handlesåˆ—è¡¨å¦‚ä¸Šã€‚handleåœ¨è°ƒç”¨æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªå‡½æ•°çš„è°ƒç”¨ï¼Œå°±æ˜¯uv__handle_startã€‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ˜¯å“ªäº›å‡½æ•°è°ƒç”¨äº†uv__handle_startã€‚æœ‰ä¸€äº›handleä¸åœ¨å…¶ä¸­ï¼Œå¯èƒ½ä¸å…¶è°ƒç”¨æ–¹å¼æœ‰å…³ï¼Œæˆ‘æš‚æ—¶æ— æ³•è§£é‡Š 1234567#define uv__handle_start(h) \\ do &#123; \\ if (((h)-&gt;flags &amp; UV_HANDLE_ACTIVE) != 0) break; \\ (h)-&gt;flags |= UV_HANDLE_ACTIVE; \\ if (((h)-&gt;flags &amp; UV_HANDLE_REF) != 0) uv__active_handle_add(h); \\ &#125; \\ while (0) &emsp;&emsp;uv__handle_startå‡½æ•°åœ¨è°ƒç”¨æ—¶ï¼Œä¼šè°ƒç”¨uv__active_handle_addï¼Œuv__active_handle_addå°±æ˜¯å°†loop-&gt;active_handles++ 12345#define uv__active_handle_add(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles++; \\ &#125; \\ while (0) &emsp;&emsp;ç›¸åº”çš„åœ¨handleç»“æŸæ—¶æœ‰uv__active_handle_rmçš„è°ƒç”¨ï¼Œ(h)-&gt;loop-&gt;active_handleså‡ä¸€ã€‚ 12345#define uv__active_handle_rm(h) \\ do &#123; \\ (h)-&gt;loop-&gt;active_handles--; \\ &#125; \\ while (0) req&emsp;&emsp;uv__has_active_reqså’Œhandleçš„é“ç†ä¸€æ ·ï¼Œæ˜¯æ£€æµ‹(loop)-&gt;active_reqs.count &gt; 0ã€‚active_reqsæ˜¯ä¸ªå…±ç”¨ä½“ï¼Œå®ƒçš„å¦ä¸€ä¸ªç”¨é€”æš‚æ—¶æˆ‘è¿˜ä¸çŸ¥é“ã€‚ 12#define uv__has_active_reqs(loop) \\ ((loop)-&gt;active_reqs.count &gt; 0) 12345678910/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t; &emsp;&emsp;uv__req_register(loop, req)ç­‰åŒäºhandleçš„uv__active_handle_addã€‚uv__req_registeråœ¨uv__req_initä¸­è°ƒç”¨ï¼Œå‡ ä¹ï¼ˆæ¼ç½‘çš„æš‚æ—¶æ²¡æ³•è§£é‡Š ï¼‰æ¯ä¸ªreqåœ¨åˆå§‹åŒ–æ—¶éƒ½è°ƒç”¨äº†uv__req_initã€‚ 123456789101112#define uv__req_init(loop, req, typ) \\ do &#123; \\ UV_REQ_INIT(req, typ); \\ uv__req_register(loop, req); \\ &#125; \\ while (0) #define uv__req_register(loop, req) \\ do &#123; \\ (loop)-&gt;active_reqs.count++; \\ &#125; \\ while (0) &emsp;&emsp;ä¸‹å›¾æ‰€ç¤ºæ˜¯é‚£äº›å‡½æ•°è°ƒç”¨äº†uv__req_initï¼Œç”±åç§°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥å®ƒä»¬æ˜¯å±äºå“ªäº›reqçš„ã€‚&emsp;&emsp;åŒç†ï¼Œè¿˜æœ‰uv__req_unregisterã€‚ 123456#define uv__req_unregister(loop, req) \\ do &#123; \\ assert(uv__has_active_reqs(loop)); \\ (loop)-&gt;active_reqs.count--; \\ &#125; \\ while (0) closing_handles&emsp;&emsp;è¦å…³é—­çš„handleä¼šä»¥é“¾è¡¨çš„å½¢å¼æŒ‚åœ¨loop-&gt;closing_handlesä¸Šã€‚è¿™ä¸ªæ“ä½œé€šè¿‡è°ƒç”¨uv__make_close_pendingæ¥å®ç°ã€‚ 123456void uv__make_close_pending(uv_handle_t* handle) &#123; assert(handle-&gt;flags &amp; UV_HANDLE_CLOSING); assert(!(handle-&gt;flags &amp; UV_HANDLE_CLOSED)); handle-&gt;next_closing = handle-&gt;loop-&gt;closing_handles; handle-&gt;loop-&gt;closing_handles = handle;&#125; å¦‚æœclosing_handlesä¸ä¸ºç©ºï¼Œé‚£ä¹ˆè¿˜éœ€è¦è¿›å…¥äº‹ä»¶å¾ªç¯ï¼Œå»è°ƒç”¨å…³é—­çš„handleçš„å›è°ƒå‡½æ•°ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"libuvæºç åˆ†æï¼ˆ1ï¼‰äº‹ä»¶å¾ªç¯åˆ†æ","slug":"libuv1","date":"2019-11-16T08:45:44.000Z","updated":"2019-11-24T15:54:06.502Z","comments":true,"path":"2019/11/16/libuv1/","link":"","permalink":"http://yoursite.com/2019/11/16/libuv1/","excerpt":"","text":"å‰è¨€ &emsp;&emsp;libuvæ€»æ˜¯æŠ¥å‡ºä¸€äº›è®©äººéš¾ä»¥ç†è§£çš„é”™è¯¯ğŸ˜‚ï¼Œä½œä¸ºä¸€ä¸ªCçš„é¡¹ç›®ï¼Œä¸å…·æœ‰Javaã€JavaScriptã€phpé‚£æ ·çš„äººæ°”ï¼Œå¾ˆéš¾ç™¾åº¦åˆ°ä¸€äº›é—®é¢˜çš„ç­”æ¡ˆï¼Œç”šè‡³googleä¹Ÿä¸è¡Œã€‚ä¸ºäº†ç”¨å¥½libuvï¼Œä¹Ÿä¸ºäº†å­¦ä¹ å§ã€‚æˆ‘å¼€å§‹çœ‹libuvçš„æºç ï¼Œä¸çŸ¥é“è‡ªå·±èƒ½èµ°å¤šè¿œã€‚ã€‚ã€‚ äº‹ä»¶å¾ªç¯ è¿™æ˜¯å®˜æ–¹äº‹ä»¶å¾ªç¯çš„ç¤ºæ„å›¾ã€‚é“¾æ¥-&gt;å®˜æ–¹å›¾ç‰‡ä½ç½® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); uv__run_timers(loop); ran_pending = uv__run_pending(loop); uv__run_idle(loop); uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); uv__io_poll(loop, timeout); uv__run_check(loop); uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; /* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; &emsp;&emsp;æ•´ä¸ªäº‹ä»¶å¾ªç¯å°±æ˜¯åœ¨ä¸»çº¿ç¨‹çš„uv_runï¼ˆï¼‰è°ƒç”¨ä¸­æ‰§è¡Œçš„ã€‚æˆ‘å°±è·Ÿç€å®˜æ–¹çš„ä»‹ç»ä¸€æ­¥ä¸€æ­¥æ¥çœ‹ï¼ˆå®˜æ–¹ä»‹ç»ï¼‰ã€‚ ç¬¬ä¸€æ­¥ The loop concept of â€˜nowâ€™ is updated. The event loop caches the current time at the start of the event loop tick in order to reduce the number of time-related system calls. &emsp;&emsp;ç¬¬ä¸€æ­¥æ˜¯æ›´æ–°æ—¶é—´ã€‚å¯¹åº”ä»£ç å¦‚ä¸‹ï¼š 1uv__update_time(loop); &emsp;&emsp;æ€»ç»“æ¥è¯´å°±æ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ›´æ–°æ—¶é—´ã€‚uv__update_timeå®ç°æˆ‘ä¸‹ä¸€ç¯‡æ¥ä»‹ç» ç¬¬äºŒæ­¥ If the loop is alive an iteration is started, otherwise the loop will exit immediately. So, when is a loop considered to be alive? If a loop has active and refâ€™d handles, active requests or closing handles itâ€™s considered to be alive. 1r = uv__loop_alive(loop); &emsp;&emsp;ç”¨uv__loop_aliveå‡½æ•°è·å–loopçŠ¶æ€ã€‚&emsp;&emsp;å¦‚æœuv__loop_aliveè¿”å›é›¶æˆ–è€…loop-&gt;stop_flag == 1è¯´æ˜loopç»ˆæ­¢ï¼Œç›´æ¥è·³è¿‡å¾ªç¯ï¼Œåˆ°ä»£ç æœ€ä¸‹é¢ï¼ˆè¿™é‡Œæœ‰ä¸€äº›æ€§èƒ½çš„å¤„ç†æš‚æ—¶ä¸ç®¡ ï¼‰ï¼Œé€€å‡ºï¼š 1234567/* The if statement lets gcc compile it to a conditional store. Avoids * dirtying a cache line. */ if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r; &emsp;&emsp;loop-&gt;stop_flag == 0çš„ä¸€ä¸ªæ¥æºæ˜¯è°ƒç”¨äº†uv_stopï¼Œè¿™ä¸ªå‡½æ•°åœ¨æ‰‹å†Œä¸­çœ‹è§ã€‚å®ƒçš„æºä»£ç ä¹Ÿå¾ˆæ¸…æ™°ã€‚ 123void uv_stop(uv_loop_t* loop) &#123; loop-&gt;stop_flag = 1;&#125; &emsp;&emsp;å¦‚æœloopçŠ¶æ€OKï¼Œé‚£ä¹ˆå°±è¿›å…¥å¾ªç¯ä¸­ã€‚ ç¬¬ä¸‰æ­¥ Due timers are run. All active timers scheduled for a time before the loopâ€™s concept of now get their callbacks called. &emsp;&emsp;å¯¹åº”ä»£ç è¿™ä¸€éƒ¨åˆ†ï¼š 1234567891011121314151617181920uv__run_timers(loop);å…¶å®ç°ï¼švoid uv__run_timers(uv_loop_t* loop) &#123; struct heap_node* heap_node; uv_timer_t* handle; for (;;) &#123; heap_node = heap_min(timer_heap(loop)); if (heap_node == NULL) break; handle = container_of(heap_node, uv_timer_t, heap_node); if (handle-&gt;timeout &gt; loop-&gt;time) break; uv_timer_stop(handle); uv_timer_again(handle); handle-&gt;timer_cb(handle); &#125;&#125; &emsp;&emsp;å°†å †é‡Œé¢å·²ç»è¶…æ—¶çš„æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬å››æ­¥ Pending callbacks are called. All I/O callbacks are called right after polling for I/O, for the most part. There are cases, however, in which calling such a callback is deferred for the next loop iteration. If the previous iteration deferred any I/O callback it will be run at this point. å¯¹åº”ï¼š 12345678910111213141516171819202122ran_pending = uv__run_pending(loop);å…¶å®ç°ï¼šstatic int uv__run_pending(uv_loop_t* loop) &#123; QUEUE* q; QUEUE pq; uv__io_t* w; if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue)) return 0; QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq); while (!QUEUE_EMPTY(&amp;pq)) &#123; q = QUEUE_HEAD(&amp;pq); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, pending_queue); w-&gt;cb(loop, w, POLLOUT); &#125; return 1;&#125; &emsp;&emsp;å°†loop-&gt;pending_queueä¸­çš„ä»»åŠ¡æ‹¿å‡ºæ¥è¿è¡Œã€‚ ç¬¬äº”ã€å…­ã€ä¹æ­¥ 5.Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active 6.Prepare handle callbacks are called. Prepare handles get their callbacks called right before the loop will block for I/O. 9.Check handle callbacks are called. Check handles get their callbacks called right after the loop has blocked for I/O. Check handles are essentially the counterpart of prepare handles. 123uv__run_idle(loop);uv__run_prepare(loop);uv__run_check(loop); &emsp;&emsp;è¿™ä¸‰éƒ¨ä¸ºä»€ä¹ˆè¦ä¸€èµ·è¯´å‘¢ï¼Ÿå› ä¸ºå®ƒä»¬çš„å®è´¨æ˜¯ä¸€æ ·çš„ã€‚åœ¨æ¯æ¬¡å¾ªç¯å›ºå®šçš„ä½ç½®è°ƒç”¨ã€‚&emsp;&emsp;è¿™ä¸‰ä¸ªå‡½æ•°å®šä¹‰åœ¨loop-watcher.cè¿™ä¸ªæ–‡ä»¶é‡Œé¢ï¼Œå®ƒä»¬æ˜¯ç”¨å®å®šä¹‰å®šä¹‰çš„ã€‚åªæ”¹äº†idleã€prepareã€checkè¿™ä¸‰ä¸ªåå­—çš„éƒ¨åˆ†ï¼Œå…¶ä½™éƒ¨åˆ†å‡½æ•°éƒ½æ˜¯ä¸€æ ·çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Copyright Joyent, Inc. and other Node contributors. All rights reserved. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */#include \"uv.h\"#include \"internal.h\"#define UV_LOOP_WATCHER_DEFINE(name, type) \\ int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) &#123; \\ uv__handle_init(loop, (uv_handle_t*)handle, UV_##type); \\ handle-&gt;name##_cb = NULL; \\ return 0; \\ &#125; \\ \\ int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) &#123; \\ if (uv__is_active(handle)) return 0; \\ if (cb == NULL) return UV_EINVAL; \\ QUEUE_INSERT_HEAD(&amp;handle-&gt;loop-&gt;name##_handles, &amp;handle-&gt;queue); \\ handle-&gt;name##_cb = cb; \\ uv__handle_start(handle); \\ return 0; \\ &#125; \\ \\ int uv_##name##_stop(uv_##name##_t* handle) &#123; \\ if (!uv__is_active(handle)) return 0; \\ QUEUE_REMOVE(&amp;handle-&gt;queue); \\ uv__handle_stop(handle); \\ return 0; \\ &#125; \\ \\ void uv__run_##name(uv_loop_t* loop) &#123; \\ uv_##name##_t* h; \\ QUEUE queue; \\ QUEUE* q; \\ QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue); \\ while (!QUEUE_EMPTY(&amp;queue)) &#123; \\ q = QUEUE_HEAD(&amp;queue); \\ h = QUEUE_DATA(q, uv_##name##_t, queue); \\ QUEUE_REMOVE(q); \\ QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q); \\ h-&gt;name##_cb(h); \\ &#125; \\ &#125; \\ \\ void uv__##name##_close(uv_##name##_t* handle) &#123; \\ uv_##name##_stop(handle); \\ &#125;UV_LOOP_WATCHER_DEFINE(prepare, PREPARE)UV_LOOP_WATCHER_DEFINE(check, CHECK)UV_LOOP_WATCHER_DEFINE(idle, IDLE) ç¬¬ä¸ƒæ­¥ Poll timeout is calculated. Before blocking for I/O the loop calculates for how long it should block. These are the rules when calculating the timeout:If the loop was run with the UV_RUN_NOWAIT flag, the timeout is 0.If the loop is going to be stopped (uv_stop() was called), the timeout is 0.If there are no active handles or requests, the timeout is 0.If there are any idle handles active, the timeout is 0.If there are any handles pending to be closed, the timeout is 0.If none of the above cases matches, the timeout of the closest timer is taken, or if there are no active timers, infinity. 12if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); &emsp;&emsp;è¿™éƒ¨åˆ†æ˜¯å–å†³äºuv_runçš„æ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼Œæš‚æ—¶ä¸ç»†çœ‹ã€‚ ç¬¬å…«æ­¥ The loop blocks for I/O. At this point the loop will block for I/O for the duration calculated in the previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point. 1uv__io_poll(loop, timeout); &emsp;&emsp;è¿™ä¸€éƒ¨åˆ†å¯¹äºä¸åŒæ“ä½œç³»ç»Ÿæœ‰æ‰€ä¸åŒï¼Œlinuxæ˜¯pollï¼Œmacæ˜¯kqueueã€‚ ç¬¬åæ­¥ Close callbacks are called. If a handle was closed by calling uv_close() it will get the close callback called. 1uv__run_closing_handles(loop); &emsp;&emsp;è°ƒç”¨å„ç±»çš„closeå›è°ƒå‡½æ•°ã€‚ ç¬¬åä¸€ã€åäºŒæ­¥ 11.Special case in case the loop was run with UV_RUN_ONCE, as it implies forward progress. Itâ€™s possible that no I/O callbacks were fired after blocking for I/O, but some time has passed so there might be timers which are due, those timers get their callbacks called.12.Iteration ends. If the loop was run with UV_RUN_NOWAIT or UV_RUN_ONCE modes the iteration ends and uv_run() will return. If the loop was run with UV_RUN_DEFAULT it will continue from the start if itâ€™s still alive, otherwise it will also end. &emsp;&emsp;å¯¹äºuv_runä¸åŒæ¨¡å¼çš„ä¸€ç‚¹ç‰¹æ®Šå¤„ç†ã€‚ 12345678910111213141516if (mode == UV_RUN_ONCE) &#123; /* UV_RUN_ONCE implies forward progress: at least one callback must have * been invoked when it returns. uv__io_poll() can return without doing * I/O (meaning: no callbacks) when its timeout expires - which means we * have pending timers that satisfy the forward progress constraint. * * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from * the check. */ uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; å°ç»“&emsp;&emsp;å®è§‚ä¸Šæ¢³ç†ä¸€ä¸‹æ•´ä¸ªäº‹ä»¶å¾ªç¯çš„è¿‡ç¨‹ã€‚","categories":[],"tags":[{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"åœ¨åå°è§£å†³å‰ç«¯å°ä¼™ä¼´è¯·æ±‚jsonæ—¶çš„CORSè·¨åŸŸé—®é¢˜ï¼Ÿ","slug":"problems9","date":"2019-10-04T11:30:06.000Z","updated":"2020-03-04T07:31:02.042Z","comments":true,"path":"2019/10/04/problems9/","link":"","permalink":"http://yoursite.com/2019/10/04/problems9/","excerpt":"","text":"å‰ç«¯å°ä¼™ä¼´åœ¨è¯·æ±‚æˆ‘åå°çš„jsonæ—¶å‡ºç°äº†è·¨åŸŸçš„æŠ¥é”™ã€‚æœ€åé€šè¿‡åç«¯æ·»åŠ å“åº”å¤´è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œæ€»ç»“ä¸€ä¸‹ã€‚ è§£å†³åŠæ³•1234res-&gt;addHeader(\"Access-Control-Allow-Origin\", \"*\");res-&gt;addHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PUT, OPTIONS, DELETE, PATCH\");res-&gt;addHeader(\"Access-Control-Max-Age\", \"3600\");res-&gt;addHeader(\"Access-Control-Allow-Headers\",\"Origin, X-Requested-With, Content-Type, Accept,token\"); corsæ˜¯æµè§ˆå™¨ä¸ºäº†å®‰å…¨çš„è§„å®šï¼Œåœ¨å®é™…ç¯å¢ƒä¸­æ˜¯å¾ˆé‡è¦çš„ï¼Œä½†åœ¨å‰åç«¯è°ƒè¯•æ—¶æˆ‘ä»¬ä¸éœ€è¦è¿™ä¸ªå®‰å…¨ä¿éšœï¼Œæ‰€ä»¥ç»™è¿”å›çš„å“åº”æ·»åŠ ä¸Šè¿™å››ä¸ªå¤´éƒ¨è®©æµè§ˆå™¨æ¥å—æˆ‘ä»¬çš„æŠ¥æ–‡å°±å¯ä»¥äº†ã€‚ æ¯ä¸ªé€‰é¡¹çš„æ„æ€ Access-Control-Allow-Originï¼šæºå¸¦äº†æœåŠ¡å™¨ç«¯éªŒè¯åçš„å…è®¸çš„è·¨åŸŸè¯·æ±‚åŸŸåï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªå…·ä½“çš„åŸŸåæˆ–æ˜¯ä¸€ä¸ª*ï¼ˆè¡¨ç¤ºä»»æ„åŸŸåï¼‰ã€‚ Access-Control-Expose-Headersï¼šå…è®¸è¿”å›ç»™è·¨åŸŸè¯·æ±‚çš„å“åº”å¤´åˆ—è¡¨ï¼Œåœ¨åˆ—è¡¨ä¸­çš„å“åº”å¤´çš„å†…å®¹ï¼Œæ‰å¯ä»¥è¢«æµè§ˆå™¨è®¿é—®ã€‚ Access-Control-Max-Ageï¼š ç”¨äºå‘ŠçŸ¥æµè§ˆå™¨å¯ä»¥å°†é¢„å…ˆæ£€æŸ¥è¯·æ±‚è¿”å›ç»“æœç¼“å­˜çš„æ—¶é—´ï¼Œåœ¨ç¼“å­˜æœ‰æ•ˆæœŸå†…ï¼Œæµè§ˆå™¨ä¼šä½¿ç”¨ç¼“å­˜çš„é¢„å…ˆæ£€æŸ¥ç»“æœåˆ¤æ–­æ˜¯å¦å‘é€è·¨åŸŸè¯·æ±‚ã€‚ Access-Control-Allow-Methodsï¼šç”¨äºå‘ŠçŸ¥æµè§ˆå™¨å¯ä»¥åœ¨å®é™…å‘é€è·¨åŸŸè¯·æ±‚æ—¶ï¼Œå¯ä»¥æ”¯æŒçš„è¯·æ±‚æ–¹æ³•ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªå…·ä½“çš„æ–¹æ³•åˆ—è¡¨æˆ–æ˜¯ä¸€ä¸ª*ï¼ˆè¡¨ç¤ºä»»æ„æ–¹æ³•ï¼‰ã€‚ Access-Control-Allow-Credentialsï¼š è¯¥å­—æ®µå¯é€‰ã€‚å®ƒçš„å€¼æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºæ˜¯å¦å…è®¸å‘é€Cookieã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒCookieä¸åŒ…æ‹¬åœ¨CORSè¯·æ±‚ä¹‹ä¸­ã€‚è®¾ä¸ºtrueï¼Œå³è¡¨ç¤ºæœåŠ¡å™¨æ˜ç¡®è®¸å¯ï¼ŒCookieå¯ä»¥åŒ…å«åœ¨è¯·æ±‚ä¸­ï¼Œä¸€èµ·å‘ç»™æœåŠ¡å™¨ã€‚è¿™ä¸ªå€¼ä¹Ÿåªèƒ½è®¾ä¸ºtrueï¼Œå¦‚æœæœåŠ¡å™¨ä¸è¦æµè§ˆå™¨å‘é€Cookieï¼Œåˆ é™¤è¯¥å­—æ®µå³å¯ã€‚ PSï¼š å¦‚æœè¦å‘é€Cookieï¼ŒAccess-Control-Allow-Originå°±ä¸èƒ½è®¾ä¸ºæ˜Ÿå·ï¼Œå¿…é¡»æŒ‡å®šæ˜ç¡®çš„ã€ä¸è¯·æ±‚ç½‘é¡µä¸€è‡´çš„åŸŸåã€‚åŒæ—¶ï¼ŒCookieä¾ç„¶éµå¾ªåŒæºæ”¿ç­–ï¼Œåªæœ‰ç”¨æœåŠ¡å™¨åŸŸåè®¾ç½®çš„Cookieæ‰ä¼šä¸Šä¼ ï¼Œå…¶ä»–åŸŸåçš„Cookieå¹¶ä¸ä¼šä¸Šä¼ ï¼Œä¸”ï¼ˆè·¨æºï¼‰åŸç½‘é¡µä»£ç ä¸­çš„document.cookieä¹Ÿæ— æ³•è¯»å–æœåŠ¡å™¨åŸŸåä¸‹çš„Cookieã€‚ å¦å¤–ä½œä¸ºä¸€ä¸ªå®Œæ•´çš„åå°æœåŠ¡å™¨ï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥èƒ½å¤Ÿå“åº”å®¢æˆ·ç«¯çš„CORS é¢„æ£€è¯·æ±‚ã€‚è¿™ä¸ªéƒ¨åˆ†MDNä¸Šå†™çš„å¾ˆå¥½ï¼Œè¿™é‡Œæ˜¯é“¾æ¥ã€‚åœ¨ç¬¬ä¸€æ¬¡å‘é€postä»¥å‰ï¼Œæµè§ˆå™¨ä¼šå…ˆå‘é€ä¸€ä¸ªCORS é¢„æ£€è¯·æ±‚ã€‚è¿™æ˜¯æˆ‘çš„æ—¥å¿—æ•æ‰åˆ°çš„æŠ¥æ–‡ï¼šåå°æŒ‰ç…§ä¸Šé¢MDNé“¾æ¥ä¸­çš„æ–¹å¼è¿”å›æŠ¥æ–‡ï¼Œç„¶ååå°å°±èƒ½æ”¶åˆ°å‰å°çš„PostæŠ¥æ–‡äº†ã€‚","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2.5)","slug":"rax3","date":"2019-08-14T10:40:51.000Z","updated":"2019-11-25T19:51:03.317Z","comments":true,"path":"2019/08/14/rax3/","link":"","permalink":"http://yoursite.com/2019/08/14/rax3/","excerpt":"","text":"ç‚¹ç‚¹åºŸè¯&emsp;&emsp;æœ€è¿‘æ²¡æœ‰å†å°†raxçš„æºç å¾€ä¸‹çœ‹ï¼Œraxå¯¹äºä¸€ä¸ªæ–°æ‰‹æ¥è¯´è¿˜æ˜¯ä½“é‡è¿‡å¤§ï¼Œåœ¨å°è¯•è‡ªå·±å†™å†™ï¼Œåœ¨å†™çš„æ—¶å€™é‡åˆ°äº†ä¸€äº›å‘ï¼Œä¹Ÿä½“ä¼šåˆ°äº†raxçš„ä¸€äº›å†™æ³•çš„ç²¾å¦™ä¹‹å¤„ï¼Œè®°å½•ä¸€ä¸‹ã€‚ å®å®šä¹‰å‡½æ•°çš„æ³¨æ„ç‚¹ï¼š&emsp;&emsp;æˆ‘å®šä¹‰äº†è¿™æ ·ä¸€ä¸ªå®å®šä¹‰å‡½æ•°ï¼š 12#define radixNthChild(h, n) \\ (radix_node**)((char*)&amp;h-&gt;data + h-&gt;size + padding(h-&gt;size) + n * sizeof(void*)) æˆ‘è¿™æ ·è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼š 1radixNthChild(new_cur, new_cur-&gt;size - 1) è¿™æ ·ä¸€ä¸ªè°ƒç”¨å¤§å®¶è§‰å¾—æœ‰é—®é¢˜å—ï¼Ÿå—¯ï¼Œè‚¯å®šæ˜¯æœ‰é—®é¢˜çš„ï¼Œä¸ç„¶æˆ‘è¯´å•¥?ã€‚ è¿™é‡Œï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¸€èˆ¬çš„è°ƒç”¨å‡½æ•°çš„æ€è·¯ï¼Œè¿™æ ·ä¸€ä¸ªè°ƒç”¨çš„è¿è¡Œè¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼š è®¡ç®—å‡ºnew_cur-&gt;size - 1 å¸¦å…¥radixNthChildå‡½æ•° å®é™…ä¸Šæ°æ°ç›¸åï¼Œå®å®šä¹‰çš„å¤„ç†åœ¨é¢„ç¼–è¯‘æ—¶ï¼ˆg++ -Eï¼‰ï¼Œå®å®šä¹‰æ˜¯å°†å¯¹äºçš„å®šä¹‰æ›¿æ¢æ‰ï¼Œæ‰€ä»¥åœ¨é¢„ç¼–è¯‘åçš„ç»“æœå¦‚ä¸‹ï¼š 12# 363 &quot;radix_tree.c&quot; memcpy((radix_node**)((char*)&amp;new_cur-&gt;data + new_cur-&gt;size + ((sizeof(void*) - (sizeof(radix_node) + new_cur-&gt;size) % sizeof(void*)) &amp; (sizeof(void*) - 1)) + new_cur-&gt;size - 1 * sizeof(void*)), &amp;keyOne, sizeof(void*)); å¯ä»¥çœ‹åˆ°æ˜¯ ï¼š + new_cur-&gt;size - 1 * sizeof(void)è€Œä¸æ˜¯æˆ‘æ‰€æƒ³çš„ï¼š + ï¼ˆnew_cur-&gt;size - 1ï¼‰ * sizeof(void) å¯ä»¥å¾—å‡ºå…¶è¿‡ç¨‹å…¶å®æ˜¯ï¼š å‡½æ•°å®å®šä¹‰æ›¿æ¢ è¿è¡Œæ—¶è®¡ç®— ç»“è®ºï¼š åœ¨å®å®šä¹‰å‡½æ•°è°ƒç”¨æ—¶æ³¨æ„æ‹¬å·çš„é—®é¢˜ï¼Œä¸åŠ æ‹¬å·å¯èƒ½ä¼šç”±äºè¿ç®—ç¬¦ä¼˜å…ˆçº§è€Œ å¯¼è‡´è¡¨è¾¾å¼æ„ä¹‰ä¸æˆ‘ä»¬æƒ³çš„æœ‰å‡ºå…¥? åœ°å€è¿ç®—æ³¨æ„ç‚¹å…ˆç»™å‡ºè¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼š 123struct test &#123; void* a, *b, *c;&#125;; int main(void) { cout &lt;&lt; sizeof(test) &lt;&lt; endl; test* p = new test; fprintf(stdout, &quot;%p:%p:%p:%p\\n&quot;, p, p + 1, (char*)p + 1, (int*)p+1); return 0; }&emsp;&emsp;åœ¨è¿™æ ·ä¸€ä¸ªæµ‹è¯•ä»£ç ä¸­ï¼Œå¤§å®¶è§‰å¾—p + 1, (char)p + 1, (int)p+1è¿™ä¸‰ä¸ªç»“æœï¼Œç›¸å¯¹äºpçš„æ•°å€¼ç›¸å·®å¤šå°‘å‘¢ï¼Ÿ&emsp;&emsp;è¿è¡Œç»“æœæ˜¯è¿™æ ·çš„ã€‚ç±»å‹ä¸åœ°å€çš„è¿ç®—æ˜¯æœ‰ç€å¯†åˆ‡å…³ç³»çš„ã€‚ p + 1æ˜¯ä¸€ä¸ªé»˜è®¤æƒ…å†µï¼Œ è¿™æ—¶1çš„æ„ä¹‰æ˜¯ä¸€ä¸ªpçš„åœ°å€å®½åº¦ (char*)p + 1ï¼Œpè¢«è§£é‡Šä¸ºcharç±»å‹æŒ‡é’ˆï¼ŒæŒ‡å‘çš„åœ°å€è¢«è§£é‡Šä¸ºcharï¼Œäºæ˜¯1å°±æ˜¯ä¸€ä¸ªcharçš„åœ°å€å®½åº¦ã€‚ æ€»ç»“ï¼š åœ¨è®¡ç®—åœ°å€æ—¶ï¼Œè¦æ³¨æ„è¿ç®—ç¬¦å·¦è¾¹å€¼çš„ç±»å‹ã€‚ä½ åŠ ä¸Šçš„1å¯èƒ½å¹¶ä¸æ˜¯ä¸€ä¸ªå­—èŠ‚çš„å¤§å°ã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(2)","slug":"rax2","date":"2019-08-12T10:51:18.000Z","updated":"2019-11-25T19:49:43.833Z","comments":true,"path":"2019/08/12/rax2/","link":"","permalink":"http://yoursite.com/2019/08/12/rax2/","excerpt":"","text":"ä»Šå¤©æˆ‘æƒ³è¦è¯´çš„æ˜¯raxä¸­çš„paddingè¿™ä¸ªå‡½æ•°ï¼Œæˆ‘æŸ¥äº†å¾ˆå¤šçš„èµ„æ–™ï¼Œå¤§å®¶çš„åšå®¢éƒ½å‘Šè¯‰æˆ‘ä»¬å†…å­˜å¯¹é½æé«˜æ€§èƒ½ï¼Œå´æ²¡æœ‰å»åˆ†æä¸ºä»€ä¹ˆï¼Œæ˜¯æœ‰æ ¹æ®è®©ä½œè€…é€‰æ‹©è¿™æ ·åšï¼Ÿå¦‚æœåªæ˜¯è¿™æ ·ç®€å•çš„æ”¾è¿‡ï¼Œæ€»æ„Ÿè§‰è®©äººæœ‰ä¸€ä¸çš„é—æ†¾ã€‚ &emsp;&emsp;å…ˆæŠŠä¸»è§’æ‹‰å‡ºæ¥ï¼š 12#define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1)) &emsp;&emsp;é¦–å…ˆè¦è¯´çš„æ˜¯raxPaddingçš„ä½œç”¨æ˜¯ï¼šè®©raxNewNodeç”³è¯·çš„å†…å­˜nodesizeæ˜¯8çš„å€æ•°ã€‚ 123456789101112raxNode *raxNewNode(size_t children, int datafield) &#123; size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+ sizeof(raxNode*)*children; if (datafield) nodesize += sizeof(void*); raxNode *node = rax_malloc(nodesize); if (node == NULL) return NULL; node-&gt;iskey = 0; node-&gt;isnull = 0; node-&gt;iscompr = 0; node-&gt;size = children; return node;&#125; ç¬¬ä¸€ä¸ªé—®é¢˜ï¼šå¯¹é½çš„ä¼˜åŠ¿&emsp;&emsp;è¿™ä¸ªå¹¶ä¸æ˜¯æˆ‘æƒ³è¯´çš„é‡ç‚¹ï¼Œè¿™é‡Œæ˜¯å¤§å®¶éƒ½è°ˆåˆ°çš„ï¼Œä¹Ÿå°±æ˜¯ç»è¿‡å†…å­˜å¯¹é½ä¹‹åï¼ŒCPUçš„å†…å­˜è®¿é—®é€Ÿåº¦å¤§å¤§æå‡ã€‚å¯¹äºæˆ‘æ¥è¯´ï¼Œè¿™ä¸ªç»“è®ºæ„Ÿè§‰è¿˜æ˜¯å¤ªæ¨¡ç³Šï¼Œè¿™æ˜¯ä¸€ä¸ªå®šæ€§çš„ç»“è®ºï¼Œå…·ä½“çš„åº•å±‚ç»†èŠ‚å¯¹äºæˆ‘ä»¬åˆå­¦è€…æ¥è¯´å€’æ˜¯æ²¡å¿…è¦å»æ·±ç©¶ã€‚ ç¬¬äºŒä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆè¦è¿™ä¹ˆå»åšï¼Ÿ&emsp;&emsp;raxçš„ä½œè€…è¿™æ ·çš„åšæ³•å…¶å®æ˜¯å‚è€ƒç»“æ„ä½“çš„åšæ³•ã€‚ä¸¾ä¸ªä¾‹å­ï¼š 123456struct X&#123; char a; int c; double b;&#125;S2; è¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼Œå®ƒçš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿç­”æ¡ˆæ˜¯16ã€‚åœ¨cè¯­è¨€çš„å†…éƒ¨ï¼Œåšäº†è¿™æ ·çš„å†…å­˜å¯¹é½å¤„ç†ï¼š è¿™é‡Œè½¬è½½äº†è¿™ç¯‡æ–‡ç« ä¸­çš„å¾ˆå¤šèµ„æºï¼Œå¤§å®¶ä¹Ÿå¯ä»¥å»çœ‹çœ‹è¿™ç¯‡æ–‡ç« ï¼Œå†™çš„å¾ˆä¸é”™ã€‚ä¹Ÿæœ‰æ›´å¤šä¾‹å­ã€‚ å›åˆ°raxä¸Šæ¥&emsp;&emsp; åœ¨raxçš„raxNodeè¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œå› ä¸ºä½¿ç”¨äº†æŸ”æ€§æ•°ç»„ï¼Œæ‰€ä»¥åœ¨cè¯­è¨€æœ¬èº«æ˜¯æ— æ³•å¸®åŠ©æˆ‘ä»¬å®ç°åƒä¸Šé¢ä¸€æ ·çš„å†…å­˜å¯¹é½çš„ï¼ˆsizeof(raxNode) == 4,æˆ‘ä»¬ç”³è¯·çš„å†…å­˜å¤§å°å†³å®šäº†æŸ”æ€§æ•°ç»„çš„é•¿åº¦ï¼Œè¯¦æƒ…è¯·ç™¾åº¦æŸ”æ€§æ•°ç»„ï¼‰ ï¼Œcè¯­è¨€å¯¹äºç»“æ„ä½“çš„ä¼˜åŒ–æ²¡æœ‰åŒ…å«æŸ”æ€§æ•°ç»„è¿™ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»è‡ªå·±æ¥æ¥ç®¡è¿™ä¸€éƒ¨åˆ†çš„å†…å­˜å¯¹é½ï¼Œä¿è¯ç¨‹åºçš„è¿è¡Œæ•ˆç‡ã€‚ typedef struct raxNode { uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; /* Number of children, or compressed string len. */ unsigned char data[]; } raxNode; è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"redisåŸºæ•°æ ‘raxæºç åˆ†æ(1)","slug":"rax1","date":"2019-08-11T16:11:44.000Z","updated":"2019-11-25T19:48:25.184Z","comments":true,"path":"2019/08/12/rax1/","link":"","permalink":"http://yoursite.com/2019/08/12/rax1/","excerpt":"","text":"&emsp;&emsp;æœ€è¿‘æƒ³ç”¨libuvå†™ä¸ªhttpæœåŠ¡å™¨ï¼Œçœ‹åˆ°äº†è¿™ä¸ªå¼€æºé¡¹ç›®haywireï¼Œåœ¨çœ‹åˆ°ç¬¬39æ¬¡æäº¤çš„æ—¶å€™ï¼Œä½œè€…ç”¨åŸºæ•°æ ‘æ¥å­˜å‚¨ä¸åŒè·¯ç”±çš„controllerï¼Œä¸è¿‡åœ¨åç»­ç‰ˆæœ¬ä¸­æ”¹ä¸ºäº†ä½¿ç”¨hashï¼Œä¸è¿‡æƒ³æ¥ä¸å¦‚æ­£å¥½å­¦å­¦åŸºæ•°æ ‘ï¼Œä½œè€…ä½¿ç”¨çš„åŸºæ•°æ ‘æ˜¯è¿™ä¸ªç‰ˆæœ¬radix_treeï¼Œè¿™ä¸ªç‰ˆæœ¬ç¼ºå°‘æ³¨é‡Šï¼Œä¸”å’Œä¸€èˆ¬æ€è·¯ä¸ä¸€æ ·çš„ä½¿ç”¨çš„æ˜¯äºŒå‰æ ‘è€ŒéNå‰æ ‘ï¼Œä¸ºäº†ç†è§£æ–¹ä¾¿ï¼Œæˆ‘é€‰æ‹©äº†æ³¨é‡Šè¾ƒå¤šçš„rax æ•°æ®ç»“æ„&emsp;&emsp;é¦–å…ˆè¦æåˆ°çš„æ˜¯raxçš„æ•°æ®ç»“æ„è®¾è®¡ï¼š 1234567typedef struct raxNode &#123; uint32_t iskey:1; /* Does this node contain a key? */ uint32_t isnull:1; /* Associated value is NULL (don&apos;t store it). */ uint32_t iscompr:1; /* Node is compressed. */ uint32_t size:29; / unsigned char data[];&#125; raxNode; è¿™é‡Œç¬¬ä¸€ä¸ªè¦è¯´åˆ°çš„ç‚¹æ˜¯ï¼šä½ è§‰å¾—è¿™æ ·ä¸€ä¸ªæ•°æ®ç»“æ„çš„å¤§å°æ˜¯å¤šå°‘ï¼Ÿ24ï¼Ÿ 16ï¼Ÿ è¿˜æ˜¯8ï¼Ÿ&emsp;&emsp;ç¬¬ä¸€ä¸ªåŸå› æ˜¯ä½åŸŸï¼Œä¹Ÿå°±æ˜¯ç»“æ„ä½“ä¸­çš„å†’å·ï¼š ï¼Œå†’å·åœ¨è¿™é‡Œå£°æ˜å®é™…éœ€è¦ä½¿ç”¨çš„ä½æ•°ï¼Œiskeyï¼Œisnullï¼Œiscomprï¼Œsizeå››ä¸ªä¸€å…±åŠ èµ·æ¥32ä½ï¼Œå 4ä¸ªå­—èŠ‚ã€‚&emsp;&emsp;ç¬¬äºŒä¸ªåŸå› æ˜¯data[]å 0ä¸ªå­—èŠ‚ã€‚unsigned char data[];è¿™æ ·ä¸€ä¸ªç»“æ„åœ¨è¿™é‡Œå¹¶ä¸æ˜¯ç†è§£æˆä¸€ä¸ªæŒ‡é’ˆ8ä¸ªå­—èŠ‚ã€‚è€Œæ˜¯ä¸€ä¸ªæŸ”æ€§æ•°ç»„çš„æ¦‚å¿µï¼Œå®ç°ä¸€ä¸ªå¯å˜é•¿åº¦ã€‚data[1]å ç»“æ„ä½“1ä¸ªå­—èŠ‚ï¼Œdata[2]å ç»“æ„ä½“2ä¸ªå­—èŠ‚â€¦â€¦.data[13]å 13ä¸ªå­—èŠ‚ã€‚æ•°ç»„ç±»å‹çš„å†…å­˜æ˜¯ç»“æ„ä½“ä¸­ç›´æ¥åˆ†é…çš„ï¼Œè€Œä¸æ˜¯åƒæŒ‡é’ˆä¸€æ ·éœ€è¦æˆ‘ä»¬åæ¥åˆ†é…ã€‚å¦‚ä¸‹å›¾å¯è§ï¼š 12345678910typedef struct raxNode &#123; unsigned char data[13];&#125; raxNode;int main(int argc, char *argv[])&#123; printf(&quot;%d\\n&quot;, sizeof(raxNode)); return 0;&#125; data[]&emsp;&emsp;æ¥ä¸‹æ¥æˆ‘ä»¬è¿˜æ˜¯è¦è°ˆdataï¼Œåœ¨è¿™é‡Œdataçš„æ„ä¹‰å¹¶ä¸æ˜¯ä¸€ä¸ªç®€å•çš„unsigned charæ•°ç»„ï¼Œå®ƒå­˜å‚¨çš„æ˜¯é”®å€¼keyå’ŒradixNodeæŒ‡é’ˆä¸¤ç§å˜é‡ã€‚å›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132dataçš„å®é™…ä½¿ç”¨æ–¹å¼åœ¨å¤§å¤šæ•°æ—¶å€™æ˜¯ä»¥å†…å­˜åœ°å€çš„æ–¹å¼è¿›è¡Œçš„ã€‚ 123456#define raxNodeLastChildPtr(n) ((raxNode**) ( \\ ((char*)(n)) + \\ raxNodeCurrentLength(n) - \\ sizeof(raxNode*) - \\ (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \\)) &emsp;&emsp;è¿™æ˜¯è®¿é—®æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯è®¿é—®å›¾ä¸­çš„A-ptrï¼‰ã€‚næ˜¯ä¸€ä¸ªraxNode*æŒ‡é’ˆï¼Œå¯¹è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„åœ°å€è¿›è¡Œï¼‹æ“ä½œæ¥å¾—åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚ èŠ‚ç‚¹çš„è¡¨ç¤ºå›¾æ¥è‡ªï¼šhttps://my.oschina.net/yunqi/blog/3039132&emsp;&emsp;å‡è®¾åŸºæ•°æ ‘ä¸­æœ‰â€œabcdâ€è¿™ä¸ªé”®å€¼çš„èŠ‚ç‚¹ã€‚é‚£ä¹ˆå®ƒçš„è¡¨ç¤ºå½¢å¼æ˜¯åƒä¸Šå›¾è¿™æ ·çš„ã€‚â€œabcdâ€è¿™ä¸ªèŠ‚ç‚¹çš„value-dataå­˜å‚¨åœ¨å›¾ç‰‡ä¸‹åŠéƒ¨åˆ†çš„èŠ‚ç‚¹å¤„ï¼Œå¹¶ä¸”ä¸‹é¢ä¸€ä¸ªèŠ‚ç‚¹iskeyè®¾ä¸º1.&emsp;&emsp;ä¸ºä»€ä¹ˆä¸æ˜¯ç›´æ¥åªæœ‰å›¾ç‰‡çš„ä¸ŠåŠéƒ¨åˆ†ï¼Œç”±å›¾ç‰‡ä¸ŠåŠéƒ¨åˆ†é‚£ä¸ªèŠ‚ç‚¹å°†iskeyè®¾ç½®ä¸º1å¹¶ä¸”å°†å€¼å­˜å‚¨åœ¨å…¶valueÂ·dataä¸­å‘¢ï¼Ÿåƒè¿™æ ·ï¼š [iskey:1][isnull: 0][iscompr:1][size:4][abcd] [z-ptr ][value-ptr] å…ˆç»™å‡ºç»“è®ºï¼š åœ¨raxä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å­˜åœ¨ï¼ˆiskey == 1ï¼‰æ˜¯ç”±dataä¸­å¯¹åº”çš„å­èŠ‚ç‚¹æ¥è¡¨ç¤ºçš„ã€‚åŸå› å¾ˆç®€å•ï¼šåœ¨è¿™ä¸ªä¾‹å­é‡Œé¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰å‹ç¼©çš„èŠ‚ç‚¹ï¼Œè¿™ä¸€å±‚ç”±aå’ŒAä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœåœ¨å½“å‰å±‚æ¬¡è¡¨ç¤ºï¼Œå¦‚ä½•åˆ†è¾¨ä½ æŒ‡å®šçš„æ˜¯aè¿˜æ˜¯Aï¼Ÿæ‰€ä»¥ç”¨å¼•å‡ºå­èŠ‚ç‚¹æ¥è¡¨ç¤ºã€‚ è¿™æ˜¯æˆ‘è¾¹çœ‹raxè¾¹å®ç°çš„ä¸€ä¸ªå°ç»ƒä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ•™ï¼šhttps://github.com/LurenAA/radix_tree ï¼Œå¥½æƒ³è¦ä¸ªstarï¼Œæ±‚æ±‚äº†ï¼Œå…„å¼ŸèŒ:kissing_heart:","categories":[],"tags":[{"name":"raxæºç é˜…è¯»","slug":"raxæºç é˜…è¯»","permalink":"http://yoursite.com/tags/rax%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"å¦‚ä½•é€€å‡ºnohupè¿è¡Œçš„ç¨‹åºï¼Ÿ","slug":"problems8","date":"2019-07-04T07:26:33.000Z","updated":"2020-03-04T07:28:03.201Z","comments":true,"path":"2019/07/04/problems8/","link":"","permalink":"http://yoursite.com/2019/07/04/problems8/","excerpt":"","text":"1ps -aux | grep ç¨‹åºå | grep -v grep ps -auxå¯ä»¥æ˜¾ç¤ºæ‰€æœ‰çš„è¿›ç¨‹ã€‚grep ç¨‹åºåæŸ¥æ‰¾ä½ è¦æ‰¾çš„ç¨‹åºã€‚grep -v grepè¿‡æ»¤æ‰grepè¿™ä¸ªè¿›ç¨‹ã€‚ è¿™æ ·å°±å¯ä»¥æ‰¾åˆ°è¿è¡Œè¯¥ç¨‹åºçš„è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œç„¶å 1kill pid","categories":[],"tags":[{"name":"é‡è§çš„é—®é¢˜","slug":"é‡è§çš„é—®é¢˜","permalink":"http://yoursite.com/tags/%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"}]}]}